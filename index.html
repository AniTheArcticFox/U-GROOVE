<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <!-- Apple Touch Icon for home screen -->
    <link rel="apple-touch-icon" href="ugroove1mobile.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="U-Groove">
    <link rel="icon" type="image/svg+xml" href="" id="dynamicFavicon">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ff6b35">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>
    <title>U-Groove</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --accent-color-bright: #ff6b35;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e0e0e0;
        }

        .container {
            background: #1a1a1a;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            max-width: 1200px;
            width: 100%;
            padding: 30px;
            border: 1px solid var(--accent-color-bright);
            padding-bottom: 400px;
        }

        h1 {
            text-align: center;
            color: var(--accent-color-bright);
            font-size: 28px;
        }
        h3 {
            text-align: center;
            color: var(--accent-color-bright);
            margin-bottom: 20px;
            font-size: 14px;
        }

        .color-picker-container {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-picker-label {
            color: #e0e0e0;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .color-picker-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .color-picker-wrapper input[type="color"] {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 50px;
            height: 50px;
            border: none;
            cursor: pointer;
        }

        .folder-section {
            margin-bottom: 25px;
        }

        .main-content {
            display: flex;
            gap: 30px;
            margin-bottom: 25px;
        }

        .visualizer-section {
            flex: 0 0 300px;
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .duration-control {
            margin-bottom: 15px;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--accent-color-bright);
        }

        .duration-control label {
            display: block;
            color: #ffffff;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .duration-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #3a3a3a;
            outline: none;
            -webkit-appearance: none;
        }

        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color-bright);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        .duration-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color-bright);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

.visualizer-canvas {
    background: #0f0f0f;
    border-radius: 10px;
    border: 1px solid var(--accent-color-bright);
    width: 100%;
    height: 100%;
    display: block;
}

        .playlist-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .folder-btn {
            width: 100%;
            padding: 15px;
            background: #2a2a2a;
            color: var(--accent-color-bright);
            border: 2px solid var(--accent-color-bright);
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .folder-btn:hover {
            background: var(--accent-color-bright);
            color: #1a1a1a;
        }
        .help{
            background: #2a2a2a;
            color: var(--accent-color-bright);
            font-size: 2rem;
            transition: all 0.3s;
        }

        .help:hover {
            background: var(--accent-color-bright);
            color: #2a2a2a;
            
        }

        .playlist {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--accent-color-bright);
            border-radius: 10px;
            background: #0f0f0f;
            margin-bottom: 15px;
        }

        .playlist-item {
            padding: 12px 15px;
            border-bottom: 1px solid #2a2a2a;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            color: #e0e0e0;
        }

        .playlist-item:last-child {
            border-bottom: none;
        }

        .playlist-item:hover {
            background: #2a2a2a;
        }

        .playlist-item.active {
            background: var(--accent-color-bright);
            color: #1a1a1a;
            font-weight: bold;
        }

        .playlist-item.playing::before {
            content: "â™ª ";
            margin-right: 8px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

.player-section {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 85%;
    max-width: 800px;
    background: rgba(26, 26, 26, 0.98);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid var(--accent-color-bright);
    box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.8);
    z-index: 1000;
}

.now-playing {
    text-align: center;
    margin-bottom: 10px;
    color: var(--accent-color-bright);
    font-size: 14px;
    font-weight: 500;
}

.controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.secondary-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
}

        .control-btn {
            background: #3a3a3a;
            color: var(--accent-color-bright);
            border: 2px solid var(--accent-color-bright);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: var(--accent-color-bright);
            color: #1a1a1a;
            transform: scale(1.1);
        }

        .control-btn.play-pause {
            width: 45px;
            height: 45px;
            font-size: 24px;
        }

        .control-btn.active {
            background: var(--accent-color-bright);
            color: #1a1a1a;
        }

        .progress-container {
            width: 100%;
            background: #3a3a3a;
            height: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent-color-bright);
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #999;
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }

        .section-label {
            display: block;
            color: var(--accent-color-bright);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        .filter-section {
            margin-bottom: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 10px;
            border: 1px solid var(--accent-color-bright);
        }

                .search-section {
            margin-bottom: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 10px;
            border: 1px solid var(--accent-color-bright);
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            background: #1a1a1a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: var(--accent-color-bright);
        }

        .search-input::placeholder {
            color: #666;
        }

        .tagging-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--accent-color-bright);
            margin-bottom: 25px;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            overflow-y: scroll;
            max-height: 200px;
        }

        .tag-pill {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid var(--accent-color-bright);
            background: transparent;
            color: var(--accent-color-bright);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-pill:hover {
            background: var(--accent-color-bright)40;
        }

        .tag-pill.active {
            background: var(--accent-color-bright);
            color: #1a1a1a;
            font-weight: 600;
        }

        .tag-pill.active::before {
            content: "âœ“ ";
        }

        .add-tag-btn {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px dashed var(--accent-color-bright);
            background: transparent;
            color: var(--accent-color-bright);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-tag-btn:hover {
            background: var(--accent-color-bright)20;
        }

        .tag-input {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid var(--accent-color-bright);
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 13px;
            outline: none;
            min-width: 120px;
        }

        .save-tags-btn {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--accent-color-bright);
            background: var(--accent-color-bright);
            color: #1a1a1a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-tags-btn:hover {
            background: #ff8c42;
            border-color: #ff8c42;
        }

        .save-tags-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #999;
            font-size: 14px;
            font-style: italic;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #3a3a3a;
            border-top-color: var(--accent-color-bright);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .playlist-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .playlist {
            flex: 1;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--accent-color-bright);
            border-radius: 10px;
            background: #0f0f0f;
        }

        .playback-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #3a3a3a;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: var(--accent-color-bright);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .playback-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #3a3a3a;
            outline: none;
            -webkit-appearance: none;
        }

        .playback-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color-bright);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        .playback-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-color-bright);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        audio {
            display: none;
        }

        .collapsible-section {
    position: relative;
}

.collapse-handle {
    background: transparent;
    border: none;
    color: var(--accent-color-bright);
    cursor: pointer;
    font-size: 18px;
    padding: 0;
    margin-left: 10px;
    transition: transform 0.3s;
    display: inline-block;
    vertical-align: middle;
}

.collapse-handle:hover {
    opacity: 0.7;
}

.collapse-handle.collapsed {
    transform: rotate(-90deg);
}

.collapsible-content {
    max-height: 500px;
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    opacity: 1;
}

.collapsible-content.collapsed {
    max-height: 0;
    opacity: 0;
    margin: 0 !important;
}

.player-section.collapsed {
    padding: 15px 20px;
}

.player-section.collapsed .controls {
    margin-bottom: 0;
}
.player-section.collapsed .trim-btn {
    display: none;
}

.player-compact {
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 20px;
}

.player-section.collapsed .player-compact {
    display: flex;
}

.player-compact-left {
    flex: 1;
    min-width: 0;
    text-align: left;
}

.player-compact-center {
    display: flex;
    gap: 15px;
    align-items: center;
}

.player-compact-right {
    flex: 1;
    min-width: 0;
    text-align: right;
}

.player-compact-title {
    color: var(--accent-color-bright);
    font-size: 14px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-compact-time {
    color: #999;
    font-size: 12px;
    white-space: nowrap;
}

.player-section.collapsed .controls,
.player-section.collapsed .now-playing,
.player-section.collapsed .progress-container,
.player-section.collapsed .time-display,
.player-section.collapsed .secondary-controls,
.player-section.collapsed .playback-controls {
    display: none;
}

.section-header {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
}

.speed-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.speed-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
}

.fade-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.fade-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
}

.fade-save-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.save-fades-btn {
    padding: 4px 10px;
    border-radius: 5px;
    border: 1px solid var(--accent-color-bright);
    background: transparent;
    color: var(--accent-color-bright);
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s;
    white-space: nowrap;
}

.save-fades-btn:hover {
    background: var(--accent-color-bright)40;
}

.speed-save-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.save-speed-btn {
    padding: 4px 10px;
    border-radius: 5px;
    border: 1px solid var(--accent-color-bright);
    background: transparent;
    color: var(--accent-color-bright);
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s;
    white-space: nowrap;
}

.save-speed-btn:hover {
    background: var(--accent-color-bright)40;
}

.checkbox-wrapper {
    display: flex;
    align-items: center;
    gap: 5px;
}

.checkbox-wrapper input[type="checkbox"] {
    width: 14px;
    height: 14px;
    cursor: pointer;
    accent-color: var(--accent-color-bright);
}

.checkbox-wrapper label {
    font-size: 11px;
    color: #e0e0e0;
    cursor: pointer;
    text-transform: none;
    margin: 0;
}

.speed-value-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.speed-arrow-btn {
    background: #3a3a3a;
    color: var(--accent-color-bright);
    border: 1px solid var(--accent-color-bright);
    border-radius: 5px;
    width: 24px;
    height: 24px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
}

.speed-arrow-btn:hover {
    background: var(--accent-color-bright)40;
}

.toggle-switch-container {
    display: flex;
    gap: 15px;
    margin-bottom: 12px;
    align-items: center;
}

.toggle-switch {
    display: flex;
    border: 2px solid;
    border-radius: 20px;
    overflow: hidden;
    background: #1a1a1a;
}

.toggle-option {
    padding: 6px 16px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    transition: all 0.2s;
    border: none;
    background: transparent;
}

.toggle-option.active {
    color: #1a1a1a;
}

.visualizer-controls-section {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 15px;
}

.visualizer-control-group {
    margin-bottom: 12px;
}

.visualizer-control-group:last-child {
    margin-bottom: 0;
}

.visualizer-control-group label {
    display: block;
    color: #e0e0e0;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 6px;
    text-transform: uppercase;
}

.visualizer-control-slider {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: #3a3a3a;
    outline: none;
    -webkit-appearance: none;
}

.visualizer-control-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
}

.visualizer-control-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.visualizer-toggle-btn {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    border: 2px solid;
    background: transparent;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    margin-bottom: 12px;
}

.visualizer-toggle-btn:hover {
    opacity: 0.8;
}


.sort-select:focus {
    border-color: var(--accent-color-bright);
}

.sort-order-btn:hover,
.scroll-to-song-btn:hover {
    background: #3a3a3a;
    border-color: var(--accent-color-bright);
}

.sort-select option {
    background: #2a2a2a;
    color: #e0e0e0;
}
.song-counter {
    text-align: center;
    padding: 10px;
    color: #888;
    font-size: 13px;
    font-weight: 500;
    background: #0f0f0f;
    border: 1px solid var(--accent-color-bright);
    border-radius: 10px;
    margin-top: -1px;
    margin-bottom: 15px;
}

.trim-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.trim-overlay.active {
    display: flex;
}

.trim-window {
    background: #1a1a1a;
    border: 2px solid var(--accent-color-bright);
    border-radius: 15px;
    padding: 20px;
    width: 90%;
    max-width: 1000px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
}

.trim-header {
    text-align: center;
    color: var(--accent-color-bright);
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}

.trim-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
}

.trim-zoom-btn {
    padding: 8px 15px;
    background: #2a2a2a;
    border: 2px solid var(--accent-color-bright);
    border-radius: 8px;
    color: var(--accent-color-bright);
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

.trim-zoom-btn:hover {
    background: var(--accent-color-bright);
    color: #1a1a1a;
}

.trim-time-display {
    flex: 1;
    display: flex;
    justify-content: space-around;
    color: #e0e0e0;
    font-size: 13px;
}

.trim-waveform-container {
    position: relative;
    background: #0f0f0f;
    border: 1px solid var(--accent-color-bright);
    border-radius: 10px;
    height: 300px;
    margin-bottom: 15px;
    overflow: hidden;
    cursor: grab;
}

.trim-waveform-container:active {
    cursor: grabbing;
}

.trim-waveform-canvas {
    width: 100%;
    height: 100%;
}

.trim-handle {
    position: absolute;
    top: 0;
    width: 3px;
    height: 100%;
    background: var(--accent-color-bright);
    cursor: ew-resize;
    z-index: 10;
}

.trim-handle::before {
    content: '';
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 60px;
    background: #353535;
    border: solid 2px white;
    border-radius: 10px;
    margin-left: -8.5px;
}

.trim-handle.start {
    left: 0;
}

.trim-handle.end {
    right: 0;
}

.trim-region {
    position: absolute;
    top: 0;
    height: 100%;
    background: rgba(255, 107, 53, 0.1);
    border-left: 3px solid var(--accent-color-bright);
    border-right: 3px solid var(--accent-color-bright);
    pointer-events: none;
}

.trim-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.trim-action-btn {
    padding: 12px 30px;
    border-radius: 8px;
    border: 2px solid var(--accent-color-bright);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.trim-cancel-btn {
    background: transparent;
    color: var(--accent-color-bright);
}

.trim-cancel-btn:hover {
    background: var(--accent-color-bright)40;
}

.trim-save-btn {
    background: var(--accent-color-bright);
    color: #1a1a1a;
}

.trim-save-btn:hover {
    background: #ff8c42;
    border-color: #ff8c42;
}

.trim-btn {
    padding: 10px 20px;
    background: #2a2a2a;
    border: 2px solid var(--accent-color-bright);
    border-radius: 8px;
    color: var(--accent-color-bright);
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
    margin-bottom: 10px;
}

.trim-btn:hover {
    background: var(--accent-color-bright);
    color: #1a1a1a;
}

.tag-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
    align-items: center;
}

.tag-category-select,
.tag-sort-select {
    padding: 8px 12px;
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 12px;
    outline: none;
    cursor: pointer;
    flex: 1;
}

.tag-category-select:focus,
.tag-sort-select:focus {
    border-color: var(--accent-color-bright);
}

.tag-sort-order-btn {
    padding: 8px 12px;
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 12px;
    cursor: pointer;
    min-width: 40px;
}

.tag-sort-order-btn:hover {
    background: #3a3a3a;
    border-color: var(--accent-color-bright);
}

.collapsible-section.collapsed .tag-controls {
    display: none;
}

.multi-select-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
    align-items: center;
}

.multi-select-btn,
.select-all-btn {
    padding: 8px 15px;
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 600;
}

.multi-select-btn.active {
    border-color: var(--accent-color-bright);
    background: var(--accent-color-bright);
    color: #1a1a1a;
}

.multi-select-btn:hover,
.select-all-btn:hover {
    background: #3a3a3a;
    border-color: var(--accent-color-bright);
}

.playlist-item-checkbox {
    width: 18px;
    height: 18px;
    margin-right: 10px;
    cursor: pointer;
    accent-color: var(--accent-color-bright);
    flex-shrink: 0;
}

.playlist-item.has-checkbox {
    display: flex;
    align-items: center;
}

.playlist-item-text {
    flex: 1;
    cursor: pointer;
}

.collapsible-section.collapsed .multi-select-controls {
    display: none;
}

.settings-section {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 10px;
    border: 1px solid var(--accent-color-bright);
    margin-bottom: 15px;
}

.setting-item {
    padding: 12px;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    background: #1a1a1a;
    margin-bottom: 10px;
}

.setting-item:last-child {
    margin-bottom: 0;
}

.setting-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
}

.setting-title {
    color: #e0e0e0;
    font-size: 14px;
    font-weight: 600;
    margin: 0;
}

.setting-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: var(--accent-color-bright);
}

.setting-subtitle {
    color: #999;
    font-size: 12px;
    line-height: 1.5;
    margin: 0;
}
.merge-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 12px;
}

.merge-buttons-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
}

.json-select-btn {
    padding: 10px 20px;
    border-radius: 8px;
    border: 2px solid var(--accent-color-bright);
    background: transparent;
    color: var(--accent-color-bright);
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    transition: all 0.2s;
    min-width: 100px;
}

.json-select-btn:hover {
    background: var(--accent-color-bright)40;
}

.json-select-btn.selected {
    background: linear-gradient(135deg, var(--accent-color-bright), #ff8c42);
    color: #1a1a1a;
    border-color: var(--accent-color-bright);
}

.merge-arrow {
    color: var(--accent-color-bright);
    font-size: 20px;
    font-weight: bold;
}

.merge-action-btn {
    padding: 12px 30px;
    border-radius: 8px;
    border: 2px solid var(--accent-color-bright);
    background: var(--accent-color-bright);
    color: #1a1a1a;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
    align-self: center;
}

.merge-action-btn:hover:not(:disabled) {
    background: #ff8c42;
    border-color: #ff8c42;
}

.merge-action-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: transparent;
    color: var(--accent-color-bright);
}

.json-file-info {
    color: #999;
    font-size: 11px;
    text-align: center;
    font-style: italic;
}

.metadata-loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.metadata-loading-overlay.active {
    display: flex;
}

.metadata-loading-content {
    background: #1a1a1a;
    border: 2px solid var(--accent-color-bright);
    border-radius: 15px;
    padding: 40px;
    text-align: center;
    min-width: 300px;
}

.metadata-loading-title {
    color: var(--accent-color-bright);
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 20px;
}

.metadata-loading-status {
    color: #e0e0e0;
    font-size: 16px;
    margin-bottom: 15px;
}

.metadata-progress-bar-container {
    width: 100%;
    height: 8px;
    background: #3a3a3a;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 10px;
}

.metadata-progress-bar {
    height: 100%;
    background: linear-gradient(135deg, var(--accent-color-bright), #ff8c42);
    width: 0%;
    transition: width 0.3s ease;
}

.metadata-loading-percentage {
    color: var(--accent-color-bright);
    font-size: 14px;
    font-weight: 600;
}

.tag-search-input {
    width: 100%;
    padding: 10px 15px;
    background: #1a1a1a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s;
    margin-bottom: 12px;
}

.tag-search-input:focus {
    border-color: var(--accent-color-bright);
}

.tag-search-input::placeholder {
    color: #666;
}

.tag-pill.hidden {
    display: none;
}

.visualizer-fullscreen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    max-width: none !important;
    flex: none !important;
    z-index: 9999 !important;
    background: #0a0a0a !important;
    padding: 20px !important;
    margin: 0 !important;
    border-radius: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: flex-start !important;
    align-items: center !important;
    box-sizing: border-box !important;
}

.visualizer-fullscreen > div {
    width: 95vw !important;
    height: calc(100vh - 220px) !important; /* Leave room for player at bottom */
    max-width: none !important;
    margin-top: 20px !important;
}

.visualizer-fullscreen .visualizer-canvas {
    width: 100% !important;
    height: 100% !important;
}

.hide-when-fullscreen {
    display: none !important;
}

body.visualizer-fullscreen-active {
    overflow: hidden !important;
}

#tagColorsBtn:hover {
    background: var(--accent-color-bright);
    color: #1a1a1a;
}

.tag-color-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 12px;
    background: #2a2a2a;
    border-radius: 8px;
    margin-bottom: 10px;
    border: 1px solid #3a3a3a;
}

.tag-color-item:hover {
    background: #333;
}

.tag-color-name {
    flex: 1;
    color: #e0e0e0;
    font-size: 14px;
    font-weight: 500;
}

.tag-color-picker-wrapper {
    position: relative;
    width: 40px;
    height: 40px;
    border-radius: 8px;
    border: 2px solid #fff;
    overflow: hidden;
    cursor: pointer;
}

.tag-color-picker-wrapper input[type="color"] {
    position: absolute;
    top: -5px;
    left: -5px;
    width: 50px;
    height: 50px;
    border: none;
    cursor: pointer;
}

.tag-weight-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.tag-weight-label {
    color: #999;
    font-size: 12px;
    min-width: 60px;
}

.tag-weight-slider {
    width: 100px;
    height: 6px;
    border-radius: 3px;
    background: #3a3a3a;
    outline: none;
    -webkit-appearance: none;
}

.tag-weight-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-color-bright);
    cursor: pointer;
}

.tag-weight-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-color-bright);
    cursor: pointer;
    border: none;
}

.song-color-picker-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
}

.song-color-dot {
    width: 30px;
    height: 30px;
    flex-shrink: 0;
}

.song-color-dot input[type="color"] {
    width: 40px;
    height: 40px;
}

.playlist-item.active span {
            color: #1a1a1a;
        }

        /* Last.fm Identification Styles */
.lastfm-result-item {
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

.lastfm-result-item:hover {
    border-color: var(--accent-color-bright);
    background: #333;
}

.lastfm-result-item.selected {
    border-color: var(--accent-color-bright);
    background: #333;
    box-shadow: 0 0 10px rgba(255, 107, 53, 0.3);
}

.lastfm-result-header {
    font-size: 16px;
    font-weight: bold;
    color: var(--accent-color-bright);
    margin-bottom: 10px;
}

.lastfm-result-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.lastfm-tag-chip {
    padding: 4px 10px;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 12px;
    font-size: 12px;
    color: #e0e0e0;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
}

.lastfm-tag-chip:hover {
    border-color: var(--accent-color-bright);
}

.lastfm-tag-chip.selected {
    background: var(--accent-color-bright);
    color: #1a1a1a;
    border-color: var(--accent-color-bright);
}

.lastfm-tag-chip.deselected {
    opacity: 0.4;
    text-decoration: line-through;
}

.identification-status {
    margin-left: auto;
    margin-right: 8px;
    font-size: 14px;
    color: inherit;
}
.identify-btn {
    background: transparent;
    border: none;
    color: var(--accent-color-bright);
    font-size: 16px;
    cursor: pointer;
    padding: 0 4px;
    transition: transform 0.2s;
}

.identify-btn:hover {
    transform: scale(1.2);
}

/* Master Tags Editor Styles */
.master-tag-item {
    background: #2a2a2a;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 15px;
    transition: all 0.2s;
}

.master-tag-item:hover {
    border-color: var(--accent-color-bright);
    background: #333;
}

.master-tag-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.master-tag-name {
    font-size: 16px;
    font-weight: bold;
    color: var(--accent-color-bright);
}

.master-tag-details {
    font-size: 12px;
    color: #999;
}

.master-tag-category-select {
    padding: 8px 12px;
    background: #1a1a1a;
    border: 1px solid var(--accent-color-bright);
    border-radius: 5px;
    color: #e0e0e0;
    font-size: 14px;
    cursor: pointer;
    min-width: 150px;
}

.master-tag-delete-btn {
    padding: 8px 16px;
    background: #d32f2f;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
}

.master-tag-delete-btn:hover {
    background: #f44336;
}
.tags-locked-checkmark {
    color: inherit;
    font-weight: bold;
    font-size: 16px;
}

.selected-tags-section {
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 2px solid #3a3a3a;
}

.selected-tags-header {
    color: var(--accent-color-bright);
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    margin-bottom: 8px;
    letter-spacing: 0.5px;
}

.selected-tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    min-height: 32px;
}

.tag.removed {
    opacity: 0.4;
    text-decoration: line-through;
    pointer-events: none;
}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="color-picker-container">
            <span class="color-picker-label">Accent</span>
            <div class="color-picker-wrapper">
                <input type="color" id="accentColorPicker1" value="var(--accent-color-bright)">
            </div>
            <div class="color-picker-wrapper">
                <input type="color" id="accentColorPicker2" value="#ff8c42">
            </div>
        </div>
        <div style="position: absolute; top: 80px; right: 30px; display: flex; gap: 10px; align-items: center;">
            <input type="checkbox" id="useTagColors" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent-color-bright);">
            <button id="tagColorsBtn" style="
                padding: 8px 15px;
                background: #2a2a2a;
                color: var(--accent-color-bright);
                border: 2px solid var(--accent-color-bright);
                border-radius: 8px;
                font-size: 12px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.2s;
            ">Tag Colors</button>
        </div>
        <div style="display: flex; justify-content: space-between;">
                <svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 197.09 197.09' style="width: 60px; height: 60px;" id="headerLogo">
                    <defs>
                        <linearGradient id='lg1' x1='18.3' y1='51.83' x2='178.93' y2='144.58' gradientUnits='userSpaceOnUse'>
                            <stop offset='0' stop-color="#ff6b35"/>
                            <stop offset='1' stop-color="#ff8c42"/>
                        </linearGradient>
                        <linearGradient id='lg2' x1='96.76' y1='67.87' x2='124.81' y2='84.06' xlink:href='#lg1'/>
                        <linearGradient id='lg3' x1='96.76' y1='126.45' x2='124.81' y2='142.64' gradientTransform='translate(221.95 .32) rotate(79.1)' xlink:href='#lg1'/>
                        <linearGradient id='lg4' x1='47.35' y1='68.57' x2='161.33' y2='134.37' xlink:href='#lg1'/>
                    </defs>
                    <circle fill='#231f20' cx='98.55' cy='98.55' r='98.55'/>
                    <circle fill='url(#lg1)' cx='98.61' cy='98.2' r='92.73'/>
                    <circle fill='#231f20' cx='99.87' cy='98.47' r='87.1'/>
                    <circle fill='url(#lg2)' cx='110.78' cy='75.97' r='16.19'/>
                    <circle fill='url(#lg3)' cx='110.78' cy='134.55' r='16.19' transform='translate(-42.28 217.89) rotate(-79.1)'/>
                    <path fill='url(#lg4)' d='M51.64,144.55c.05,1.91.18,5.43,2.5,7.95,1.12,1.22,3.58,3.14,6.82,4.09,1.33.39,10.31,3.02,15.91-2.73,3.01-3.09,3.47-7.24,3.64-9.32,2.12-25.98,2.03-72.69,2.05-76.36,0-.26,0-.67.05-1.22.76-9.69,10.47-15.74,11.05-16.09,3.91-2.36,7.38-2.91,11.22-3.52,4.04-.64,9.8-.55,15,.65,2.09.48,8.28,4.04,9.78,6.65.38.67,4.02,5.14,4.43,11.61.08,1.23.02,2.17,0,2.48-.86,14.19,1.91,73.11,1.04,79.43-.03.19-.13.9,0,1.83.37,2.54,2.22,4.23,2.61,4.57,3.37,2.93,9.58,2.44,12.13-.52,1-1.17,1.24-2.49,1.3-2.87,2.05-12.34-1.11-68.62-.78-83.35,0-.41.03-1,0-1.83-.29-9.3-5.01-18.76-11.74-24.65-6.05-5.3-12.08-7.35-22.57-8.22-14.15-1.18-26.53-.25-34.83,1.57-9.16,2-12.33,4.76-14.45,6.29-5.77,4.19-8.82,8.82-10.99,13.01-1.5,2.89-4.57,8.97-4.83,17.09-.03,1.09,0,1.9,0,2.22.21,7.42.12,50.09.64,71.24Z'/>
                </svg>
            <div>
                        <h1>U-GROOVE</h1>
                        <h3>Fine Tune Your Vibe</h3>
            </div>
            <button class="help" style="border: solid #ff6b35 2px; border-radius: 100px; height: 55px; width: 55px; display: flex; align-items: center; justify-content: center;">
                ?
            </button>
        </div>

        
        <div class="folder-section">
            <button class="folder-btn" onclick="selectFolder()">Select Music Folder</button>
        </div>

        <div class="main-content">
            <div style="max-width: 35%;">
            <div class="visualizer-section">
                <div class="visualizer-controls-section collapsible-section">
                    <div class="section-header">
                        <label class="section-label" style="margin-bottom: 0;">Visualizer Controls</label>
                        <button class="collapse-handle" onclick="toggleCollapse('visualizer')" id="visualizerCollapseBtn">â–¼</button>
                    </div>
                    <div class="collapsible-content" id="visualizerContent">
                        <button class="visualizer-toggle-btn" id="visualizerToggleBtn" onclick="toggleVisualizer()">Visualizer: ON</button>
                        
                        <div style="margin-bottom: 15px;">
                        <label style="display: block; color: #e0e0e0; font-size: 11px; font-weight: 600; margin-bottom: 8px;">Mode:</label>
                        <select id="visualizerModeSelect" onchange="setVisualizerMode(this.value)" style="width: 100%; padding: 10px; background: #2a2a2a; border: 2px solid var(--accent-color-bright); border-radius: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; outline: none;">
                            <option value="frequency">Frequency</option>
                            <option value="layered">Layered</option>
                            <option value="waveform">Waveform</option>
                            <option value="particles">Particles</option>
                            <option value="radial">Radial</option>
                            <option value="helix">DNA Helix</option>
                            <option value="random">ðŸŽ² Random</option>
                        </select>
                    </div>
                            <div class="visualizer-control-group"style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                                <input type="checkbox" id="opacityByVolume" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent-color, var(--accent-color-bright));">
                                <label for="opacityByVolume" style="color: #e0e0e0; font-size: 13px; cursor: pointer;">Pulse</label>
                            </div>

                        <div id="frequencyControls">
                            <div class="visualizer-control-group">
                                <label for="minFreqSlider">Min Frequency: <span id="minFreqValue">20</span> Hz</label>
                                <input type="range" id="minFreqSlider" class="visualizer-control-slider" min="20" max="2000" value="20">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="maxFreqSlider">Max Frequency: <span id="maxFreqValue">20000</span> Hz</label>
                                <input type="range" id="maxFreqSlider" class="visualizer-control-slider" min="1000" max="20000" value="20000">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="minHeightSlider">Min Bar Height: <span id="minHeightValue">0</span>%</label>
                                <input type="range" id="minHeightSlider" class="visualizer-control-slider" min="0" max="50" value="0">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="maxHeightSlider">Max Bar Height: <span id="maxHeightValue">100</span>%</label>
                                <input type="range" id="maxHeightSlider" class="visualizer-control-slider" min="50" max="100" value="100">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="durationSlider">Response Time: <span id="durationValue">50</span>ms</label>
                                <input type="range" id="durationSlider" class="duration-slider" min="10" max="1000" value="50">
                            </div>
                        </div>

                        <div id="waveformControls" style="display: none;">
                            <div class="visualizer-control-group">
                                <label for="waveformSensitivitySlider">Waveform Zoom: <span id="waveformSensitivityValue">5.0</span>x</label>
                                <input type="range" id="waveformSensitivitySlider" class="duration-slider" min="0.5" max="20.0" step="0.1" value="5.0">
                                <span id="waveformSensitivityValue">5.0x</span>
                            </div>
                        </div>
                        <div id="particlesControls" style="display: none;">
                            <div class="visualizer-control-group">
                                <label for="particleSpeedSlider">Movement Speed: <span id="particleSpeedValue">1.0</span>x</label>
                                <input type="range" id="particleSpeedSlider" class="visualizer-control-slider" min="0.1" max="3.0" step="0.1" value="1.0">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="particleCountSlider">Particle Count: <span id="particleCountValue">10</span></label>
                                <input type="range" id="particleCountSlider" class="visualizer-control-slider" min="1" max="100" step="1" value="10">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="particleSpreadSlider">Spawn Spread: <span id="particleSpreadValue">100</span>px</label>
                                <input type="range" id="particleSpreadSlider" class="visualizer-control-slider" min="0" max="300" step="10" value="100">
                            </div>
                        </div>
                        <div id="radialControls" style="display: none;">
                            <div class="visualizer-control-group">
                                <label for="radialRadiusSlider">Inner Radius: <span id="radialRadiusValue">30</span>%</label>
                                <input type="range" id="radialRadiusSlider" class="visualizer-control-slider" min="10" max="50" step="5" value="30">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="radialRotationSlider">Rotation Speed: <span id="radialRotationValue">0.5</span></label>
                                <input type="range" id="radialRotationSlider" class="visualizer-control-slider" min="0" max=".5" step="0.05" value="0.2">
                            </div>
                            <div class="visualizer-control-group" style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                                <input type="checkbox" id="radialMirror" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent-color, var(--accent-color-bright));" checked>
                                <label for="radialMirror" style="color: #e0e0e0; font-size: 13px; cursor: pointer;">Mirror Mode</label>
                            </div>
                        </div>
                        <div id="helixControls" style="display: none;">
                            <div class="visualizer-control-group">
                                <label for="helixSpeedSlider">Rotation Speed: <span id="helixSpeedValue">1.0</span>x</label>
                                <input type="range" id="helixSpeedSlider" class="visualizer-control-slider" min="0.1" max="3.0" step="0.1" value="1.0">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="helixTightnessSlider">Spiral Tightness: <span id="helixTightnessValue">3</span></label>
                                <input type="range" id="helixTightnessSlider" class="visualizer-control-slider" min="1" max="8" step="0.5" value="3">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="helixThicknessSlider">Line Thickness: <span id="helixThicknessValue">3</span>px</label>
                                <input type="range" id="helixThicknessSlider" class="visualizer-control-slider" min="1" max="8" step="1" value="3">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="helixSmoothingSlider">Smoothing: <span id="helixSmoothingValue">0.85</span></label>
                                <input type="range" id="helixSmoothingSlider" class="visualizer-control-slider" min="0.7" max=".99" step="0.01" value="0.85">
                            </div>
                        </div>
                        
                    </div>
                </div>
                    <div style="position: relative; width: 100%; height: 400px;">
                        <canvas id="visualizer" class="visualizer-canvas"></canvas>
                        <button id="visualizerFullscreenBtn" style="
                            position: absolute;
                            top: 10px;
                            right: 10px;
                            padding: 8px 15px;
                            background: #2a2a2a;
                            color: var(--accent-color-bright);
                            border: 2px solid var(--accent-color-bright);
                            border-radius: 8px;
                            font-size: 14px;
                            cursor: pointer;
                            font-weight: 600;
                            z-index: 10;
                            transition: all 0.2s;
                        ">â›¶</button>
                    </div>
            </div>

            <div class="settings-section">
                <label class="section-label">Advanced Controls</label>
                
                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Prioritize Tagging</h4>
                        <input type="checkbox" id="prioritizeNewSongsCheckbox" class="setting-checkbox" onchange="togglePrioritizeNewSongs()">
                    </div>
                    <p class="setting-subtitle">If a song has more than 4 tags, it will be skipped so you can focus on tagging songs with a low number of tags, unless all songs in your playlist have more than 4 tags.</p>
                </div>

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Repeat Prevention</h4>
                        <input type="checkbox" id="repeatPreventionCheckbox" class="setting-checkbox" onchange="toggleRepeatPrevention()">
                    </div>
                    <p class="setting-subtitle">Skip over any songs that have been played less than this many number of days ago, unless all songs in the list have been played before this range.</p>
                    <div class="setting-control" style="margin-top: 10px;">
                        <label style="color: #e0e0e0; font-size: 12px; margin-right: 10px;">Days:</label>
                        <input type="number" id="repeatPreventionDays" min="0" max="365" value="7" 
                            style="width: 80px; padding: 5px; background: #2a2a2a; color: #e0e0e0; border: 1px solid var(--accent-color-bright); border-radius: 5px;"
                            onchange="updateRepeatPreventionDays()">
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Auto-ID Songs</h4>
                    </div>
                    <p class="setting-subtitle">This will take the filename of all your loaded songs and attempt to match them with listings on Last.fm. This will change the visible name in your playlist to reflect the artist name and the song title, along with applying popular tags for that song or that artist. If there are any mistakes, you can manually re-identify songs using the edit pencil.</p>
                    
                    <div class="setting-control" style="margin-top: 12px;">
                        <label style="display: block; color: #e0e0e0; font-size: 12px; font-weight: 600; margin-bottom: 5px;">Exclude tags that appear this many times or less:</label>
                        <input type="number" id="autoIdMinTagThreshold" min="0" max="100" value="2" 
                            style="width: 80px; padding: 5px; background: #2a2a2a; color: #e0e0e0; border: 1px solid var(--accent-color-bright); border-radius: 5px;">
                        <span style="color: #888; font-size: 11px; margin-left: 8px;">(default: 2)</span>
                    </div>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="autoIdRunBtn" onclick="startBackgroundIdentification()" style="width: auto; min-width: 120px;">Run</button>
                        <p class="json-file-info" id="autoIdStatus" style="margin-top: 8px;">Not yet run</p>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Merge JSON Configs</h4>
                    </div>
                    <p class="setting-subtitle">If you use this app with two separate song folders, merge them together here. Select whichever JSON file is OLDER with the JSON 1 button, then select whichever JSON file is NEWER with the JSON 2 button, then click merge.</p>
                    
                    <div class="merge-controls">
                        <div class="merge-buttons-row">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                                <button class="json-select-btn" id="json1Btn" onclick="selectJsonFile(1)">JSON 1</button>
                                <span class="json-file-info" id="json1Info">No file selected</span>
                            </div>
                            <span class="merge-arrow">â†</span>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                                <button class="json-select-btn" id="json2Btn" onclick="selectJsonFile(2)">JSON 2</button>
                                <span class="json-file-info" id="json2Info">No file selected</span>
                            </div>
                        </div>
                        <button class="merge-action-btn" id="mergeBtn" onclick="mergeJsonFiles()" disabled>Merge</button>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Calculate Setlist Lengths</h4>
                    </div>
                    <p class="setting-subtitle">If you want to see how long it would take to play all the songs in the songs list, this will calculate the length of all the songs in your selected folder and display the cumulative length based on the songs available. Note that there may be some latency while this function runs depending on how many songs you have.</p>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="calculateDurationsBtn" onclick="calculateAllDurations()" style="width: auto; min-width: 120px;">Run</button>
                        <p class="json-file-info" id="durationStatus" style="margin-top: 8px;">Not yet calculated</p>
                    </div>
                </div>
                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Auto-trim Silence</h4>
                    </div>
                    <p class="setting-subtitle">This will go through your entire song library to trim the silence off the beginning and end of your tracks, leaving .1 seconds of silence at the beginning and 2 seconds of silence at the end.</p>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="autoTrimBtn" onclick="autoTrimSilence()" style="width: auto; min-width: 120px;">Run</button>
                        <p class="json-file-info" id="autoTrimStatus" style="margin-top: 8px;">Not yet run</p>
                    </div>
                </div>
                <!-- Global Speed Control -->
<div class="setting-item">
    <div class="setting-header">
        <div class="setting-info">
            <div class="setting-title">Global Speed Control</div>
            <div class="setting-subtitle">Temporarily adjust the speed of all songs played. This does not save the speed to any songs in the config.</div>
        </div>
    </div>
    <div class="speed-control">
        <label for="globalSpeedSlider">
            Speed: <span id="globalSpeedValue">100</span>%
        </label>
        <input 
            type="range" 
            id="globalSpeedSlider" 
            class="speed-slider" 
            min="95" 
            max="105" 
            value="100" 
            step=".25">
    </div>
</div>

                <!-- <div class="setting-item">

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Refresh Metadata Cache</h4>
                    </div>
                    <p class="setting-subtitle">Your app caches song metadata (album, track numbers, etc.) for faster loading. Use this to re-scan all songs and update the cache if you've changed metadata in your files.</p>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="refreshMetadataBtn" onclick="refreshMetadataCache()" style="width: auto; min-width: 120px;">Refresh Cache</button>
                        <p class="json-file-info" id="metadataCacheStatus" style="margin-top: 8px;">Cache loaded</p>
                    </div>
                </div>
                    <div class="setting-header">
                        <h4 class="setting-title">Write Song Edits to Copies</h4>
                    </div>
                    <p class="setting-subtitle">If you would like to apply the speed, trim, and fading changes you've made to all of your songs, this option will create a duplicate file with the changes made directly to the audio file, save the same tags as the original song to this new copy, and replace the tags of the old song with a single tag, 'Original from duped', that will be excluded by default. These duped songs will be moved to a separate folder in your songs folder.</p>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="writeSongEditsBtn" onclick="writeSongEdits()" style="width: auto; min-width: 120px;">Write Edits</button>
                        <p class="json-file-info" id="writeEditsStatus" style="margin-top: 8px;">Calculating...</p>
                    </div>
                </div> -->
            </div>
        </div>
            <div class="playlist-wrapper" style="width: 50%;">
<div class="filter-section collapsible-section">
    <div class="section-header">
        <label class="section-label" style="margin-bottom: 0;">Filter by Tags</label>
        <button class="collapse-handle" onclick="toggleCollapse('filter')" id="filterCollapseBtn">â–¼</button>
    </div>
    <div class="collapsible-content" id="filterContent">
        <div class="tag-controls">
            <select id="filterCategorySelect" class="tag-category-select" onchange="changeTagCategory(this.value)">
                <option value="All">All Categories</option>
                <option value="Artist">Artists</option>
                <option value="Genre">Genres</option>
                <option value="Vibe">Vibes</option>
                <option value="Instrument">Instruments</option>
                <option value="Album">Albums</option>
                <option value="Playlist">Playlist</option>
                <option value="Structure">Structure</option>
                <option value="LastFM Tags">LastFM Tags</option>
                <option value="Utility">Utility</option>
            </select>
            <select id="filterSortSelect" class="tag-sort-select" onchange="changeTagSort(this.value)">
                <option value="alphabetical">A-Z</option>
                <option value="songCount">Song Count</option>
            </select>
            <button class="tag-sort-order-btn" id="filterSortOrderBtn" onclick="toggleTagSortOrder()">â†“</button>
        </div>
         <input type="text" class="tag-search-input" id="filterTagSearch" placeholder="Search tags...">
        <div class="toggle-switch-container" style="flex-wrap: wrap;">
            <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Select:</label>
            <div class="toggle-switch" id="tagSelectSwitch">
                <button class="toggle-option active" onclick="setTagSelectMode('single')">Single</button>
                <button class="toggle-option" onclick="setTagSelectMode('multi')">Multi</button>
            </div>
            <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Match:</label>
            <div class="toggle-switch" id="tagMatchSwitch">
                <button class="toggle-option active" onclick="setTagMatchMode('and')">AND</button>
                <button class="toggle-option" onclick="setTagMatchMode('or')">OR</button>
            </div>
                <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Mode:</label>
                <div class="toggle-switch" id="tagFilterModeSwitch">
                    <button class="toggle-option active" onclick="setTagFilterMode('include')">Include</button>
                    <button class="toggle-option" onclick="setTagFilterMode('exclude')">Exclude</button>
                </div>
        </div>
        <div style="margin-bottom: 10px;">
            <button onclick="randomizeFilters()" style="
                width: 100%;
                padding: 12px;
                background: #2a2a2a;
                color: var(--accent-color-bright);
                border: 2px solid var(--accent-color-bright);
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s;
            " onmouseover="this.style.background='var(--accent-gradient)'; this.style.color='#1a1a1a';" 
               onmouseout="this.style.background='#2a2a2a'; this.style.color='var(--accent-color-bright)';">
                ðŸŽ² Randomize
            </button>
            <div id="randomizeStatus" style="
                margin-top: 8px;
                font-size: 11px;
                color: #888;
                text-align: center;
                line-height: 1.4;
            "></div>
        </div>
        <div class="selected-tags-section">
            <div class="selected-tags-header">Active Filters:</div>
            <div id="selectedFiltersContainer" class="selected-tags-container">
                <!-- Selected filter tags will appear here -->
            </div>
        </div>
        <!-- Existing tags list -->
        <div class="tag-list" id="filterTags">
            <button class="tag-pill active" onclick="selectFilterTag('all')">All</button>
        </div>
    </div>
</div>
                <div class="search-section">
                    <input type="text" class="search-input" id="searchInput" placeholder="Search songs...">
                </div>

                <div class="sort-section" style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <div style="flex: 1; display: flex; gap: 8px;">
                        <select id="sortSelect" class="sort-select" style="flex: 1; padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; outline: none; cursor: pointer;">
                                <option value="title">Sort by Title</option>
                                <option value="artist">Sort by Artist</option>
                                <option value="modified">Sort by Date Modified</option>
                                <option value="size">Sort by File Size</option>
                                <option value="album">Sort by Album Order</option>
                                <option value="tagCount">Sort by Tag Count</option>
                                <option value="lastPlayed">Sort by Last Played Date</option>
                                <option value="locked">Sort by Locked Status</option>
                        </select>
                        <button class="sort-order-btn" id="sortOrderBtn" onclick="toggleSortOrder()" style="padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; min-width: 45px;">â†“</button>
                    </div>
                    <button class="scroll-to-song-btn" id="autoScrollToggle" onclick="scrollToCurrentSong()" style="padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; white-space: nowrap;">Scroll to Song</button>
                    <button class="scroll-to-song-btn" id="autoScrollToggle" onclick="toggleAutoScroll()" style="padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; white-space: nowrap;">ðŸ“ Auto-Scroll: ON</button>
                </div>
       <div class="song-counter" id="songCounter">
            0 songs
        </div>
    <div class="playlist" id="playlist">
        </div>
 

        <div class="tagging-section collapsible-section">
    <div class="section-header">
        <label class="section-label" style="margin-bottom: 0;">
            Add tags to song 
        </label>
        <button class="collapse-handle" onclick="toggleCollapse('tagging')" id="taggingCollapseBtn">â–¼</button>
    </div>
<div class="collapsible-content" id="taggingContent">
    <div class="multi-select-controls">
        <button class="multi-select-btn" id="multiSelectBtn" onclick="toggleMultiSelect()">Multi-Select</button>
        <button class="select-all-btn" id="selectAllBtn" onclick="toggleSelectAll()" style="display: none;">Select All</button>
        <button onclick="toggleLockTags()" class="multi-select-btn" id="lockTagsBtn" style="">
            ðŸ”“ Lock Tags
        </button>
<button onclick="openMasterTagsModal()" style="padding: 10px 20px; background: #2a2a2a; color: var(--accent-color-bright); border: 2px solid var(--accent-color-bright); border-radius: 10px; cursor: pointer; font-weight: 600;">
    Manage All Tags
</button>
        <button onclick="clearAllTags()" class="multi-select-btn" id="clearAllTagsBtn" style="background: #2a2a2a; color: #d32f2f; border-color: #d32f2f;">
    Clear All Tags
</button>
    </div>
            <div class="tag-controls">
            <select id="songCategorySelect" class="tag-category-select" onchange="changeTagCategory(this.value)">
                <option value="All">All Categories</option>
                <option value="Artist">Artists</option>
                <option value="Genre">Genres</option>
                <option value="Vibe">Vibes</option>
                <option value="Instrument">Instruments</option>
                <option value="Album">Albums</option>
                <option value="Playlist">Playlist</option>
                <option value="Structure">Structure</option>
                <option value="LastFM Tags">LastFM Tags</option>
                <option value="Utility">Utility</option>
            </select>
            <select id="songSortSelect" class="tag-sort-select" onchange="changeTagSort(this.value)">
                <option value="alphabetical">A-Z</option>
                <option value="songCount">Song Count</option>
            </select>
            <button class="tag-sort-order-btn" id="songSortOrderBtn" onclick="toggleTagSortOrder()">â†“</button>
        </div>
        <input type="text" class="tag-search-input" id="songTagSearch" placeholder="Search tags...">
        <!-- NEW: Selected song tags section -->
        <div class="selected-tags-section">
            <div class="selected-tags-header">Tags on This Song:</div>
            <div id="selectedSongTagsContainer" class="selected-tags-container">
                <!-- Selected song tags will appear here -->
            </div>
        </div>
        <!-- Existing tags list -->
        <div class="tag-list" id="songTags">
            <button class="add-tag-btn" onclick="showTagInput()">+ Add Tag</button>
        </div>
    </div>
</div>

<div class="player-section" id="playerSection">
    <button class="collapse-handle" onclick="toggleCollapse('player')" id="playerCollapseBtn" style="position: absolute; top: 15px; right: 15px; z-index: 10;">â–¼</button>
    
    <!-- Compact view (shown when collapsed) -->
    <div class="player-compact">
        <div class="player-compact-left">
            <div class="player-compact-title" id="compactTitle">No track playing</div>
        </div>
        <div class="player-compact-center">
            <button class="control-btn" onclick="previousTrack()" title="Previous">â®œ</button>
            <button class="control-btn play-pause" onclick="togglePlay()" id="playBtnCompact" title="Play/Pause">â–¶</button>
            <button class="control-btn" onclick="nextTrack()" title="Next">â®ž</button>
        </div>
        <div class="player-compact-right">
            <div class="player-compact-time" id="compactTime">0:00 / 0:00</div>
        </div>
    </div>

    <!-- Full view (shown when expanded) -->
    <!-- Primary controls (back, play, skip) -->
    <div class="controls">
        <button class="control-btn" onclick="previousTrack()" title="Previous">â®œ</button>
        <button class="control-btn play-pause" onclick="togglePlay()" id="playBtn" title="Play/Pause">â–¶</button>
        <button class="control-btn" onclick="nextTrack()" title="Next">â®ž</button>
    </div>

    <!-- Now playing and progress -->
    <div class="now-playing" id="nowPlaying">No track playing</div>
    
    <div class="progress-container" onclick="seekAudio(event)">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <div class="time-display">
        <span id="currentTime">0:00</span>
        <span id="duration">0:00</span>
    </div>
    <!-- Secondary controls (shuffle, loop, normalize) -->
    <div class="secondary-controls">
        <button class="control-btn" onclick="toggleShuffle()" id="shuffleBtn" title="Shuffle">ðŸ”€</button>
        <button class="control-btn" onclick="toggleLoop()" id="loopBtn" title="Loop">ðŸ”</button>
        <button class="control-btn" onclick="toggleNormalization()" id="normalizeBtn" title="Audio Normalization">ðŸ”Š</button>
    </div>
<div style="text-align: center; margin: 15px 0;">
            <div class="song-color-picker-wrapper" id="songColorPickerWrapper">
                <div class="color-picker-wrapper song-color-dot" id="songColor1Dot">
                    <input type="color" id="songColor1Picker">
                </div>
                <button class="trim-btn" onclick="openTrimWindow()">âœ‚ï¸ Trim Song</button>
                <div class="color-picker-wrapper song-color-dot" id="songColor2Dot">
                    <input type="color" id="songColor2Picker">
                </div>
            </div>
        </div>
    <div class="playback-controls">
    <div class="control-group">
        <label for="volumeSlider">Volume: <span id="volumeValue">100</span>%</label>
        <input type="range" id="volumeSlider" class="playback-slider" min="0" max="100" value="100">
    </div>
    <div class="control-group">
        <div class="speed-controls">
            <div class="speed-header">
                <div class="speed-value-controls">
                    <button class="speed-arrow-btn" onclick="adjustSpeed(-1)" title="Decrease 1%">â—€</button>
                    <label for="speedSlider" style="margin: 0;">Speed: <span id="speedValue">100</span>%</label>
                    <button class="speed-arrow-btn" onclick="adjustSpeed(1)" title="Increase 1%">â–¶</button>
                    <button class="speed-arrow-btn" onclick="resetSpeed()" title="Reset to 100%" style="min-width: 32px;">â†º</button>
                </div>
                <div class="speed-save-controls">
                    <button class="save-speed-btn" onclick="saveSpeed()">Save Speed</button>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="useSavedSpeedCheckbox" onchange="toggleUseSavedSpeed()">
                        <label for="useSavedSpeedCheckbox">Use Saved</label>
                    </div>
                </div>
            </div>
            <input type="range" id="speedSlider" class="playback-slider" min="25" max="200" value="100" step="1">
        </div>
    </div>
    <div class="control-group">
        <div class="fade-controls">
            <div class="fade-header">
                <label for="fadeInSlider" style="margin: 0;">Fade In: <span id="fadeInValue">0</span>s</label>
                <div class="fade-save-controls">
                    <button class="save-fades-btn" onclick="saveFades()">Save Fades</button>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="useSavedFadesCheckbox" onchange="toggleUseSavedFades()">
                        <label for="useSavedFadesCheckbox">Use Saved</label>
                    </div>
                </div>
            </div>
            <input type="range" id="fadeInSlider" class="playback-slider" min="0" max="8" value="0" step="1">
        </div>
    </div>
    <div class="control-group">
        <label for="fadeOutSlider">Fade Out: <span id="fadeOutValue">0</span>s</label>
        <input type="range" id="fadeOutSlider" class="playback-slider" min="0" max="8" value="0" step="1">
    </div>
</div>
</div>

        <div class="trim-overlay" id="trimOverlay">
            <div class="trim-window">
                <div class="trim-header" id="trimHeader">Trim: [Song Name]</div>
                
                <div class="trim-controls">
                    <button class="trim-zoom-btn" onclick="adjustTrimZoom(-2.5)">Zoom Out</button>
                    <button class="trim-zoom-btn" onclick="adjustTrimZoom(2.5)">Zoom In</button>
                    <button class="trim-zoom-btn" onclick="resetTrimZoom()">Reset Zoom</button>
                    
                    <div class="trim-time-display">
                        <span>Start: <strong id="trimStartTime">0:00.00</strong></span>
                        <span>End: <strong id="trimEndTime">0:00.00</strong></span>
                        <span>Duration: <strong id="trimDuration">0:00.00</strong></span>
                    </div>
                </div>
                
                <div class="trim-waveform-container" id="trimWaveformContainer">
                    <canvas class="trim-waveform-canvas" id="trimWaveformCanvas"></canvas>
                    <div class="trim-region" id="trimRegion"></div>
                    <div class="trim-handle start" id="trimHandleStart"></div>
                    <div class="trim-handle end" id="trimHandleEnd"></div>
                </div>
                
                <div class="trim-actions">
                    <button class="trim-action-btn trim-cancel-btn" onclick="closeTrimWindow()">Cancel</button>
                    <button class="trim-action-btn trim-save-btn" onclick="saveTrimSettings()">Save Trim</button>
                </div>
            </div>
        </div>
        <!-- <div class="help-overlay">
            <div class="help-container">
                <div class="help-header">
                    <h2>Help / FAQ</h2>
                    <button class="help-close-btn" onclick="toggleHelp()">âœ–</button>
                </div>
                <div class="help-listings">
                    <div class="help-listing">
                        <h2>How to Select a Music Folder</h2>
                        <p>Click the "Select Music Folder" button to choose the folder containing your music files. U-GROOVE will load all supported audio files from this folder and any sub-folders.</p>
                    </div>
                    <div class="help-listing">
                        <h2>How to filter my song list</h2>
                        <p>Click the "Select Music Folder" button to choose the folder containing your music files. U-GROOVE will load all supported audio files from this folder and any sub-folders.</p>
                    </div>
                </div>
            </div>
        </div> -->
    <div class="metadata-loading-overlay" id="metadataLoadingOverlay">
        <div class="metadata-loading-content">
            <div class="metadata-loading-title">Loading Song Metadata</div>
            <div class="metadata-loading-status" id="metadataLoadingStatus">Preparing...</div>
            <div class="metadata-progress-bar-container">
                <div class="metadata-progress-bar" id="metadataProgressBar"></div>
            </div>
            <div class="metadata-loading-percentage" id="metadataLoadingPercentage">0%</div>
        </div>
    </div>
    <!-- Tag Colors Modal -->
<div id="tagColorsOverlay" style="
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    justify-content: center;
    align-items: center;
">
    <div style="
        background: #1a1a1a;
        border: 2px solid var(--accent-color-bright);
        border-radius: 15px;
        padding: 30px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    ">
        <h2 style="color: var(--accent-color-bright); margin-bottom: 20px; text-align: center;">Tag Colors</h2>
        
        <!-- Search bar -->
        <input type="text" id="tagColorSearch" placeholder="Search tags..." style="
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 15px;
            outline: none;
        ">
        
        <!-- Tags list -->
        <div id="tagColorsList" style="
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            max-height: 50vh;
        "></div>
        
        <!-- Close button -->
        <button id="closeTagColorsBtn" style="
            padding: 12px;
            background: #2a2a2a;
            color: var(--accent-color-bright);
            border: 2px solid var(--accent-color-bright);
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 600;
        ">Close</button>
    </div>
</div>
        <audio id="audioPlayer"></audio>
    </div>

    <!-- Last.fm Identification Modal -->
<div id="lastfmIdentifyOverlay" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10000; align-items: flex-start; justify-content: center; padding-top: 5vh;">
    <div class="modal-content" style="max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
        <div class="modal-header">
            <h2>Identify Song with Last.fm</h2>
            <button class="modal-close" onclick="closeLastFMIdentifyModal()">Ã—</button>
        </div>
        
        <div class="lastfm-search-section" style="padding: 15px; border-bottom: 1px solid #2a2a2a;">
            <input type="text" id="lastfmSearchInput" placeholder="Search Last.fm..." 
                   style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
        </div>
        
        <div id="lastfmResultsContainer" style="flex: 1; overflow-y: auto; padding: 15px; min-height: 400px;">
            <!-- Results will be inserted here -->
        </div>
        
        <div class="modal-footer" style="padding: 15px; border-top: 1px solid #2a2a2a; display: flex; gap: 10px; justify-content: space-between;">
    <button onclick="showManualEntry()" style="padding: 10px 20px; background: #2a2a2a; color: var(--accent-color-bright); border: 1px solid var(--accent-color-bright); border-radius: 5px; cursor: pointer;">None of These</button>
    <div style="display: flex; gap: 10px;">
        <button onclick="closeLastFMIdentifyModal()" style="padding: 10px 20px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #444; border-radius: 5px; cursor: pointer;">Cancel</button>
        <button id="confirmLastFMBtn" onclick="confirmLastFMIdentification()" style="padding: 10px 20px; background: var(--accent-color-bright); color: #1a1a1a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;" disabled>Confirm</button>
    </div>
</div>
    </div>
</div>
<!-- Master Tags Editor Modal -->
<div id="masterTagsOverlay" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10000; align-items: center; justify-content: center;">
    <div class="modal-content" style="max-width: 900px; max-height: 85vh; display: flex; flex-direction: column; width: 90%;">
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center;">
            <h2>Manage All Tags</h2>
            <div style="display: flex; gap: 10px; align-items: center;">
                <label style="display: flex; align-items: center; gap: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; padding: 8px 12px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px;">
                    <input type="checkbox" id="blacklistDeletedTagsCheckbox" onchange="toggleBlacklistDeletedTags()" 
                           style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent-color-bright);">
                    <span>Blacklist Deleted Tags</span>
                </label>
                <button id="bulkDeleteBtn" onclick="bulkDeleteTags()" disabled
                        style="padding: 8px 16px; background: #d32f2f; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; opacity: 0.5;">
                    Delete Selected
                </button>
                <button id="bulkCategoryBtn" onclick="showBulkCategoryModal()" disabled
                        style="padding: 8px 16px; background: var(--accent-color-bright); color: #1a1a1a; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; opacity: 0.5;">
                    Change Category
                </button>
                <button class="modal-close" onclick="closeMasterTagsModal()">Ã—</button>
            </div>
        </div>
        
        <div style="padding: 20px; border-bottom: 1px solid #2a2a2a;">
            <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap;">
                <input type="text" id="masterTagSearch" placeholder="Search tags..." 
                       style="flex: 1; min-width: 200px; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
                
                <select id="masterTagCategoryFilter" 
                        style="padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px; cursor: pointer;">
                    <option value="all">All Categories</option>
                </select>
                
                <select id="masterTagSortOrder" 
                        style="padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px; cursor: pointer;">
                    <option value="alpha">A-Z</option>
                    <option value="count">Song Count</option>
                </select>
            </div>
        </div>
        
        <div id="masterTagsList" style="flex: 1; overflow-y: auto; padding: 20px;">
            <!-- Tags will be rendered here -->
        </div>
        
        <div class="modal-footer" style="padding: 15px; border-top: 1px solid #2a2a2a;">
            <button onclick="closeMasterTagsModal()" style="padding: 10px 20px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #444; border-radius: 5px; cursor: pointer;">Close</button>
        </div>
    </div>
</div>
    </div>
</div>
<!-- Tag Merge Modal -->
<div id="tagMergeOverlay" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10001; align-items: center; justify-content: center;">
    <div class="modal-content" style="max-width: 600px; width: 90%;">
        <div class="modal-header">
            <h2>Merge Tag: <span id="mergeTagName" style="color: var(--accent-color-bright);"></span></h2>
            <button class="modal-close" onclick="closeTagMergeModal()">Ã—</button>
        </div>
        
        <div style="padding: 20px;">
            <p style="color: #e0e0e0; margin-bottom: 20px;">
                Select a tag to merge into (this will move all songs and create an alias):
            </p>
            
            <div id="suggestedMergeTags" style="margin-bottom: 20px;">
                <!-- Suggested tags will be inserted here -->
            </div>
            
            <div style="margin-top: 20px;">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-weight: 600;">Or type a tag name:</label>
                <div style="position: relative;">
                    <input type="text" id="manualMergeTagInput" placeholder="Type tag name..." 
                           style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
                    <div id="mergeTagSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: #1a1a1a; border: 1px solid var(--accent-color-bright); border-radius: 5px; max-height: 200px; overflow-y: auto; display: none; z-index: 1000; margin-top: 5px;">
                        <!-- Autocomplete suggestions -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="modal-footer" style="padding: 15px; border-top: 1px solid #2a2a2a; display: flex; gap: 10px; justify-content: flex-end;">
            <button onclick="closeTagMergeModal()" style="padding: 10px 20px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #444; border-radius: 5px; cursor: pointer;">Cancel</button>
        </div>
    </div>
</div>
    <script>
        let configFileHandle = null;
        let songConfig = {}; // Structure: { songs: { "filename": { tags: [], speed: 100, trimStart: 0, trimEnd: 0 } }, appSettings: { accentColor1, accentColor2, useSavedSpeed, volume, isShuffled, isLooping } }
        let configDirHandle = null;
        const LASTFM_API_KEY = 'fd78579f16c1feaca839527a364f763b';
        const LASTFM_BASE_URL = 'https://ws.audioscrobbler.com/2.0/';
        let songBeingIdentified = null;
        let isEditingExistingSong = false;
        let currentSearchId = 0; 
        let sortBy = 'title'; // 'name', 'modified', 'size'
        let sortAscending = true;
        let audioFiles = [];
        let currentIndex = 0;
        let currentlyPlayingFile = null; // Track the actual playing song, independent of filtered list
        let isPlaying = false;
        let isShuffled = false;
        let isLooping = false;
        let originalOrder = [];
        let isNormalized = true; // Normalization on by default
        // Waveform scrolling variables
        let waveformBuffer = [];
        let waveformBufferSize = 4096; // Adjustable buffer size
        let waveformScrollSpeed = 1; // Pixels per frame
        
        // Web Audio API setup for normalization
        let audioContext;
        let sourceNode;
        let gainNode;
        let analyserNode;
        let compressorNode;
        let isAudioContextSetup = false;
        let playerExpanded = true;
        
        // Tagging system
// Tagging system with categories
let masterTags = {}; // Structure: { "tagName": { category: "Artist", songCount: 5 } }
let tagAliases = {};
let blacklistedTags = new Set();
let selectedSongTags = new Set(); // Currently selected tags for active song
let initialSongTags = new Set();
let selectedFilterTags = new Set(['all']); // Tags selected for filtering
let currentTagCategory = 'All'; // Current category filter: 'All', 'Artist', 'Genre', 'Vibe', 'Instrument', 'Album', 'Playlist,' 'Structure', 'Utility'
let tagSortBy = 'alphabetical'; // 'alphabetical' or 'songCount'
let tagSortAscending = true;
let tagFilterMode = 'include'; // 'include' or 'exclude'
let excludedFilterTags = new Set(); // Tags selected for exclusion
let multiSelectMode = false; // Whether multi-select is enabled
let selectedSongs = new Set(); // Set of selected song filenames
let lastSelectedIndex = -1; // Track last selected song for shift-click range selection
let lastSelectedMasterTagIndex = -1;
let prioritizeNewSongs = false;
let hasMarkedAsHeard = false; // Track if we've marked current song as heard
let globalSpeedAdjustment = 100; // Global speed control (90-110)

let json1Data = null;
let json2Data = null;
let json1FileName = '';
let json2FileName = '';
let songDurations = {}; // Store durations: filename -> duration in seconds
// Predefined master tag list with categories
let songMetadata = {}; // Store metadata: { filename: { artist, album, track, title } }
const PREDEFINED_TAGS = {
    'Original from duped': 'Utility'
};
        let searchQuery = ''; 
        let fileHandles = new Map(); // filename -> file handle for writing back
        let isLoadingMetadata = false; // Track if metadata is still loading
        const SERVER_URL = 'http://localhost:3001'; // Node.js server
        
        // Visualizer setup
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        let animationId;
        let barFallSpeeds = [];
        let barHeights = [];
        let responseDuration = 50; // milliseconds - how fast bars respond
        
        const audioPlayer = document.getElementById('audioPlayer');
        const playBtn = document.getElementById('playBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const loopBtn = document.getElementById('loopBtn');
        const normalizeBtn = document.getElementById('normalizeBtn');
        const progressBar = document.getElementById('progressBar');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const nowPlaying = document.getElementById('nowPlaying');
        const playlist = document.getElementById('playlist');
        const durationSlider = document.getElementById('durationSlider');
        const durationValue = document.getElementById('durationValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        let useSavedSpeed = false;
        let pendingTrimUpdates = new Map(); // filename -> {trimStart, trimEnd}
        let isSaving = false; // Add this lock
        let saveQueue = []; // Add this queue

        let useSavedFades = false;
        let currentFadeInDuration = 0;
        let currentFadeOutDuration = 0;
        let fadeInInterval = null;
        let fadeOutInterval = null;
        let originalVolume = 1.0;
        let isFadingIn = false;
        let isFadingOut = false;
        let opacityByVolume = false;
        let repeatPrevention = false;
        let repeatPreventionDays = 7;

        // Gradient color system
        let accentColor1 = '#ff6b35';
        let accentColor2 = '#ff8c42';
        let currentAccentGradient = `linear-gradient(135deg, ${accentColor1}, ${accentColor2})`;

        // Visualizer settings
        let visualizerEnabled = true;
        let visualizerMode = 'frequency'; // 'frequency' or 'waveform'
        let minFrequency = 20;
        let maxFrequency = 20000;
        let minBarHeight = 0;
        let maxBarHeight = 100;
        let waveformSensitivity = 5.0;
        let isTabVisible = true;
        let tagSearchQuery = '';

        // Tag filter modes
        let tagMatchMode = 'and'; // 'and' or 'or'
        let tagSelectMode = 'single'; // 'single' or 'multi'
        let autoScrollEnabled = true; // Auto-scroll to song when playing

        let useTagColors = false;
let savedAccentColor1 = accentColor1; // Store the original colors
let savedAccentColor2 = accentColor2;
let isTransitioningColors = false;
let selectedMasterTags = new Set();
// Add near the top of your script, after audioContext is declared
let wakeLock = null;

// Particle visualizer variables
let particles = [];
let particleSpeed = 1.0;
let particleBurstMultiplier = 1.0; // Multiplier for particles per burst
let particleSpread = 100; 
let peakThreshold = 200; // Base threshold for minimum volume
let lastPeakTime = { bass: 0, lowMid: 0, mid: 0, high: 0, veryHigh: 0 }; // Track last peak time for each range
let peakCooldown = 150; // Milliseconds between peaks
let energyHistory = { bass: [], lowMid: [], mid: [], high: [], veryHigh: [] }; // Track energy over time
const historyLength = 5; // Average over last 5 frames
let attackThreshold = 10; // How much energy needs to increase to trigger burst



// Initialize particle sliders
const particleSpeedSlider = document.getElementById('particleSpeedSlider');
const particleSpeedValue = document.getElementById('particleSpeedValue');
const particleCountSlider = document.getElementById('particleCountSlider');
const particleCountValue = document.getElementById('particleCountValue');

if (particleSpeedSlider) {
    particleSpeedSlider.addEventListener('input', (e) => {
        particleSpeed = parseFloat(e.target.value);
        particleSpeedValue.textContent = particleSpeed.toFixed(1) + 'x';
    });
    particleSpeedSlider.addEventListener('change', () => saveConfig());
}

if (particleCountSlider) {
    particleCountSlider.addEventListener('input', (e) => {
        // Convert slider value (50-300) to multiplier (0.33-2.0)
        particleBurstMultiplier = parseInt(e.target.value) / 150;
        particleCountValue.textContent = parseInt(e.target.value);
    });
    particleCountSlider.addEventListener('change', () => saveConfig());
}

// Particle spread slider
const particleSpreadSlider = document.getElementById('particleSpreadSlider');
const particleSpreadValue = document.getElementById('particleSpreadValue');

if (particleSpreadSlider) {
    particleSpreadSlider.addEventListener('input', (e) => {
        particleSpread = parseInt(e.target.value);
        particleSpreadValue.textContent = particleSpread;
    });
    particleSpreadSlider.addEventListener('change', () => saveConfig());
}
// Particle class
class Particle {
    constructor(x, y, size, speed, angle, opacity, color) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.speed = speed;
        this.angle = angle;
        this.opacity = opacity;
        this.initialOpacity = opacity;
        this.color = color;
        this.life = .3; // 1.0 = full life, 0.0 = dead
        this.isDying = false; // Flag to prevent resurrection
    }
    
    update() {
        // Move the particle
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        // Decay life
        this.life -= 0.008; // Slower decay for longer-lasting particles
        
        // Ensure life never goes negative or bounces back
        if (this.life <= 0) {
            this.life = 0;
            this.isDying = true;
        }
        
        // Update opacity based on life (no multiplier to keep particles visible longer)
        this.opacity = this.initialOpacity * Math.sqrt(this.life); // Square root for slower fade
    }
    
    draw(ctx) {
        // Don't draw if already dead
        if (this.isDying || this.life <= 0) {
            return;
        }
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen'; // Add blend mode
        ctx.globalAlpha = Math.max(0, this.opacity); // Ensure never negative
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    isDead() {
        return this.life <= 0 || this.isDying;
    }
}

// Radial visualizer variables
let radialInnerRadius = 30; // Percentage of canvas
let radialRotationSpeed = 0.2; // Degrees per frame
let radialRotation = 0; // Current rotation angle
let radialMirrorMode = true; // Mirror the bars inward and outward
let radialBarHeights = []; // Smoothed bar heights
let radialBarFallSpeeds = []; // Fall speeds for each bar

// Initialize radial sliders
const radialRadiusSlider = document.getElementById('radialRadiusSlider');
const radialRadiusValue = document.getElementById('radialRadiusValue');
const radialRotationSlider = document.getElementById('radialRotationSlider');
const radialRotationValue = document.getElementById('radialRotationValue');
const radialMirrorCheckbox = document.getElementById('radialMirror');

if (radialRadiusSlider) {
    radialRadiusSlider.addEventListener('input', (e) => {
        radialInnerRadius = parseInt(e.target.value);
        radialRadiusValue.textContent = radialInnerRadius + '%';
    });
    radialRadiusSlider.addEventListener('change', () => saveConfig());
}

if (radialRotationSlider) {
    radialRotationSlider.addEventListener('input', (e) => {
        radialRotationSpeed = parseFloat(e.target.value);
        radialRotationValue.textContent = radialRotationSpeed;
    });
    radialRotationSlider.addEventListener('change', () => saveConfig());
}

if (radialMirrorCheckbox) {
    radialMirrorCheckbox.addEventListener('change', (e) => {
        radialMirrorMode = e.target.checked;
        saveConfig();
    });
}

// DNA Helix visualizer variables
let helixRotation = 0;
let helixSpeed = 1.0;
let helixTightness = 3; // How many complete spirals across the canvas
let helixThickness = 3;
let helixSmoothedWaveform = []; // Smoothed waveform data
let helixSmoothedFrequency = []; // Smoothed frequency data
let helixSmoothingFactor = .7; // Higher = smoother (0-1)

// Initialize helix sliders
const helixSpeedSlider = document.getElementById('helixSpeedSlider');
const helixSpeedValue = document.getElementById('helixSpeedValue');
const helixTightnessSlider = document.getElementById('helixTightnessSlider');
const helixTightnessValue = document.getElementById('helixTightnessValue');
const helixThicknessSlider = document.getElementById('helixThicknessSlider');
const helixThicknessValue = document.getElementById('helixThicknessValue');

if (helixSpeedSlider) {
    helixSpeedSlider.addEventListener('input', (e) => {
        helixSpeed = parseFloat(e.target.value);
        helixSpeedValue.textContent = helixSpeed.toFixed(1) + 'x';
    });
    helixSpeedSlider.addEventListener('change', () => saveConfig());
}

if (helixTightnessSlider) {
    helixTightnessSlider.addEventListener('input', (e) => {
        helixTightness = parseFloat(e.target.value);
        helixTightnessValue.textContent = helixTightness;
    });
    helixTightnessSlider.addEventListener('change', () => saveConfig());
}

if (helixThicknessSlider) {
    helixThicknessSlider.addEventListener('input', (e) => {
        helixThickness = parseInt(e.target.value);
        helixThicknessValue.textContent = helixThickness + 'px';
    });
    helixThicknessSlider.addEventListener('change', () => saveConfig());
}
// Helix smoothing slider
const helixSmoothingSlider = document.getElementById('helixSmoothingSlider');
const helixSmoothingValue = document.getElementById('helixSmoothingValue');

if (helixSmoothingSlider) {
    helixSmoothingSlider.addEventListener('input', (e) => {
        helixSmoothingFactor = parseFloat(e.target.value);
        helixSmoothingValue.textContent = helixSmoothingFactor.toFixed(2);
    });
    helixSmoothingSlider.addEventListener('change', () => saveConfig());
}

// Last.fm search input handler
document.getElementById('lastfmSearchInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        // User typed manually, use regular search (not smart search)
        performLastFMSearch(false);
    }
});

// Master tags modal filters (only add if elements exist)
const masterTagSearch = document.getElementById('masterTagSearch');
const masterTagCategoryFilter = document.getElementById('masterTagCategoryFilter');
const masterTagSortOrder = document.getElementById('masterTagSortOrder');

if (masterTagSearch) {
    masterTagSearch.addEventListener('input', renderMasterTagsList);
}
if (masterTagCategoryFilter) {
    masterTagCategoryFilter.addEventListener('change', renderMasterTagsList);
}
if (masterTagSortOrder) {
    masterTagSortOrder.addEventListener('change', renderMasterTagsList);
}
// Random visualizer mode
let randomVisualizerMode = null; // Stores the actual mode when "random" is selected
const availableVisualizers = ['frequency', 'layered', 'waveform', 'particles', 'radial', 'helix'];
let usedVisualizers = []; // Track which visualizers have been used

function pickRandomVisualizer() {
    // If we've used all visualizers, reset the pool
    if (usedVisualizers.length >= availableVisualizers.length) {
        usedVisualizers = [];
    }
    
    // Get visualizers that haven't been used yet
    const remainingVisualizers = availableVisualizers.filter(v => !usedVisualizers.includes(v));
    
    // Pick a random one from the remaining
    const randomIndex = Math.floor(Math.random() * remainingVisualizers.length);
    const selected = remainingVisualizers[randomIndex];
    
    // Add to used list
    usedVisualizers.push(selected);
    
    return selected;
}

function getAverageEnergy(history) {
    if (history.length === 0) return 0;
    return history.reduce((a, b) => a + b, 0) / history.length;
}

// Helper function to get brighter color
function getLighterColor(color1, color2) {
    const r1 = parseInt(color1.slice(1, 3), 16);
    const g1 = parseInt(color1.slice(3, 5), 16);
    const b1 = parseInt(color1.slice(5, 7), 16);
    const r2 = parseInt(color2.slice(1, 3), 16);
    const g2 = parseInt(color2.slice(3, 5), 16);
    const b2 = parseInt(color2.slice(5, 7), 16);
    
    const brightness1 = r1 + g1 + b1;
    const brightness2 = r2 + g2 + b2;
    
    return brightness1 > brightness2 ? color1 : color2;
}

function getDarkerColor(color1, color2) {
    const r1 = parseInt(color1.slice(1, 3), 16);
    const g1 = parseInt(color1.slice(3, 5), 16);
    const b1 = parseInt(color1.slice(5, 7), 16);
    const r2 = parseInt(color2.slice(1, 3), 16);
    const g2 = parseInt(color2.slice(3, 5), 16);
    const b2 = parseInt(color2.slice(5, 7), 16);
    
    const brightness1 = r1 + g1 + b1;
    const brightness2 = r2 + g2 + b2;
    
    return brightness1 < brightness2 ? color1 : color2;
}

// Handle visibility changes and audio context suspension
document.addEventListener('visibilitychange', async () => {
    if (document.hidden) {
        console.log('Page hidden, preparing audio for background...');
        // Don't do anything - let it continue
    } else {
        console.log('Page visible, resuming audio context...');
        if (audioContext && audioContext.state === 'suspended') {
            await audioContext.resume();
            console.log('Audio context resumed');
        }
    }
});


// Listen for audio context state changes
if (audioContext) {
    audioContext.onstatechange = () => {
        console.log('Audio context state:', audioContext.state);
        if (audioContext.state === 'suspended' && isPlaying) {
            console.log('Context suspended while playing, attempting resume...');
            audioContext.resume();
        }
    };
}

// Handle page becoming active/inactive
window.addEventListener('focus', async () => {
    if (audioContext && audioContext.state === 'suspended' && isPlaying) {
        await audioContext.resume();
        console.log('Window focused, audio context resumed');
    }
});

window.addEventListener('blur', () => {
    console.log('Window blurred');
    // Keep audio context alive by not suspending
    if (audioContext && audioContext.state === 'running' && isPlaying) {
        // Force a keep-alive
        if (sourceNode) {
            sourceNode.connect(gainNode);
        }
    }
});
document.getElementById('opacityByVolume').addEventListener('change', (e) => {
    opacityByVolume = e.target.checked;
    saveConfig();
});
// Read metadata from audio file
async function readSongMetadata(file) {
    return new Promise((resolve) => {
        jsmediatags.read(file, {
            onSuccess: (tag) => {
                const tags = tag.tags;
                const metadata = {
                    album: tags.album || null,
                    track: tags.track || null,
                    year: tags.year || null
                };
                
                // Store in config
                const config = getSongConfig(file.name);
                
                // Always update metadata fields (user can edit later)
                config.album = metadata.album;
                config.track = metadata.track;
                config.year = metadata.year;
                config.metadataScanned = true; // Mark as scanned
                
                // Also store artist/title if not identified yet
                if (!config.identified) {
                    if (tags.artist) config.artist = tags.artist;
                    if (tags.title) config.title = tags.title;
                }
                
                songConfig[file.name] = config;
                
                resolve(metadata);
            },
            onError: (error) => {
                console.log('No metadata for:', file.name);
                
                // Even if reading failed, mark as scanned
                const config = getSongConfig(file.name);
                config.album = null;
                config.track = null;
                config.year = null;
                config.metadataScanned = true;
                songConfig[file.name] = config;
                
                resolve({
                    album: null,
                    track: null,
                    year: null
                });
            }
        });
    });
}

// Read comment field from audio file for tags
async function readCommentTags(file) {
    return new Promise((resolve) => {
        jsmediatags.read(file, {
            onSuccess: (tag) => {
                const tags = tag.tags;
                // Comment can be in different fields depending on format
                let comment = tags.comment?.text || tags.comment || tags.COMM?.data?.text || '';
                
                if (typeof comment === 'object') {
                    comment = comment.text || '';
                }
                
                if (comment && typeof comment === 'string') {
                    // Parse comma-separated tags, trim whitespace, convert to lowercase
                    const parsedTags = comment.split(',')
                        .map(t => t.trim().toLowerCase())
                        .filter(t => t.length > 0);
                    resolve(parsedTags);
                } else {
                    resolve([]);
                }
            },
            onError: (error) => {
                resolve([]);
            }
        });
    });
}

// Calculate Levenshtein distance between two strings
function levenshteinDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Create a matrix
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    
    // Initialize first column and row
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    // Fill the matrix
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i - 1][j],     // deletion
                    dp[i][j - 1],     // insertion
                    dp[i - 1][j - 1]  // substitution
                );
            }
        }
    }
    
    return dp[m][n];
}

// Calculate similarity percentage between two strings (0-100)
function calculateSimilarity(str1, str2) {
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();
    
    if (s1 === s2) return 100;
    
    const distance = levenshteinDistance(s1, s2);
    const maxLength = Math.max(s1.length, s2.length);
    
    if (maxLength === 0) return 100;
    
    return ((maxLength - distance) / maxLength) * 100;
}

// Find the best matching tag from master list
function findBestMatchingTag(inputTag, masterTagsList) {
    // Filter out tags less than 3 characters
    const validMasterTags = masterTagsList.filter(t => t.length >= 3);
    
    let bestMatch = null;
    let bestSimilarity = 0;
    
    for (const masterTag of validMasterTags) {
        const similarity = calculateSimilarity(inputTag, masterTag);
        if (similarity > bestSimilarity) {
            bestSimilarity = similarity;
            bestMatch = masterTag;
        }
    }
    
    // Return match only if similarity is >= 50%
    if (bestSimilarity >= 50) {
        return { tag: bestMatch, similarity: bestSimilarity };
    }
    
    return null;
}

// Show notification popup
function showNotification(message, duration = 5000) {
    // Remove any existing notification
    const existing = document.getElementById('tagImportNotification');
    if (existing) existing.remove();
    
    const notification = document.createElement('div');
    notification.id = 'tagImportNotification';
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, ${accentColor1}, ${accentColor2});
        color: #1a1a1a;
        padding: 15px 25px;
        border-radius: 10px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        max-width: 90%;
        text-align: center;
        animation: slideDown 0.3s ease-out;
    `;
    
    // Add animation keyframes if not already present
    if (!document.getElementById('notificationStyles')) {
        const style = document.createElement('style');
        style.id = 'notificationStyles';
        style.textContent = `
            @keyframes slideDown {
                from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
                to { transform: translateX(-50%) translateY(0); opacity: 1; }
            }
            @keyframes slideUp {
                from { transform: translateX(-50%) translateY(0); opacity: 1; }
                to { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    notification.innerHTML = message;
    document.body.appendChild(notification);
    
    // Auto-remove after duration
    setTimeout(() => {
        notification.style.animation = 'slideUp 0.3s ease-in forwards';
        setTimeout(() => notification.remove(), 300);
    }, duration);
}

async function loadMetadataWithCache(dirHandle) {
    console.log('Checking for metadata in config...');
    
    // Check how many songs need scanning
    const songsNeedingScanning = originalOrder.filter(file => {
        // Check if song exists in config AND has been scanned
        if (!songConfig[file.name]) {
            return true; // Song not in config at all - needs scanning
        }
        const config = songConfig[file.name];
        return !config.metadataScanned; // Song exists but hasn't been scanned
    });
    
    if (songsNeedingScanning.length === 0) {
        console.log('âœ“ All songs have metadata in config - skipping scan');
        return;
    }
    
    console.log(`Scanning metadata for ${songsNeedingScanning.length} songs...`);
    
    const overlay = document.getElementById('metadataLoadingOverlay');
    const status = document.getElementById('metadataLoadingStatus');
    const progressBar = document.getElementById('metadataProgressBar');
    const percentage = document.getElementById('metadataLoadingPercentage');
    
    overlay.classList.add('active');
    
    let loaded = 0;
    const totalToScan = songsNeedingScanning.length;
    
    for (const file of songsNeedingScanning) {
        await readSongMetadata(file);
        loaded++;
        
        if (loaded % 5 === 0 || loaded === totalToScan) {
            const percent = Math.round((loaded / totalToScan) * 100);
            status.textContent = `Scanning ${loaded} of ${totalToScan} songs...`;
            progressBar.style.width = `${percent}%`;
            percentage.textContent = `${percent}%`;
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }
    
    status.textContent = `âœ“ Scanned ${totalToScan} new songs!`;
    setTimeout(() => overlay.classList.remove('active'), 500);
    
    // Save config with newly scanned metadata
    await saveConfig();
    console.log('âœ“ Metadata saved to config');
}

// Load metadata for all songs (call this after loading files)
async function loadAllMetadata() {
    const overlay = document.getElementById('metadataLoadingOverlay');
    const status = document.getElementById('metadataLoadingStatus');
    const progressBar = document.getElementById('metadataProgressBar');
    const percentage = document.getElementById('metadataLoadingPercentage');
    
    // Show loading overlay
    overlay.classList.add('active');
    
    const totalSongs = originalOrder.length;
    console.log('Loading metadata for', totalSongs, 'songs...');
    
    let loadedCount = 0;
    let sampleLogged = false;
    
    for (const file of originalOrder) {
        if (!songMetadata[file.name]) {
            const metadata = await readSongMetadata(file);
            songMetadata[file.name] = metadata;
            
            // Log first 3 songs with track numbers as examples
            if (!sampleLogged && metadata.track && metadata.album) {
                console.log('Sample metadata for:', file.name);
                console.log('  Album:', metadata.album);
                console.log('  Track:', metadata.track, '(type:', typeof metadata.track, ')');
                console.log('  Artist:', metadata.artist);
                console.log('  Title:', metadata.title);
                
                loadedCount++;
                if (loadedCount >= 3) {
                    sampleLogged = true;
                }
            }
        }
        
        loadedCount++;
        
        // Update progress every 10 songs
        if (loadedCount % 10 === 0 || loadedCount === totalSongs) {
            const percent = Math.round((loadedCount / totalSongs) * 100);
            status.textContent = `Loading ${loadedCount} of ${totalSongs} songs...`;
            progressBar.style.width = `${percent}%`;
            percentage.textContent = `${percent}%`;
            
            // Allow UI to update
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }
    
    // Final update
    status.textContent = `âœ“ Loaded ${totalSongs} songs!`;
    progressBar.style.width = '100%';
    percentage.textContent = '100%';
    
    console.log('Metadata loaded for', Object.keys(songMetadata).length, 'songs');
    
    // Hide overlay after a brief delay
    setTimeout(() => {
        overlay.classList.remove('active');
    }, 500);
}

        // Load or create configuration file
async function loadOrCreateConfig(dirHandle) {
    configDirHandle = dirHandle;
    
    try {
        // Try to get existing config file
        configFileHandle = await dirHandle.getFileHandle('u-groove-config.json', { create: true });
        const file = await configFileHandle.getFile();
        const text = await file.text();
        
        if (text.trim()) {
            const loadedConfig = JSON.parse(text);
            
            // Handle old format (flat structure) or new format (with songs/appSettings)
            if (loadedConfig.songs) {
                songConfig = loadedConfig.songs;
            } else {
                // Old format - everything is song configs
                songConfig = loadedConfig;
            }
            
            // Load song durations if they exist
            if (loadedConfig.songDurations) {
                songDurations = loadedConfig.songDurations;
                console.log('Loaded', Object.keys(songDurations).length, 'song durations from config');
            }
            
            // Load app settings if they exist
            if (loadedConfig.appSettings) {
                const settings = loadedConfig.appSettings;
                
                // Apply accent colors
                if (settings.accentColor1 && settings.accentColor2) {
                    savedAccentColor1 = settings.accentColor1;
                    savedAccentColor2 = settings.accentColor2;
                    accentColor1 = settings.accentColor1;
                    accentColor2 = settings.accentColor2;
                    updateAccentColors(settings.accentColor1, settings.accentColor2);
                    document.getElementById('accentColorPicker1').value = settings.accentColor1;
                    document.getElementById('accentColorPicker2').value = settings.accentColor2;
                }
                
                // Apply volume
                if (settings.volume !== null && settings.volume !== undefined) {
                    volumeSlider.value = settings.volume;
                    volumeValue.textContent = settings.volume;
                    audioPlayer.volume = settings.volume / 100;
                }
                
                // Apply useSavedSpeed
                if (settings.useSavedSpeed !== null && settings.useSavedSpeed !== undefined) {
                    useSavedSpeed = settings.useSavedSpeed;
                    const checkbox = document.getElementById('useSavedSpeedCheckbox');
                    if (checkbox) checkbox.checked = useSavedSpeed;
                }
                
                // Apply useSavedFades
                if (settings.useSavedFades !== null && settings.useSavedFades !== undefined) {
                    useSavedFades = settings.useSavedFades;
                    const checkbox = document.getElementById('useSavedFadesCheckbox');
                    if (checkbox) checkbox.checked = useSavedFades;
                }
                
// Apply prioritizeNewSongs
                if (settings.prioritizeNewSongs !== null && settings.prioritizeNewSongs !== undefined) {
                    prioritizeNewSongs = settings.prioritizeNewSongs;
                    const checkbox = document.getElementById('prioritizeNewSongsCheckbox');
                    if (checkbox) checkbox.checked = prioritizeNewSongs;
                }

                 // Apply useTagColors
                if (settings.useTagColors !== null && settings.useTagColors !== undefined) {
                    useTagColors = settings.useTagColors;
                    const checkbox = document.getElementById('useTagColors');
                    if (checkbox) checkbox.checked = useTagColors;
                }
                
                // Apply repeatPrevention
                if (settings.repeatPrevention !== null && settings.repeatPrevention !== undefined) {
                    repeatPrevention = settings.repeatPrevention;
                    const checkbox = document.getElementById('repeatPreventionCheckbox');
                    if (checkbox) checkbox.checked = repeatPrevention;
                }
                
                // Apply repeatPreventionDays
                if (settings.repeatPreventionDays !== null && settings.repeatPreventionDays !== undefined) {
                    repeatPreventionDays = settings.repeatPreventionDays;
                    const input = document.getElementById('repeatPreventionDays');
                    if (input) input.value = repeatPreventionDays;
                }
                // Apply visualizer settings
                // Apply visualizer settings
                if (settings.visualizerMode !== null && settings.visualizerMode !== undefined) {
                    visualizerMode = settings.visualizerMode;
                    const select = document.getElementById('visualizerModeSelect');
                    if (select) {
                        select.value = visualizerMode;
                        // Don't call setVisualizerMode() here as it triggers saveConfig()
                        // Just show/hide controls directly
                        const frequencyControls = document.getElementById('frequencyControls');
                        const waveformControls = document.getElementById('waveformControls');
                        const particlesControls = document.getElementById('particlesControls');
                        const radialControls = document.getElementById('radialControls');
                        const helixControls = document.getElementById('helixControls');
                        
                        if (frequencyControls) frequencyControls.style.display = 'none';
                        if (waveformControls) waveformControls.style.display = 'none';
                        if (particlesControls) particlesControls.style.display = 'none';
                        if (radialControls) radialControls.style.display = 'none';
                        if (helixControls) helixControls.style.display = 'none';
                        
                        if (visualizerMode === 'frequency' || visualizerMode === 'layered') {
                            if (frequencyControls) frequencyControls.style.display = 'block';
                        } else if (visualizerMode === 'waveform') {
                            if (waveformControls) waveformControls.style.display = 'block';
                        } else if (visualizerMode === 'particles') {
                            if (particlesControls) particlesControls.style.display = 'block';
                        } else if (visualizerMode === 'radial') {
                            if (radialControls) radialControls.style.display = 'block';
                        } else if (visualizerMode === 'helix') {
                            if (helixControls) helixControls.style.display = 'block';
                        }
                    }
                }
                
                if (settings.minFrequency !== null && settings.minFrequency !== undefined) {
                    minFrequency = settings.minFrequency;
                    const slider = document.getElementById('minFreqSlider');
                    const value = document.getElementById('minFreqValue');
                    if (slider) slider.value = minFrequency;
                    if (value) value.textContent = minFrequency;
                }
                
                if (settings.maxFrequency !== null && settings.maxFrequency !== undefined) {
                    maxFrequency = settings.maxFrequency;
                    const slider = document.getElementById('maxFreqSlider');
                    const value = document.getElementById('maxFreqValue');
                    if (slider) slider.value = maxFrequency;
                    if (value) value.textContent = maxFrequency;
                }
                
                if (settings.minBarHeight !== null && settings.minBarHeight !== undefined) {
                    minBarHeight = settings.minBarHeight;
                    const slider = document.getElementById('minHeightSlider');
                    const value = document.getElementById('minHeightValue');
                    if (slider) slider.value = minBarHeight;
                    if (value) value.textContent = minBarHeight;
                }
                
                if (settings.maxBarHeight !== null && settings.maxBarHeight !== undefined) {
                    maxBarHeight = settings.maxBarHeight;
                    const slider = document.getElementById('maxHeightSlider');
                    const value = document.getElementById('maxHeightValue');
                    if (slider) slider.value = maxBarHeight;
                    if (value) value.textContent = maxBarHeight;
                }
                
                if (settings.responseDuration !== null && settings.responseDuration !== undefined) {
                    responseDuration = settings.responseDuration;
                    const slider = document.getElementById('durationSlider');
                    const value = document.getElementById('durationValue');
                    if (slider) slider.value = responseDuration;
                    if (value) value.textContent = responseDuration;
                }
                
                if (settings.waveformSensitivity !== null && settings.waveformSensitivity !== undefined) {
                    waveformSensitivity = settings.waveformSensitivity;
                    const slider = document.getElementById('waveformSensitivitySlider');
                    const value = document.getElementById('waveformSensitivityValue');
                    if (slider) slider.value = waveformSensitivity;
                    if (value) value.textContent = waveformSensitivity.toFixed(1) + 'x';
                }
                
                if (settings.particleSpeed !== null && settings.particleSpeed !== undefined) {
                    particleSpeed = settings.particleSpeed;
                    const slider = document.getElementById('particleSpeedSlider');
                    const value = document.getElementById('particleSpeedValue');
                    if (slider) slider.value = particleSpeed;
                    if (value) value.textContent = particleSpeed;
                }
                
                if (settings.particleBurstMultiplier !== null && settings.particleBurstMultiplier !== undefined) {
                    particleBurstMultiplier = settings.particleBurstMultiplier;
                    const slider = document.getElementById('particleCountSlider');
                    const value = document.getElementById('particleCountValue');
                    const sliderValue = Math.round(particleBurstMultiplier * 150);
                    if (slider) slider.value = sliderValue;
                    if (value) value.textContent = sliderValue;
                }
                
                if (settings.radialInnerRadius !== null && settings.radialInnerRadius !== undefined) {
                    const slider = document.getElementById('radialRadiusSlider');
                    const value = document.getElementById('radialRadiusValue');
                    if (slider) slider.value = settings.radialInnerRadius;
                    if (value) value.textContent = settings.radialInnerRadius;
                }
                
                if (settings.radialRotationSpeed !== null && settings.radialRotationSpeed !== undefined) {
                    radialRotationSpeed = settings.radialRotationSpeed;
                    const slider = document.getElementById('radialRotationSlider');
                    const value = document.getElementById('radialRotationValue');
                    if (slider) slider.value = radialRotationSpeed;
                    if (value) value.textContent = radialRotationSpeed;
                }
                
                if (settings.radialMirrorMode !== null && settings.radialMirrorMode !== undefined) {
                    radialMirrorMode = settings.radialMirrorMode;
                    const checkbox = document.getElementById('radialMirror');
                    if (checkbox) checkbox.checked = radialMirrorMode;
                }
                
                if (settings.helixSpeed !== null && settings.helixSpeed !== undefined) {
                    helixSpeed = settings.helixSpeed;
                    const slider = document.getElementById('helixSpeedSlider');
                    const value = document.getElementById('helixSpeedValue');
                    if (slider) slider.value = helixSpeed;
                    if (value) value.textContent = helixSpeed;
                }
                
                if (settings.helixTightness !== null && settings.helixTightness !== undefined) {
                    helixTightness = settings.helixTightness;
                    const slider = document.getElementById('helixTightnessSlider');
                    const value = document.getElementById('helixTightnessValue');
                    if (slider) slider.value = helixTightness;
                    if (value) value.textContent = helixTightness;
                }
                
                if (settings.helixThickness !== null && settings.helixThickness !== undefined) {
                    helixThickness = settings.helixThickness;
                    const slider = document.getElementById('helixThicknessSlider');
                    const value = document.getElementById('helixThicknessValue');
                    if (slider) slider.value = helixThickness;
                    if (value) value.textContent = helixThickness;
                }

                if (settings.helixSmoothingFactor !== null && settings.helixSmoothingFactor !== undefined) {
                    helixSmoothingFactor = settings.helixSmoothingFactor;
                    const slider = document.getElementById('helixSmoothingSlider');
                    const value = document.getElementById('helixSmoothingValue');
                    if (slider) slider.value = helixSmoothingFactor;
                    if (value) value.textContent = helixSmoothingFactor.toFixed(2);
                }
                
                
                if (settings.opacityByVolume !== null && settings.opacityByVolume !== undefined) {
                    opacityByVolume = settings.opacityByVolume;
                    const checkbox = document.getElementById('opacityByVolume');
                    if (checkbox) checkbox.checked = opacityByVolume;
                }
                // Apply saved filter tags
                if (settings.selectedFilterTags && Array.isArray(settings.selectedFilterTags)) {
                    selectedFilterTags = new Set(settings.selectedFilterTags);
                    console.log('Loaded selected filter tags:', Array.from(selectedFilterTags));
                }
                
                if (settings.excludedFilterTags && Array.isArray(settings.excludedFilterTags)) {
                    excludedFilterTags = new Set(settings.excludedFilterTags);
                    console.log('Loaded excluded filter tags:', Array.from(excludedFilterTags));
                }
                
                if (settings.tagFilterMode) {
                    tagFilterMode = settings.tagFilterMode;
                    console.log('Loaded tag filter mode:', tagFilterMode);
                }
                
                if (settings.tagSelectMode) {
                    tagSelectMode = settings.tagSelectMode;
                    console.log('Loaded tag select mode:', tagSelectMode);
                }
                
                if (settings.tagMatchMode) {
                    tagMatchMode = settings.tagMatchMode;
                    console.log('Loaded tag match mode:', tagMatchMode);
                }
                
                // Apply shuffle state
                if (settings.isShuffled !== null && settings.isShuffled !== undefined) {
                    isShuffled = settings.isShuffled;
                    if (isShuffled) {
                        shuffleBtn.classList.add('active');
                        shuffleBtn.style.background = currentAccentGradient;
                        shuffleBtn.style.color = '#1a1a1a';
                        shuffleBtn.style.borderColor = accentColor1;
                    }
                }
                
                // Apply loop state
                if (settings.isLooping !== null && settings.isLooping !== undefined) {
                    isLooping = settings.isLooping;
                    audioPlayer.loop = isLooping;
                    if (isLooping) {
                        loopBtn.classList.add('active');
                        loopBtn.style.background = currentAccentGradient;
                        loopBtn.style.color = '#1a1a1a';
                        loopBtn.style.borderColor = accentColor1;
                    }
                }
            }
            
            console.log('Loaded configuration:', Object.keys(songConfig).length, 'songs');

            // Load master tags if they exist
            if (loadedConfig.masterTags) {
                // Merge with predefined tags
                Object.keys(PREDEFINED_TAGS).forEach(tagName => {
                    if (!loadedConfig.masterTags[tagName]) {
                        loadedConfig.masterTags[tagName] = {
                            category: PREDEFINED_TAGS[tagName],
                            songCount: 0
                        };
                    }
                });
                masterTags = loadedConfig.masterTags;
                tagAliases = loadedConfig.tagAliases || {};
                blacklistedTags = new Set(loadedConfig.blacklistedTags || []);
            } else {
                // Build from scratch
                buildMasterTagsFromConfig();
            }
            
        } else {
            songConfig = {};
            console.log('Created new configuration file');
        }
    } catch (error) {
        console.error('Error loading config:', error);
        songConfig = {};
    }
}

function toggleHelp() {
    const helpOverlay = document.querySelector('.help-overlay');
    if (helpOverlay.style.display === 'flex') {
        helpOverlay.style.display = 'none';
    } else {
        helpOverlay.style.display = 'flex';
    }
}

// Update saveConfig to handle mobile mode
async function saveConfig() {
    // Don't save if no folder selected yet
    if (!configFileHandle && !configDirHandle) {
        console.log('No folder selected, skipping config save');
        return;
    }
    
    // Try file-based save first (desktop only)
    if (configFileHandle) {
        try {
            const configData = {
                songs: songConfig,
                masterTags: masterTags,
                tagAliases: tagAliases,
                blacklistedTags: Array.from(blacklistedTags),
                songDurations: songDurations,
                appSettings: {
                    accentColor1: savedAccentColor1,
                    accentColor2: savedAccentColor2,
                    useSavedSpeed: useSavedSpeed,
                    useSavedFades: useSavedFades,
                    prioritizeNewSongs: prioritizeNewSongs,
                    volume: parseInt(volumeSlider.value),
                    selectedFilterTags: Array.from(selectedFilterTags),
                    excludedFilterTags: Array.from(excludedFilterTags),
                    tagFilterMode: tagFilterMode,
                    tagSelectMode: tagSelectMode,
                    tagMatchMode: tagMatchMode, 
                    useTagColors: useTagColors,
                    repeatPrevention: repeatPrevention,
                    repeatPreventionDays: repeatPreventionDays,
                    // Visualizer settings
                    visualizerMode: visualizerMode,
                    minFrequency: minFrequency,
                    maxFrequency: maxFrequency,
                    minBarHeight: minBarHeight,
                    maxBarHeight: maxBarHeight,
                    responseDuration: responseDuration,
                    waveformSensitivity: waveformSensitivity,
                    particleSpeed: particleSpeed,
                    particleBurstMultiplier: particleBurstMultiplier,
                    particleSpread: particleSpread,
                    radialInnerRadius: parseInt(document.getElementById('radialRadiusSlider')?.value || 30),
                    radialRotationSpeed: radialRotationSpeed,
                    radialMirrorMode: radialMirrorMode,
                    helixSpeed: helixSpeed,
                    helixTightness: helixTightness,
                    helixThickness: helixThickness,
                    helixSmoothingFactor: helixSmoothingFactor,
                    opacityByVolume: opacityByVolume
                }
            };
            
            const writable = await configFileHandle.createWritable();
            await writable.write(JSON.stringify(configData, null, 2));
            await writable.close();
            console.log('Configuration saved to file');
        } catch (error) {
            console.error('Error saving config to file:', error);
        }
    } else {
        // Mobile mode - only save certain settings to localStorage
        try {
            const configData = {
                appSettings: {
                    accentColor1: accentColor1,
                    accentColor2: accentColor2,
                    volume: parseInt(volumeSlider.value),
                    selectedFilterTags: Array.from(selectedFilterTags),
                    excludedFilterTags: Array.from(excludedFilterTags),
                    tagFilterMode: tagFilterMode,
                    tagSelectMode: tagSelectMode,
                    tagMatchMode: tagMatchMode,
                    prioritizeNewSongs: prioritizeNewSongs
                }
            };
            localStorage.setItem('u-groove-mobile-settings', JSON.stringify(configData));
            console.log('Mobile settings saved to localStorage');
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }
}

// Get song configuration
function getSongConfig(filename) {
    return songConfig[filename] || {
        tags: [],
        speed: null,
        trimStart: null,
        trimEnd: null,
        FI: 0,
        FO: 0,
        heardb4: false,
        duped: false,
        cachedTagColor1: null,
        cachedTagColor2: null
    };
}

function markAsNotDuped(filename) {
    const config = getSongConfig(filename);
    if (config.duped === true) {
        updateSongConfig(filename, { duped: false });
        console.log(`Marked ${filename} as not duped due to property change`);
    }
}

// Update song configuration
function updateSongConfig(filename, updates) {
    if (!songConfig[filename]) {
        songConfig[filename] = {
            tags: [],
            speed: null,
            trimStart: null,
            trimEnd: null,
            FI: 0,
            FO: 0,
            heardb4: false,
            cachedTagColor1: null,
            cachedTagColor2: null
        };
    }
    
    Object.assign(songConfig[filename], updates);
}

function invalidateTagColorCache(filename) {
    const config = getSongConfig(filename);
    config.cachedTagColor1 = null;
    config.cachedTagColor2 = null;
    songConfig[filename] = config;
}

// Invalidate cached tag colors for all songs with a specific tag
function invalidateTagColorCacheForTag(tagName) {
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        if (config.tags && config.tags.includes(tagName)) {
            config.cachedTagColor1 = null;
            config.cachedTagColor2 = null;
        }
    });
}

// Build master tags from configuration
function buildMasterTagsFromConfig() {
    // Start fresh but preserve existing custom tags AND color/weight data
    const existingTagData = {};
    
    // Save all existing tag data (including color and weight)
    Object.keys(masterTags).forEach(tagName => {
        existingTagData[tagName] = {
            category: masterTags[tagName].category,
            songCount: 0,
            color: masterTags[tagName].color,
            weight: masterTags[tagName].weight
        };
    });
    
    // Initialize with predefined tags
    masterTags = {};
    Object.keys(PREDEFINED_TAGS).forEach(tagName => {
        masterTags[tagName] = {
            category: PREDEFINED_TAGS[tagName],
            songCount: 0
        };
        // Restore color and weight if they existed
        if (existingTagData[tagName]) {
            if (existingTagData[tagName].color) {
                masterTags[tagName].color = existingTagData[tagName].color;
            }
            if (existingTagData[tagName].weight) {
                masterTags[tagName].weight = existingTagData[tagName].weight;
            }
        }
    });
    
    // Re-add custom tags with their color/weight data
    Object.keys(existingTagData).forEach(tagName => {
        if (!PREDEFINED_TAGS[tagName]) {
            masterTags[tagName] = existingTagData[tagName];
        }
    });
    
    // NEW: Create a Set of actually loaded filenames for fast lookup
const loadedFilenames = new Set();
if (originalOrder && originalOrder.length > 0) {
    originalOrder.forEach(file => loadedFilenames.add(file.name));
}

// Count songs for each tag - ONLY from loaded songs
Object.keys(songConfig).forEach(filename => {
    // CRITICAL: Skip songs that aren't actually loaded in the current folder
    if (originalOrder && originalOrder.length > 0 && !loadedFilenames.has(filename)) {
        return; // Skip this song, it's not in the current folder
    }
    
    const config = songConfig[filename];
    if (config.tags && Array.isArray(config.tags)) {
        config.tags.forEach(tag => {
            // If tag exists in master list, increment count
            if (masterTags[tag]) {
                masterTags[tag].songCount++;
            } else {
                // Tag not in master list at all - this shouldn't happen now
                console.warn(`Found tag "${tag}" not in masterTags for ${filename}`);
                // Add it with a default category
                masterTags[tag] = {
                    category: 'LastFM Tags',
                    songCount: 1
                };
            }
        });
    }
});
    
    // Remove tags with 0 songs (tags that exist in config but not in loaded songs)
    Object.keys(masterTags).forEach(tagName => {
        if (masterTags[tagName].songCount === 0) {
            delete masterTags[tagName];
        }
    });
    
    console.log('Master tags rebuilt. Total tags:', Object.keys(masterTags).length);
}

// Parse filename to extract potential artist and title
function parseFilename(filename) {
    // Remove file extension
    let name = filename.replace(/\.(mp3|wav|ogg|m4a|flac)$/i, '');
    
    // Common patterns: "Artist - Title" or "Title - Artist"
    const dashPattern = /^(.+?)\s+-\s+(.+)$/;
    const match = name.match(dashPattern);
    
    if (match) {
        // Try to detect which is artist vs title
        // If first part has common artist indicators, it's probably artist
        const part1 = match[1].trim();
        const part2 = match[2].trim();
        
        // Check if part1 looks like it might be artist (has &, feat, vs, etc)
        if (/(&|feat\.|ft\.|featuring|vs\.)/i.test(part1)) {
            return { artist: part1, title: part2, query: name };
        }
        
        // Default: assume "Artist - Title" format
        return { artist: part1, title: part2, query: name };
    }
    
    // No clear pattern, return full name as query
    return { artist: null, title: null, query: name };
}

// Search Last.fm for track matches
async function searchLastFM(query, limit = 10, artist = null, track = null) {
    // Build search params based on what we have
    const params = new URLSearchParams({
        method: 'track.search',
        api_key: LASTFM_API_KEY,
        format: 'json',
        limit: limit
    });
    
    // If we have separate artist and track, use both
    if (artist && track) {
        params.append('artist', artist);
        params.append('track', track);
    } else {
        // Otherwise just search with the full query
        params.append('track', query);
    }
    
    try {
        const response = await fetch(`${LASTFM_BASE_URL}?${params}`);
        const data = await response.json();
        
        if (data.results && data.results.trackmatches && data.results.trackmatches.track) {
            let tracks = data.results.trackmatches.track;
            // API returns single object if only one result
            if (!Array.isArray(tracks)) {
                tracks = [tracks];
            }
            return tracks;
        }
        return [];
    } catch (error) {
        console.error('Last.fm search error:', error);
        return [];
    }
}

// Get track tags from Last.fm
async function getTrackTags(artist, track) {
    const methods = ['track.getInfo', 'track.gettoptags'];
    let allTags = [];
    
    for (const method of methods) {
        const params = new URLSearchParams({
            method: method,
            artist: artist,
            track: track,
            api_key: LASTFM_API_KEY,
            format: 'json'
        });
        
        try {
            const response = await fetch(`${LASTFM_BASE_URL}?${params}`);
            
            // Check if response is actually JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                console.warn(`Last.fm returned non-JSON response for ${method}`);
                continue;
            }
            
            const data = await response.json();
            
            let tags = [];
            if (method === 'track.getInfo' && data.track && data.track.toptags && data.track.toptags.tag) {
                const tagData = data.track.toptags.tag;
                tags = Array.isArray(tagData) ? tagData.map(t => t.name) : [tagData.name];
            } else if (method === 'track.gettoptags' && data.toptags && data.toptags.tag) {
                const tagData = data.toptags.tag;
                tags = Array.isArray(tagData) ? tagData.map(t => t.name) : [tagData.name];
            }
            
            allTags = allTags.concat(tags);
            await new Promise(resolve => setTimeout(resolve, 200)); // Rate limit
        } catch (error) {
            console.error(`Error fetching ${method}:`, error);
        }
    }
    
    return allTags;
}

// Get artist tags from Last.fm
async function getArtistTags(artist) {
    const params = new URLSearchParams({
        method: 'artist.gettoptags',
        artist: artist,
        api_key: LASTFM_API_KEY,
        format: 'json'
    });
    
    try {
        const response = await fetch(`${LASTFM_BASE_URL}?${params}`);
        
        // Check if response is actually JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            console.warn('Last.fm returned non-JSON response for artist:', artist);
            return [];
        }
        
        const data = await response.json();
        
        if (data.toptags && data.toptags.tag) {
            const tagData = data.toptags.tag;
            return Array.isArray(tagData) ? tagData.map(t => t.name) : [tagData.name];
        }
        return [];
    } catch (error) {
        console.error('Error fetching artist tags:', error);
        return [];
    }
}

// Get detailed track info from Last.fm (album, year, etc.)
async function getTrackInfo(artist, track) {
    const params = new URLSearchParams({
        method: 'track.getInfo',
        artist: artist,
        track: track,
        api_key: LASTFM_API_KEY,
        format: 'json'
    });
    
    try {
        const response = await fetch(`${LASTFM_BASE_URL}?${params}`);
        
        // Check if response is actually JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            console.warn('Last.fm returned non-JSON response for track.getInfo');
            return { album: null, year: null, duration: null };
        }
        
        const data = await response.json();
        
        if (data.track) {
            const album = data.track.album?.title || null;
            
            // Get duration in milliseconds (Last.fm returns it in ms)
            const duration = data.track.duration ? parseInt(data.track.duration) / 1000 : null; // Convert to seconds
            
            // Try to get year from album wiki or track wiki
            let year = null;
            
            // First try album wiki
            if (data.track.album?.wiki?.published) {
                const publishedDate = data.track.album.wiki.published;
                const yearMatch = publishedDate.match(/\d{4}/);
                if (yearMatch) {
                    year = yearMatch[0];
                }
            }
            
            // If no year from album, try track wiki
            if (!year && data.track.wiki?.published) {
                const publishedDate = data.track.wiki.published;
                const yearMatch = publishedDate.match(/\d{4}/);
                if (yearMatch) {
                    year = yearMatch[0];
                }
            }
            
            return { album, year, duration };
        }
        
        return { album: null, year: null, duration: null };
    } catch (error) {
        console.error('Error fetching track info:', error);
        return { album: null, year: null, duration: null };
    }
}

// Calculate string similarity (0-1)
function stringSimilarity(str1, str2) {
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();
    
    let longer = s1;
    let shorter = s2;
    if (s1.length < s2.length) {
        longer = s2;
        shorter = s1;
    }
    
    const longerLength = longer.length;
    if (longerLength === 0) {
        return 1.0;
    }
    
    return (longerLength - editDistance(longer, shorter)) / longerLength;
}

function editDistance(s1, s2) {
    s1 = s1.toLowerCase();
    s2 = s2.toLowerCase();
    
    const costs = [];
    for (let i = 0; i <= s1.length; i++) {
        let lastValue = i;
        for (let j = 0; j <= s2.length; j++) {
            if (i === 0) {
                costs[j] = j;
            } else if (j > 0) {
                let newValue = costs[j - 1];
                if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                    newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                }
                costs[j - 1] = lastValue;
                lastValue = newValue;
            }
        }
        if (i > 0) {
            costs[s2.length] = lastValue;
        }
    }
    
    return costs[s2.length];
}

// Calculate duration similarity score (0-1)
function durationSimilarity(fileDuration, lastfmDuration) {
    if (!fileDuration || !lastfmDuration) return null; // Can't compare if either is missing
    
    const difference = Math.abs(fileDuration - lastfmDuration);
    const toleranceSeconds = Math.max(15, fileDuration * 0.10); // 10% or 15 seconds
    
    if (difference <= toleranceSeconds) {
        // Within tolerance - perfect match
        return 1.0;
    } else if (difference <= fileDuration * 0.30) {
        // Within 30% - partial match (linear decay)
        const severity = (difference - toleranceSeconds) / (fileDuration * 0.20);
        return Math.max(0, 1.0 - severity);
    } else {
        // More than 30% difference - poor match
        return 0;
    }
}

// Attempt to automatically identify a song with Last.fm
async function autoIdentifySong(filename) {
    const config = getSongConfig(filename);
    
    // Skip if already identified
    if (config.identified) {
        return config;
    }
    
    const parsed = parseFilename(filename);

// If we detected an artist, search with both artist and track
// This prevents "Machine Head" (title) from returning "Machine Head" (band)
let searchResults = parsed.artist && parsed.title 
    ? await searchLastFM(parsed.query, 5, parsed.artist, parsed.title)
    : await searchLastFM(parsed.query, 5);

if (searchResults.length === 0) {
    config.identified = false;
    return config;
}

// CRITICAL FIX: Re-sort results by listener count (descending)
// Last.fm returns by "relevance" which prioritizes shorter artist names
// We want the most popular version first for better auto-identification
searchResults.sort((a, b) => {
    const listenersA = parseInt(a.listeners) || 0;
    const listenersB = parseInt(b.listeners) || 0;
    
    // Determine if each result is an exact match
    const comparisonStringA = parsed.artist && parsed.title ? `${a.artist} ${a.name}` : a.name;
    const comparisonStringB = parsed.artist && parsed.title ? `${b.artist} ${b.name}` : b.name;
    
    const isExactA = parsed.query.toLowerCase() === comparisonStringA.toLowerCase();
    const isExactB = parsed.query.toLowerCase() === comparisonStringB.toLowerCase();
    
    // Exact matches come first
    if (isExactA && !isExactB) return -1;
    if (!isExactA && isExactB) return 1;
    
    // Both exact or both non-exact: sort by listener count
    return listenersB - listenersA;
});

// Check if tags are locked
const hasLockedTags = config.locked && config.locked.length > 0;

// Detect if this is a title-only search (no artist in filename)
const isTitleOnly = !parsed.artist;

// For title-only searches, check artist diversity to detect ambiguous titles
if (isTitleOnly) {
    const uniqueArtists = new Set(searchResults.map(r => r.artist.toLowerCase()));
    const artistDiversity = uniqueArtists.size;
    
    // If 6+ different artists have songs with this title, it's too ambiguous
    if (artistDiversity >= 6) {
        config.identified = false;
        console.log(`âŠ˜ Title too ambiguous (${artistDiversity} different artists in top 10): ${filename}`);
        return config;
    }
    
    // Log the diversity for debugging
    if (artistDiversity >= 4) {
        console.log(`âš  Moderate ambiguity (${artistDiversity} different artists): ${filename}`);
    }
}
    
// Calculate similarities for all results
    const matches = [];
    for (let i = 0; i < searchResults.length; i++) {
        const result = searchResults[i];
        
        // KEY FIX: For title-only searches, compare against JUST the track name
        // For searches with artist, compare against "artist + track"
        const comparisonString = isTitleOnly 
            ? result.name 
            : `${result.artist} ${result.name}`;
        
        const similarity = stringSimilarity(parsed.query, comparisonString);
        
        // Get file duration if available
        const fileDuration = songDurations[filename] || null;
        
        // Fetch track info to get Last.fm duration
        let lastfmDuration = null;
        if (fileDuration) {
            const trackInfo = await getTrackInfo(result.artist, result.name);
            lastfmDuration = trackInfo.duration;
        }
        
        // Calculate duration similarity
        const durSimilarity = durationSimilarity(fileDuration, lastfmDuration);
        
        // Adjust overall similarity based on duration match
        let adjustedSimilarity = similarity;
        if (durSimilarity !== null) {
            if (durSimilarity >= 0.8) {
                // Good duration match - boost confidence by up to 5%
                adjustedSimilarity = Math.min(1.0, similarity + 0.05);
            } else if (durSimilarity < 0.3) {
                // Poor duration match - reduce confidence by up to 10%
                adjustedSimilarity = Math.max(0, similarity - 0.10);
            }
        }
        
        matches.push({
            artist: result.artist,
            track: result.name,
            similarity: adjustedSimilarity,
            originalSimilarity: similarity,
            durationMatch: durSimilarity,
            listeners: parseInt(result.listeners) || 0,
            isTopResult: i === 0
        });
    }
    
    // Sort by similarity (descending)
    matches.sort((a, b) => b.similarity - a.similarity);
    
    let selectedMatch = null;
    
    // STRATEGY 1: High confidence match (85%+ similarity) - always accept
    const highConfidenceMatch = matches.find(m => m.similarity >= 0.90);
    if (highConfidenceMatch) {
        selectedMatch = highConfidenceMatch;
        console.log(`âœ“ High confidence match (${(highConfidenceMatch.similarity * 100).toFixed(1)}%): ${filename}`);
    }
    
    // STRATEGY 2: Popularity-based acceptance for medium confidence matches
    if (!selectedMatch) {
        // Get top result from original search order
        const topResult = matches.find(m => m.isTopResult);
        
        // Check if top result has medium confidence (60-84% similarity)
        if (topResult && topResult.similarity >= 0.60 && topResult.similarity < 0.85) {
            
            // Get second most popular result for comparison
            const secondResult = searchResults.length > 1 ? matches.find(m => !m.isTopResult) : null;
            
            if (secondResult && secondResult.listeners > 0) {
                // Calculate popularity ratio
                const popularityRatio = topResult.listeners / secondResult.listeners;
                
                // If top result is 5x more popular, accept it
                if (popularityRatio >= 10) {
                    selectedMatch = topResult;
                    console.log(`âœ“ Popularity-based match (${(topResult.similarity * 100).toFixed(1)}%, ${popularityRatio.toFixed(1)}x more popular): ${filename}`);
                }
            } else if (topResult.listeners >= 500000) {
                // If top result is popular (50k+ listeners) and no comparison available, accept it
                selectedMatch = topResult;
                console.log(`âœ“ High popularity match (${(topResult.similarity * 100).toFixed(1)}%, ${topResult.listeners.toLocaleString()} listeners): ${filename}`);
            }
        }
        
        // STRATEGY 3: Relaxed threshold for title-only searches with top result
        if (!selectedMatch && isTitleOnly && topResult) {
            // For title-only, accept if similarity is 70%+ and it's the top result
            if (topResult.similarity >= 0.70) {
                selectedMatch = topResult;
                console.log(`âœ“ Title-only match (${(topResult.similarity * 100).toFixed(1)}%): ${filename}`);
            }
        }
    }
    
    // If we found a match, fetch tags and save
    if (selectedMatch) {
        // Save identification info (artist and title)
        config.artist = selectedMatch.artist;
        config.title = selectedMatch.track;
        config.identified = true;
        
        // Only add tags if tags are NOT locked
        if (!hasLockedTags) {
            // Get tags for this match
            const trackTags = await getTrackTags(selectedMatch.artist, selectedMatch.track);
            const artistTags = await getArtistTags(selectedMatch.artist);
            const allTags = [...new Set([...trackTags, ...artistTags])]; // Remove duplicates
            
            // Add tags that have at least some content
            if (allTags.length > 0) {
                // Filter out overly long tags (likely nonsense)
                const validTags = allTags.filter(tag => tag.length <= 25);
                
                // Conform tags to existing tags
                const conformedTags = validTags.map(tag => conformTagToExisting(tag)).filter(t => t);
                
                // Merge with existing tags
                config.tags = [...new Set([...(config.tags || []), ...conformedTags])];
                
                // Invalidate cached tag colors since tags changed
                invalidateTagColorCache(filename);
            }
        } else {
            console.log(`  â†’ Tags locked, skipping tag updates for: ${filename}`);
        }
        
        return config;
    }
    
    // No match found
    config.identified = false;
    console.log(`âœ— No confident match found for: ${filename}`);
    return config;
}
function showReviewStep(artist, title, tags = [], album = null, year = null) {
    const resultsContainer = document.getElementById('lastfmResultsContainer');
    
    // Get current song's metadata if editing
    const config = songBeingIdentified ? getSongConfig(songBeingIdentified) : {};
    
    resultsContainer.innerHTML = `
        <div style="padding: 20px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
                <button onclick="showSearchResults()" 
                        style="padding: 8px 15px; background: #2a2a2a; color: var(--accent-color-bright); border: 1px solid var(--accent-color-bright); border-radius: 5px; cursor: pointer;">
                    â† Back
                </button>
                <h3 style="color: var(--accent-color-bright); margin: 0;">Review Song Information</h3>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-weight: 600;">Artist:</label>
                <input type="text" id="reviewArtist" value="${artist}" 
                       style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-weight: 600;">Title:</label>
                <input type="text" id="reviewTitle" value="${title}" 
                       style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-weight: 600;">Album:</label>
                <input type="text" id="reviewAlbum" value="${album || config.album || ''}" 
                    style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
            </div>

            <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                <div style="flex: 1;">
                    <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-weight: 600;">Track #:</label>
                    <input type="text" id="reviewTrack" value="${config.track || ''}" 
                        style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
                </div>
                <div style="flex: 1;">
                    <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-weight: 600;">Year:</label>
                    <input type="text" id="reviewYear" value="${year || config.year || ''}" 
                        style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid var(--accent-color-bright); border-radius: 5px; color: #e0e0e0; font-size: 14px;">
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 10px; color: #e0e0e0; font-weight: 600;">Tags (click to toggle):</label>
                <div id="reviewTagsContainer" style="display: flex; flex-wrap: wrap; gap: 8px;">
                    ${(() => {
                        // Get existing tags from the song
                        const existingTags = config.tags || [];
                        
                        // Normalize existing tags for comparison
                        const existingNormalized = new Set(
                            existingTags.map(t => t.toLowerCase().replace(/\s+/g, ''))
                        );
                        
                        // Filter new tags to only show ones that don't already exist
                        const newTagsFiltered = tags.filter(tag => {
                            const normalized = tag.toLowerCase().replace(/\s+/g, '');
                            return !existingNormalized.has(normalized);
                        });
                        
                        // Combine filtered new tags with existing tags
                        const allTags = [...newTagsFiltered, ...existingTags];
                        
                        return allTags.map(tag => {
                            const isNewFromLastFM = newTagsFiltered.includes(tag);
                            const isSelected = true; // All tags are selected by default
                            return `
                                <span class="lastfm-tag-chip ${isSelected ? 'selected' : 'deselected'}" 
                                      data-tag="${tag}" 
                                      onclick="toggleReviewTag(this)"
                                      style="${isNewFromLastFM ? '' : 'opacity: 0.6; font-style: italic;'}">
                                    ${tag}
                                </span>
                            `;
                        }).join('');
                    })()}
                </div>
            </div>
        </div>
    `;
    
    document.getElementById('confirmLastFMBtn').disabled = false;
}

// Toggle tag selection in review step
function toggleReviewTag(element) {
    element.classList.toggle('selected');
    element.classList.toggle('deselected');
}

// Show search results (back button)
function showSearchResults() {
    const resultsContainer = document.getElementById('lastfmResultsContainer');
    resultsContainer.innerHTML = '';
    
    if (!window.lastFMSearchResults || window.lastFMSearchResults.length === 0) {
        resultsContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">No results available</div>';
        return;
    }
    
    window.lastFMSearchResults.forEach(result => {
        const resultDiv = document.createElement('div');
        resultDiv.className = 'lastfm-result-item';
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'lastfm-result-header';
        headerDiv.textContent = `${result.artist} - ${result.track}`;
        resultDiv.appendChild(headerDiv);
        
        if (result.tags.length > 0) {
            const tagsDiv = document.createElement('div');
            tagsDiv.className = 'lastfm-result-tags';
            tagsDiv.style.pointerEvents = 'none';
            
            result.tags.forEach(tag => {
                const tagChip = document.createElement('span');
                tagChip.className = 'lastfm-tag-chip';
                tagChip.textContent = tag;
                tagsDiv.appendChild(tagChip);
            });
            
            resultDiv.appendChild(tagsDiv);
        }
        
        // Add listeners count display if available
        if (result.listeners > 0) {
            const listenersDiv = document.createElement('div');
            listenersDiv.style.cssText = 'color: #888; font-size: 11px; margin-top: 5px; padding: 0 10px;';
            listenersDiv.textContent = `ðŸ‘¥ ${result.listeners.toLocaleString()} listeners`;
            resultDiv.appendChild(listenersDiv);
        }
        
        resultDiv.addEventListener('click', () => {
            showReviewStep(result.artist, result.track, result.tags, result.album, result.year);
        });
        
        resultsContainer.appendChild(resultDiv);
    });
    
    document.getElementById('confirmLastFMBtn').disabled = true;
}

function conformTagToExisting(newTag) {
    // First check if this tag has an alias
    const aliasedTag = applyTagAlias(newTag);
    if (aliasedTag !== newTag) {
        return aliasedTag; // Return the aliased tag
    }
    
    const normalized = newTag.toLowerCase().replace(/\s+/g, '');
    
    // Check against all existing tags
    for (const existingTag of Object.keys(masterTags)) {
        const existingNormalized = existingTag.toLowerCase().replace(/\s+/g, '');
        if (normalized === existingNormalized) {
            return existingTag; // Return the existing tag format
        }
    }
    
    // Check aliases (case-insensitive)
    for (const [oldTag, newTagAlias] of Object.entries(tagAliases)) {
        if (oldTag.toLowerCase() === normalized) {
            return newTagAlias; // Return the target of the alias
        }
    }
    
    // No match found, return capitalized version
    return capitalizeTag(newTag);
}

// Open Last.fm identification modal for a specific song
async function openLastFMIdentifyModalForSong(filename) {
    // Store which song we're identifying
    songBeingIdentified = filename;
    isEditingExistingSong = false; // This is initial identification, not editing
    
    document.getElementById('lastfmIdentifyOverlay').style.display = 'flex';
    document.getElementById('confirmLastFMBtn').disabled = true; // Start disabled
    
    // Set search input to filename
    const parsed = parseFilename(filename);
    document.getElementById('lastfmSearchInput').value = parsed.query;
    
    // Perform initial search with smart search enabled (uses artist+track if available)
    await performLastFMSearch(true);
}
// Close Last.fm identification modal
function closeLastFMIdentifyModal() {
    document.getElementById('lastfmIdentifyOverlay').style.display = 'none';
    selectedLastFMResult = null;
    songBeingIdentified = null;
}

// Open master tags modal
function openMasterTagsModal() {
    // Close any other open modals first
    document.getElementById('lastfmIdentifyOverlay').style.display = 'none';
    
    document.getElementById('masterTagsOverlay').style.display = 'flex';
    
    // Populate category filter
    const categoryFilter = document.getElementById('masterTagCategoryFilter');
    const categories = new Set();
    Object.values(masterTags).forEach(tag => {
        if (tag.category) categories.add(tag.category);
    });
    
    categoryFilter.innerHTML = '<option value="all">All Categories</option>';
    Array.from(categories).sort().forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat;
        categoryFilter.appendChild(option);
    });
    
    // Clear any selections
    selectedMasterTags.clear();
    
    renderMasterTagsList();
}

// Close master tags modal
function closeMasterTagsModal() {
    document.getElementById('masterTagsOverlay').style.display = 'none';
}

// Update bulk action button states
function updateBulkActionButtons() {
    const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
    const bulkCategoryBtn = document.getElementById('bulkCategoryBtn');
    const hasSelection = selectedMasterTags.size > 0;
    
    if (bulkDeleteBtn) {
        bulkDeleteBtn.disabled = !hasSelection;
        bulkDeleteBtn.style.opacity = hasSelection ? '1' : '0.5';
        bulkDeleteBtn.style.cursor = hasSelection ? 'pointer' : 'not-allowed';
    }
    
    if (bulkCategoryBtn) {
        bulkCategoryBtn.disabled = !hasSelection;
        bulkCategoryBtn.style.opacity = hasSelection ? '1' : '0.5';
        bulkCategoryBtn.style.cursor = hasSelection ? 'pointer' : 'not-allowed';
    }
}

// Bulk delete tags
async function bulkDeleteTags() {
    if (selectedMasterTags.size === 0) return;
    
    const tagList = Array.from(selectedMasterTags).join(', ');
    const totalSongs = Array.from(selectedMasterTags).reduce((sum, tag) => {
        return sum + (masterTags[tag]?.songCount || 0);
    }, 0);
    
    if (!confirm(`Delete ${selectedMasterTags.size} tag(s)?\n\nTags: ${tagList}\n\nThis will remove them from ${totalSongs} song(s).`)) {
        return;
    }
    
selectedMasterTags.forEach(tagName => {
        Object.keys(songConfig).forEach(filename => {
            const config = songConfig[filename];
            if (config.tags && config.tags.includes(tagName)) {
                config.tags = config.tags.filter(t => t !== tagName);
                
                // Invalidate cached tag colors since tags changed
                invalidateTagColorCache(filename);
            }
            if (config.locked && config.locked.includes(tagName)) {
                config.locked = config.locked.filter(t => t !== tagName);
            }
        });
        
        // Remove from master tags
        delete masterTags[tagName];
    });
    
    await saveConfig();
    
    // Clear selection and refresh
    selectedMasterTags.clear();
    renderMasterTagsList();
    renderFilterTags();
    updateAudioFilesList();
    
    console.log(`Deleted ${selectedMasterTags.size} tags`);
}

// Show bulk category change modal
function showBulkCategoryModal() {
    if (selectedMasterTags.size === 0) return;
    
    // Get all unique categories
    const allCategories = new Set();
    Object.values(masterTags).forEach(tag => {
        if (tag.category) allCategories.add(tag.category);
    });
    
    const categoryList = Array.from(allCategories).sort();
    const options = categoryList.map(cat => `<option value="${cat}">${cat}</option>`).join('');
    
    const newCategory = prompt(`Change category for ${selectedMasterTags.size} tag(s)?\n\nAvailable categories:\n${categoryList.join(', ')}\n\nEnter category name:`);
    
    if (!newCategory || !newCategory.trim()) return;
    
    // Apply category change
    selectedMasterTags.forEach(tagName => {
        if (masterTags[tagName]) {
            masterTags[tagName].category = newCategory.trim();
        }
    });
    
    saveConfig();
    
    // Clear selection and refresh
    selectedMasterTags.clear();
    renderMasterTagsList();
    
    console.log(`Changed category for ${selectedMasterTags.size} tags to "${newCategory}"`);
}
// Render master tags list
function renderMasterTagsList() {
    const container = document.getElementById('masterTagsList');
    const searchQuery = document.getElementById('masterTagSearch').value.toLowerCase();
    const categoryFilter = document.getElementById('masterTagCategoryFilter').value;
    const sortOrder = document.getElementById('masterTagSortOrder').value;
    
    // Filter tags
    let tags = Object.entries(masterTags).filter(([tagName, tagData]) => {
        // Search filter
        if (searchQuery && !tagName.toLowerCase().includes(searchQuery)) {
            return false;
        }
        
        // Category filter
        if (categoryFilter !== 'all' && tagData.category !== categoryFilter) {
            return false;
        }
        
        return true;
    });
    
    // Sort tags
    if (sortOrder === 'alpha') {
        tags.sort((a, b) => a[0].localeCompare(b[0]));
    } else {
        tags.sort((a, b) => (b[1].songCount || 0) - (a[1].songCount || 0));
    }
    
    container.innerHTML = '';
    
    if (tags.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No tags found</div>';
        return;
    }
    
    // Get unique categories for dropdown
    const allCategories = new Set();
    Object.values(masterTags).forEach(tag => {
        if (tag.category) allCategories.add(tag.category);
    });
    const categoryOptions = Array.from(allCategories).sort();
    
tags.forEach(([tagName, tagData], index) => {
    const item = document.createElement('div');
    item.className = 'master-tag-item';
    
    // Checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = selectedMasterTags.has(tagName);
    checkbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent-color-bright);';
    checkbox.addEventListener('change', (e) => {
        // Handle shift-click for range selection
        if (e.shiftKey && lastSelectedMasterTagIndex !== -1 && lastSelectedMasterTagIndex !== index) {
            // Determine the range
            const start = Math.min(lastSelectedMasterTagIndex, index);
            const end = Math.max(lastSelectedMasterTagIndex, index);
            
            // Determine whether to select or deselect based on the current checkbox's state
            const shouldSelect = e.target.checked;
            
            // Apply the selection state to all tags in the range
            for (let i = start; i <= end; i++) {
                const [rangeTagName] = tags[i];
                if (shouldSelect) {
                    selectedMasterTags.add(rangeTagName);
                } else {
                    selectedMasterTags.delete(rangeTagName);
                }
            }
            
            // Update all checkboxes in the range
            const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
            for (let i = start; i <= end; i++) {
                if (allCheckboxes[i]) {
                    allCheckboxes[i].checked = shouldSelect;
                }
            }
        } else {
            // Normal single selection toggle
            if (e.target.checked) {
                selectedMasterTags.add(tagName);
            } else {
                selectedMasterTags.delete(tagName);
            }
        }
        
        // Update last selected index
        lastSelectedMasterTagIndex = index;
        
        updateBulkActionButtons();
    });
    
    const info = document.createElement('div');
    info.className = 'master-tag-info';
    
    const name = document.createElement('div');
    name.className = 'master-tag-name';
    name.textContent = tagName;
    
    const details = document.createElement('div');
    details.className = 'master-tag-details';
    details.textContent = `${tagData.songCount || 0} song${tagData.songCount !== 1 ? 's' : ''} â€¢ Category: ${tagData.category || 'None'}`;
    
    info.appendChild(name);
    info.appendChild(details);
    
    // Category selector
    const categorySelect = document.createElement('select');
    categorySelect.className = 'master-tag-category-select';
    categorySelect.innerHTML = categoryOptions.map(cat => 
        `<option value="${cat}" ${cat === tagData.category ? 'selected' : ''}>${cat}</option>`
    ).join('');
    
    categorySelect.addEventListener('change', async (e) => {
        await changeMasterTagCategory(tagName, e.target.value);
    });
    
// Merge button
    const mergeBtn = document.createElement('button');
    mergeBtn.className = 'master-tag-merge-btn';
    mergeBtn.textContent = 'Merge';
    mergeBtn.style.cssText = 'padding: 6px 12px; background: #2a2a2a; color: var(--accent-color-bright); border: 1px solid var(--accent-color-bright); border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 12px; margin-right: 8px;';
    mergeBtn.onclick = () => openTagMergeModal(tagName);
    
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'master-tag-delete-btn';
    deleteBtn.textContent = 'Delete';
    deleteBtn.onclick = () => deleteMasterTag(tagName);
    
    item.appendChild(checkbox);
    item.appendChild(info);
    item.appendChild(categorySelect);
    item.appendChild(mergeBtn);
    item.appendChild(deleteBtn);
    
    container.appendChild(item);
});
}

// Change master tag category
async function changeMasterTagCategory(tagName, newCategory) {
    if (!masterTags[tagName]) return;
    
    masterTags[tagName].category = newCategory;
    await saveConfig();
    
    console.log(`Changed category for "${tagName}" to "${newCategory}"`);
}

// Delete master tag
async function deleteMasterTag(tagName) {
    const tagData = masterTags[tagName];
    const songCount = tagData?.songCount || 0;
    
    if (!confirm(`Delete tag "${tagName}"?\n\nThis will remove it from ${songCount} song${songCount !== 1 ? 's' : ''}.`)) {
        return;
    }
    
    // Add to blacklist if checkbox is checked
    const blacklistCheckbox = document.getElementById('blacklistDeletedTagsCheckbox');
    if (blacklistCheckbox && blacklistCheckbox.checked) {
        blacklistedTags.add(tagName);
        console.log(`Added "${tagName}" to blacklist`);
    }
    
    // Remove from all songs
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        if (config.tags && config.tags.includes(tagName)) {
            config.tags = config.tags.filter(t => t !== tagName);
        }
        if (config.locked && config.locked.includes(tagName)) {
            config.locked = config.locked.filter(t => t !== tagName);
        }
    });
    
    // Remove from master tags
    delete masterTags[tagName];
    
    await saveConfig();
    
    // Refresh displays
    renderMasterTagsList();
    renderFilterTags();
    updateAudioFilesList();
    
    console.log(`Deleted tag "${tagName}" from all songs`);
}

// Toggle blacklist deleted tags setting
function toggleBlacklistDeletedTags() {
    const checkbox = document.getElementById('blacklistDeletedTagsCheckbox');
    console.log('Blacklist deleted tags:', checkbox.checked);
}

// Calculate string similarity (Levenshtein distance-based)
function stringSimilarity(str1, str2) {
    str1 = str1.toLowerCase();
    str2 = str2.toLowerCase();
    
    const len1 = str1.length;
    const len2 = str2.length;
    const matrix = [];
    
    for (let i = 0; i <= len1; i++) {
        matrix[i] = [i];
    }
    for (let j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
                matrix[i - 1][j] + 1,
                matrix[i][j - 1] + 1,
                matrix[i - 1][j - 1] + cost
            );
        }
    }
    
    const maxLen = Math.max(len1, len2);
    return maxLen === 0 ? 1 : 1 - matrix[len1][len2] / maxLen;
}

// Open tag merge modal
function openTagMergeModal(tagName) {
    const modal = document.getElementById('tagMergeOverlay');
    document.getElementById('mergeTagName').textContent = tagName;
    
    // Find similar tags
    const allTags = Object.keys(masterTags).filter(t => t !== tagName);
    const similarities = allTags.map(tag => ({
        tag: tag,
        similarity: stringSimilarity(tagName, tag),
        songCount: masterTags[tag].songCount || 0
    }));
    
    // Sort by similarity, then by song count
    similarities.sort((a, b) => {
        if (Math.abs(a.similarity - b.similarity) > 0.1) {
            return b.similarity - a.similarity;
        }
        return b.songCount - a.songCount;
    });
    
    // Get top 5
    const topSuggestions = similarities.slice(0, 5);
    
    // Render suggestions
    const container = document.getElementById('suggestedMergeTags');
    container.innerHTML = '';
    
    if (topSuggestions.length === 0) {
        container.innerHTML = '<p style="color: #888; font-style: italic;">No similar tags found</p>';
    } else {
        topSuggestions.forEach(({ tag, songCount }) => {
            const btn = document.createElement('button');
            btn.style.cssText = `
                display: block;
                width: 100%;
                padding: 12px;
                margin-bottom: 10px;
                background: #2a2a2a;
                border: 1px solid var(--accent-color-bright);
                border-radius: 5px;
                color: #e0e0e0;
                text-align: left;
                cursor: pointer;
                font-size: 14px;
            `;
            btn.innerHTML = `<strong>${tag}</strong> <span style="color: #888;">(${songCount} song${songCount !== 1 ? 's' : ''})</span>`;
            btn.onclick = () => confirmTagMerge(tagName, tag);
            container.appendChild(btn);
        });
    }
    
    // Clear manual input
    document.getElementById('manualMergeTagInput').value = '';
    
    // Setup autocomplete for manual input
    setupMergeTagAutocomplete(tagName);
    
    modal.style.display = 'flex';
}

// Close tag merge modal
function closeTagMergeModal() {
    document.getElementById('tagMergeOverlay').style.display = 'none';
}

// Setup autocomplete for merge tag input
function setupMergeTagAutocomplete(sourceTag) {
    const input = document.getElementById('manualMergeTagInput');
    const suggestionsDiv = document.getElementById('mergeTagSuggestions');
    
    input.addEventListener('input', () => {
        const query = input.value.toLowerCase().trim();
        
        if (!query) {
            suggestionsDiv.style.display = 'none';
            return;
        }
        
        const allTags = Object.keys(masterTags).filter(t => t !== sourceTag && t.toLowerCase().includes(query));
        
        if (allTags.length === 0) {
            suggestionsDiv.style.display = 'none';
            return;
        }
        
        suggestionsDiv.innerHTML = '';
        allTags.slice(0, 10).forEach(tag => {
            const item = document.createElement('div');
            item.style.cssText = 'padding: 10px; cursor: pointer; color: #e0e0e0; border-bottom: 1px solid #2a2a2a;';
            item.textContent = tag;
            item.onmouseenter = () => item.style.background = '#2a2a2a';
            item.onmouseleave = () => item.style.background = '';
            item.onclick = () => {
                input.value = tag;
                suggestionsDiv.style.display = 'none';
                confirmTagMerge(sourceTag, tag);
            };
            suggestionsDiv.appendChild(item);
        });
        
        suggestionsDiv.style.display = 'block';
    });
    
    // Handle Enter key
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            const targetTag = input.value.trim();
            if (targetTag) {
                confirmTagMerge(sourceTag, targetTag);
            }
        }
    });
}

// Confirm and execute tag merge
async function confirmTagMerge(sourceTag, targetTag) {
    if (!sourceTag || !targetTag) {
        alert('Please select a valid tag to merge into');
        return;
    }
    
    if (sourceTag === targetTag) {
        alert('Cannot merge a tag into itself');
        return;
    }
    
    const sourceData = masterTags[sourceTag];
    const songCount = sourceData?.songCount || 0;
    
    if (!confirm(`Merge "${sourceTag}" into "${targetTag}"?\n\nThis will:\nâ€¢ Move ${songCount} song${songCount !== 1 ? 's' : ''} to use "${targetTag}"\nâ€¢ Create an alias so future "${sourceTag}" tags become "${targetTag}"\nâ€¢ Delete the "${sourceTag}" tag`)) {
        return;
    }
    
    // Create alias
    tagAliases[sourceTag] = targetTag;
    
    // Ensure target tag exists in masterTags
    if (!masterTags[targetTag]) {
        masterTags[targetTag] = {
            category: sourceData.category || 'LastFM Tags',
            songCount: 0,
            color: sourceData.color || '#ff6b35',
            weight: sourceData.weight || 5
        };
    }
    
    // Move all songs from source to target tag
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        if (config.tags && config.tags.includes(sourceTag)) {
            // Remove source tag
            config.tags = config.tags.filter(t => t !== sourceTag);
            // Add target tag if not already present
            if (!config.tags.includes(targetTag)) {
                config.tags.push(targetTag);
            }
        }
    });
    
    // Delete source tag from masterTags
    delete masterTags[sourceTag];
    
    // Save config
    await saveConfig();
    
    // Rebuild master tags to update counts
    buildMasterTagsFromConfig();
    
    // Refresh displays
    renderMasterTagsList();
    renderFilterTags();
    renderSongTags();
    updateAudioFilesList();
    
    closeTagMergeModal();
    
    console.log(`Merged "${sourceTag}" into "${targetTag}" and created alias`);
}

// Apply tag alias when adding tags (call this in conformTagToExisting)
function applyTagAlias(tag) {
    // Check if this tag has an alias
    if (tagAliases[tag]) {
        return tagAliases[tag];
    }
    return tag;
}

// Add event listeners for master tags modal filters
document.getElementById('masterTagSearch')?.addEventListener('input', renderMasterTagsList);
document.getElementById('masterTagCategoryFilter')?.addEventListener('change', renderMasterTagsList);
document.getElementById('masterTagSortOrder')?.addEventListener('change', renderMasterTagsList);


// Store selected result
let selectedLastFMResult = null;

async function performLastFMSearch(useSmartSearch = false) {
    const query = document.getElementById('lastfmSearchInput').value.trim();
    if (!query) return;
    
    // Increment search ID to invalidate previous searches
    currentSearchId++;
    const thisSearchId = currentSearchId;
    
    const resultsContainer = document.getElementById('lastfmResultsContainer');
    resultsContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Searching...</div>';
    
    let results;
    
    // Check if query contains " - " (hyphen surrounded by spaces) for manual artist-track search
    const hasHyphenWithSpaces = / - /.test(query);
    
    // Use smart search (artist+track) if requested and no hyphen/by detected
    if (useSmartSearch) {
        const parsed = parseFilename(query);
        if (parsed.artist && parsed.title) {
            // We have both artist and title, use smart search
            results = await searchLastFM(query, 10, parsed.artist, parsed.title);
        } else {
            // Title only, use regular search
            results = await searchLastFM(query, 10);
        }
    } else if (hasHyphenWithSpaces) {
        // User typed manually with " - " format, parse as artist - track
        const parts = query.split(' - ');
        const artist = parts[0].trim();
        const track = parts.slice(1).join(' - ').trim(); // Handle multiple " - " in track name
        
        if (artist && track) {
            results = await searchLastFM(query, 10, artist, track);
        } else {
            // Fallback to regular search if parsing fails
            results = await searchLastFM(query, 10);
        }
    } else {
        // User typed manually without " - ", use regular search (track name only)
        results = await searchLastFM(query, 10);
    }
    
    // Check if this search has been cancelled
    if (thisSearchId !== currentSearchId) {
        console.log('Search cancelled - newer search started');
        return;
    }
    
    if (results.length === 0) {
        resultsContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">No results found</div>';
        return;
    }

    // CRITICAL FIX: Re-sort results by listener count (descending)
    // Last.fm returns by "relevance" - we want most popular first
    results.sort((a, b) => {
        const listenersA = parseInt(a.listeners) || 0;
        const listenersB = parseInt(b.listeners) || 0;
        
        // Determine if each result is an exact match
        const isExactA = query.toLowerCase() === `${a.artist} ${a.name}`.toLowerCase() || 
                         query.toLowerCase() === a.name.toLowerCase();
        const isExactB = query.toLowerCase() === `${b.artist} ${b.name}`.toLowerCase() || 
                         query.toLowerCase() === b.name.toLowerCase();
        
        // Exact matches come first
        if (isExactA && !isExactB) return -1;
        if (!isExactA && isExactB) return 1;
        
        // Both exact or both non-exact: sort by listener count
        return listenersB - listenersA;
    });

    resultsContainer.innerHTML = '';

    // Store results for later (for back button)
    window.lastFMSearchResults = [];
    
    // Fetch tags for each result
    for (const result of results) {
        // Check if search was cancelled before each item
        if (thisSearchId !== currentSearchId) {
            console.log('Search cancelled during results processing');
            return;
        }
        
        const trackTags = await getTrackTags(result.artist, result.name);
        
        // Check again after async operation
        if (thisSearchId !== currentSearchId) return;
        
        const artistTags = await getArtistTags(result.artist);
        
        // Check again after async operation
        if (thisSearchId !== currentSearchId) return;
        
        const allTags = [...new Set([...trackTags, ...artistTags])];
        
// Fetch detailed track info to get album, year, and duration
        const trackInfo = await getTrackInfo(result.artist, result.name);
        
        // Final check after all async operations
        if (thisSearchId !== currentSearchId) return;
        
        // Store listeners along with other data
        const listeners = parseInt(result.listeners) || 0;
        
        window.lastFMSearchResults.push({
            artist: result.artist,
            track: result.name,
            tags: allTags,
            listeners: listeners,
            album: trackInfo.album || null,
            year: trackInfo.year || null,
            duration: trackInfo.duration || null
        });
        
        const resultDiv = document.createElement('div');
        resultDiv.className = 'lastfm-result-item';
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'lastfm-result-header';
        headerDiv.textContent = `${result.artist} - ${result.name}`;
        resultDiv.appendChild(headerDiv);
        
        if (allTags.length > 0) {
            const tagsDiv = document.createElement('div');
            tagsDiv.className = 'lastfm-result-tags';
            tagsDiv.style.pointerEvents = 'none'; // Don't allow clicking tags yet
            
            allTags.forEach(tag => {
                const tagChip = document.createElement('span');
                tagChip.className = 'lastfm-tag-chip';
                tagChip.textContent = tag;
                tagsDiv.appendChild(tagChip);
            });
            
            resultDiv.appendChild(tagsDiv);
        }
        
// Add listeners count and duration display
        const metaInfo = [];
        if (listeners > 0) {
            metaInfo.push(`ðŸ‘¥ ${listeners.toLocaleString()} listeners`);
        }
        
        // Show Last.fm duration and file duration for comparison
        if (trackInfo.duration || (songBeingIdentified && songDurations[songBeingIdentified])) {
            let durationText = 'â± ';
            
            // Last.fm duration
            if (trackInfo.duration) {
                const minutes = Math.floor(trackInfo.duration / 60);
                const seconds = Math.floor(trackInfo.duration % 60);
                durationText += `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                durationText += '?:??';
            }
            
            // File duration (if we're identifying a song)
            if (songBeingIdentified && songDurations[songBeingIdentified]) {
                const fileDuration = songDurations[songBeingIdentified];
                const fileMinutes = Math.floor(fileDuration / 60);
                const fileSeconds = Math.floor(fileDuration % 60);
                durationText += ` (file: ${fileMinutes}:${fileSeconds.toString().padStart(2, '0')})`;
            }
            
            metaInfo.push(durationText);
        }
        
        if (metaInfo.length > 0) {
            const metaDiv = document.createElement('div');
            metaDiv.style.cssText = 'color: #888; font-size: 11px; margin-top: 5px; padding: 0 10px;';
            metaDiv.textContent = metaInfo.join(' â€¢ ');
            resultDiv.appendChild(metaDiv);
        }
        
        resultDiv.addEventListener('click', () => {
            // Get the stored result with album/year info
            const storedResult = window.lastFMSearchResults[window.lastFMSearchResults.length - 1];
            showReviewStep(result.artist, result.name, allTags, storedResult.album, storedResult.year);
        });
        
        resultsContainer.appendChild(resultDiv);
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 250));
    }
}

async function confirmLastFMIdentification() {
    if (!songBeingIdentified) return;
    
    const artist = document.getElementById('reviewArtist')?.value.trim();
    const title = document.getElementById('reviewTitle')?.value.trim();
    const album = document.getElementById('reviewAlbum')?.value.trim();
    const track = document.getElementById('reviewTrack')?.value.trim();
    const year = document.getElementById('reviewYear')?.value.trim();
    
    if (!artist || !title) {
        alert('Please enter both artist and title');
        return;
    }
    
    const config = getSongConfig(songBeingIdentified);
    
// Get selected tags from the modal
    const selectedTags = Array.from(document.querySelectorAll('#reviewTagsContainer .lastfm-tag-chip.selected'))
        .map(chip => chip.dataset.tag);
    
    // Get ALL tags that were shown in the modal (selected and deselected)
    const allShownTags = Array.from(document.querySelectorAll('#reviewTagsContainer .lastfm-tag-chip'))
        .map(chip => chip.dataset.tag);
    
    // Conform selected tags and filter out blacklisted tags
    const conformedTags = selectedTags
        .map(tag => conformTagToExisting(tag))
        .filter(t => t && !blacklistedTags.has(t));
    
    // Add any new tags to master tags with default category
    conformedTags.forEach(tag => {
        if (!masterTags[tag]) {
            masterTags[tag] = {
                category: 'LastFM Tags',
                songCount: 0,
                color: '#ff6b35',
                weight: 5
            };
        }
    });
    
    // Keep only tags that were NOT shown in the modal, then add the selected tags
    const existingTags = config.tags || [];
    const keptTags = existingTags.filter(tag => !allShownTags.includes(tag));
    const finalTags = [...new Set([...keptTags, ...conformedTags])];
    config.tags = finalTags;
    
    config.artist = artist;
    config.title = title;
    config.album = album || null;
    config.track = track || null;
    config.year = year || null;
    config.identified = true;
    
    // Sync artist/album properties to tags (only if they already exist as tags)
    if (artist && masterTags[artist]) {
        if (!config.tags) config.tags = [];
        if (!config.tags.includes(artist)) {
            config.tags.push(artist);
        }
    }
    
    if (album && masterTags[album]) {
        if (!config.tags) config.tags = [];
        if (!config.tags.includes(album)) {
            config.tags.push(album);
        }
    }
    
    songConfig[songBeingIdentified] = config;
    
    invalidateTagColorCache(songBeingIdentified);

    await saveConfig();
    
    // Update display
    updateAudioFilesList();
    
    // Refresh tag display if this is the currently playing song
    if (currentlyPlayingFile && currentlyPlayingFile.name === songBeingIdentified) {
        // Reload the tags into selectedSongTags Set
        loadSongTags(songBeingIdentified);
        
        // Update the now playing display with new tag count
        updateNowPlayingDisplay();
        
        // Update compact player if collapsed
        if (collapsedSections.player) {
            updateCompactPlayer();
        }
    }
    
    closeLastFMIdentifyModal();
    
    const tagMessage = selectedTags.length > 0 ? `\n\n${selectedTags.length} tags added` : '';
    //alert(`Song identified as:\n${artist} - ${title}${tagMessage}`);
}

function capitalizeTag(tag) {
    return tag.split(' ').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(' ');
}
// Get filtered tags based on current category
function getFilteredTags() {
    const tags = Object.keys(masterTags);
    
    // Filter by category
    let filtered = tags;
    if (currentTagCategory !== 'All') {
        filtered = tags.filter(tag => masterTags[tag].category === currentTagCategory);
    }
    
    // Filter by search query
    if (tagSearchQuery) {
        filtered = filtered.filter(tag => 
            tag.toLowerCase().includes(tagSearchQuery)
        );
    }
    
    // Sort tags
    filtered.sort((a, b) => {
        let comparison = 0;
        
        if (tagSortBy === 'alphabetical') {
            comparison = a.localeCompare(b);
        } else if (tagSortBy === 'songCount') {
            comparison = masterTags[b].songCount - masterTags[a].songCount;
        }
        
        return tagSortAscending ? comparison : -comparison;
    });
    
    return filtered;
}

// Change tag category
function changeTagCategory(category) {
    currentTagCategory = category;
    
    // Clear search when changing category
    clearTagSearch();
    
    // Sync both dropdowns
    document.getElementById('filterCategorySelect').value = category;
    document.getElementById('songCategorySelect').value = category;
    
    // Re-render both tag sections
    renderFilterTags();
    renderSongTags();
}
// Change tag sort
function changeTagSort(sortBy) {
    tagSortBy = sortBy;
    
    // Clear search when changing sort
    clearTagSearch();
    
    // Sync both dropdowns
    document.getElementById('filterSortSelect').value = sortBy;
    document.getElementById('songSortSelect').value = sortBy;
    
    // Re-render both tag sections
    renderFilterTags();
    renderSongTags();
}

// Toggle tag sort order
function toggleTagSortOrder() {
    tagSortAscending = !tagSortAscending;
    
    // Clear search when toggling sort order
    clearTagSearch();
    
    const arrow = tagSortAscending ? 'â†“' : 'â†‘';
    document.getElementById('filterSortOrderBtn').textContent = arrow;
    document.getElementById('songSortOrderBtn').textContent = arrow;
    
    // Re-render both tag sections
    renderFilterTags();
    renderSongTags();
}

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Duration slider control
        durationSlider.addEventListener('input', (e) => {
            responseDuration = parseInt(e.target.value);
            durationValue.textContent = responseDuration;
        });
        durationSlider.addEventListener('change', () => saveConfig());

// Volume slider control (iOS compatible)
volumeSlider.addEventListener('input', (e) => {
    const volume = parseInt(e.target.value);
    volumeValue.textContent = volume;
    
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (isIOS) {
        // On iOS, we have to use the HTML5 audio element volume
        // (it only works for some audio sources, not all)
        audioPlayer.volume = volume / 100;
        originalVolume = volume / 100;
    } else if (gainNode && audioContext) {
        // Desktop: use Web Audio API
        const gainValue = volume / 100;
        gainNode.gain.setValueAtTime(gainValue, audioContext.currentTime);
        originalVolume = gainValue;
    } else {
        audioPlayer.volume = volume / 100;
        originalVolume = volume / 100;
    }
});

        // Save volume on change end
        volumeSlider.addEventListener('change', () => {
            saveConfig();
        });

        // Fade In slider control
const fadeInSlider = document.getElementById('fadeInSlider');
const fadeInValue = document.getElementById('fadeInValue');

fadeInSlider.addEventListener('input', (e) => {
    const fadeIn = parseInt(e.target.value);
    fadeInValue.textContent = fadeIn;
    currentFadeInDuration = fadeIn;
});

// Fade Out slider control
const fadeOutSlider = document.getElementById('fadeOutSlider');
const fadeOutValue = document.getElementById('fadeOutValue');

fadeOutSlider.addEventListener('input', (e) => {
    const fadeOut = parseInt(e.target.value);
    fadeOutValue.textContent = fadeOut;
    currentFadeOutDuration = fadeOut;
});

        // Speed slider control (with pitch change)
        speedSlider.addEventListener('input', (e) => {
            const speed = parseInt(e.target.value);
            speedValue.textContent = speed;
            audioPlayer.playbackRate = speed / 100;
            // Preserve pitch is false by default, so pitch will change with speed
            audioPlayer.preservesPitch = false;
        });

        // Show loading indicator
        function showLoadingIndicator() {
            isLoadingMetadata = true;
            
            // Show loading in filter section
            const filterContainer = document.getElementById('filterTags');
            filterContainer.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-spinner"></div>
                    <span>Loading metadata...</span>
                </div>
            `;
            
            // Show loading in song tags section
            const songContainer = document.getElementById('songTags');
            songContainer.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-spinner"></div>
                    <span>Loading metadata...</span>
                </div>
            `;
        }

        // Hide loading indicator and render tags
        function hideLoadingIndicator() {
            isLoadingMetadata = false;
            renderFilterTags();
            renderSongTags();
        }

        // Add a new tag to master list
function addNewTag(tagName) {
    tagName = tagName.trim();
    if (!tagName) return;
    
    // Check if tag already exists
    if (masterTags[tagName]) {
        console.log(`Tag "${tagName}" already exists with category: ${masterTags[tagName].category}`);
        return;
    }
    
    // Get category - must not be "All"
    let category;
    
    // Check if it's in predefined tags
    if (PREDEFINED_TAGS[tagName]) {
        category = PREDEFINED_TAGS[tagName];
        console.log(`Using predefined category for "${tagName}": ${category}`);
    } else {
        category = currentTagCategory;
        console.log(`Using current category for "${tagName}": ${category}`);
    }
    
    // Safety check: never allow "All" as a category
    if (category === 'All') {
        console.error('Cannot add tag without a specific category selected');
        alert('Please select a specific category (Artist, Genre, Vibe, Instrument, Album, Playlist, Structure, or Utility) before adding a new tag.');
        return;
    }
    
    // Add to master tags
    masterTags[tagName] = {
        category: category,
        songCount: 0
    };
    
    console.log(`âœ“ Added new tag "${tagName}" with category "${category}"`);
    console.log('Current masterTags entry:', masterTags[tagName]);
    
    renderSongTags();
    renderFilterTags();
}

// Show tag input field
function showTagInput() {
    // Don't allow adding tags if "All" category is selected
    if (currentTagCategory === 'All') {
        alert('Please select a specific category (Artist, Genre, Vibe, Instrument, Album, Playlist, Structure, or Utility) to add a new tag.');
        return;
    }
    
    const songTagsContainer = document.getElementById('songTags');
    const existingInput = songTagsContainer.querySelector('.tag-input');
    if (existingInput) return;

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'tag-input';
    input.placeholder = `New ${currentTagCategory}...`;
    
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const tagName = input.value.trim();
            if (tagName) {
                // Check if tag already exists (case-insensitive)
                const existingTag = Object.keys(masterTags).find(t => t.toLowerCase() === tagName.toLowerCase());
                
                if (existingTag) {
                    // Use existing tag
                    if (multiSelectMode && selectedSongs.size > 0) {
                        // Add to all selected songs
                        selectedSongs.forEach(filename => {
                            const config = getSongConfig(filename);
                            const tags = new Set(config.tags || []);
                            tags.add(existingTag);
                            updateSongConfig(filename, { tags: Array.from(tags) });
                        });
                        selectedSongTags.add(existingTag);
                    } else {
                        // Add to current song only
                        selectedSongTags.add(existingTag);
                    }
                    console.log(`Using existing tag: ${existingTag}`);
                } else {
                    // Add new tag to master list FIRST
                    addNewTag(tagName);
                    // Then add to songs (only if addNewTag succeeded)
                    if (masterTags[tagName]) {
                        if (multiSelectMode && selectedSongs.size > 0) {
                            // Add to all selected songs
                            selectedSongs.forEach(filename => {
                                const config = getSongConfig(filename);
                                const tags = new Set(config.tags || []);
                                tags.add(tagName);
                                updateSongConfig(filename, { tags: Array.from(tags) });
                            });
                            selectedSongTags.add(tagName);
                        } else {
                            // Add to current song only
                            selectedSongTags.add(tagName);
                        }
                        console.log(`Added new tag to ${multiSelectMode && selectedSongs.size > 0 ? selectedSongs.size + ' songs' : 'current song'}: ${tagName}`);
                    }
                }
                
                // Save and re-render
                renderSongTags();
                if (multiSelectMode && selectedSongs.size > 0) {
                    // Save config for all selected songs
                    saveConfig().then(() => {
                        buildMasterTagsFromConfig();
            renderFilterTags();
            // Update displays if current song is in selection
            if (currentlyPlayingFile && selectedSongs.has(currentlyPlayingFile.name)) {
                updateNowPlayingDisplay();
                if (collapsedSections.player) {
                    updateCompactPlayer();
                }
            }
            console.log(`Batch ${adding ? 'added' : 'removed'} tag "${tagName}" ${adding ? 'to' : 'from'} ${selectedSongs.size} songs`);
                    });
                } else {
                    // Save tags for current song
                    saveTags();
                }
            }
            input.remove();
        } else if (e.key === 'Escape') {
            input.remove();
        }
    });

    input.addEventListener('blur', () => {
        setTimeout(() => input.remove(), 200);
    });

    songTagsContainer.insertBefore(input, songTagsContainer.firstChild);
    input.focus();
}

// Toggle tag selection for current song
function toggleSongTag(tagName) {
        if (!selectedSongTags.has(tagName) && blacklistedTags.has(tagName)) {
        blacklistedTags.delete(tagName);
        console.log(`Removed "${tagName}" from blacklist (manually added)`);
        saveConfig();
    }
    // Check if tags are locked
// Filter out locked songs from selection
    if (multiSelectMode && selectedSongs.size > 0) {
        // Multi-select mode: toggle tag for all NON-LOCKED selected songs
        const unlockedSongs = [];
        selectedSongs.forEach(filename => {
            const config = getSongConfig(filename);
            if (!config.tagsLocked) {
                unlockedSongs.push(filename);
            }
        });
        
        if (unlockedSongs.length === 0) {
            // All songs are locked, do nothing silently
            return;
        }
        
        const adding = !selectedSongTags.has(tagName);
        
        unlockedSongs.forEach(filename => {
            const config = getSongConfig(filename);
            const tags = new Set(config.tags || []);
            
            if (adding) {
                tags.add(tagName);
            } else {
                tags.delete(tagName);
            }
            
            updateSongConfig(filename, { tags: Array.from(tags) });
            invalidateTagColorCache(filename);
        });
        
                // Update selected song tags display
        if (adding) {
            selectedSongTags.add(tagName);
        } else {
            selectedSongTags.delete(tagName);
        }
        
        // Handle Artist tag removal/change
        if (currentlyPlayingFile && masterTags[tagName]) {
            const config = getSongConfig(currentlyPlayingFile.name);
            const tagData = masterTags[tagName];
            
            if (tagData.category === 'Artist') {
                // Check if another Artist tag is selected
                const otherArtistTag = Array.from(selectedSongTags).find(t => 
                    masterTags[t] && masterTags[t].category === 'Artist'
                );
                
                if (otherArtistTag) {
                    // Switch to the other artist
                    config.artist = otherArtistTag;
                    console.log(`Changed artist property from ${tagName} to: ${otherArtistTag}`);
                }
                // Don't remove artist property if just removing the tag
            }
        }
            
        
        
        renderSongTags();
        
        // Save all changes
        saveConfig().then(() => {
            buildMasterTagsFromConfig();
            renderFilterTags();
            
            // UPDATE COLORS INSTANTLY if current song is in the selection (but only if no custom colors are set)
            if (useTagColors && currentlyPlayingFile && selectedSongs.has(currentlyPlayingFile.name)) {
                const config = getSongConfig(currentlyPlayingFile.name);
                const hasCustomColor1 = config.customColor1;
                const hasCustomColor2 = config.customColor2;
                
                if (!hasCustomColor1 && !hasCustomColor2) {
                    // Only update if no custom colors are set
                    const { color1, color2 } = getAccentColorsFromTags(config.tags || []);
                    updateAccentColors(color1, color2);
                    document.getElementById('songColor1Picker').value = color1;
                    document.getElementById('songColor2Picker').value = color2;
                }
            }
            
            console.log(`Batch ${adding ? 'added' : 'removed'} tag "${tagName}" ${adding ? 'to' : 'from'} ${unlockedSongs.length} songs (skipped ${selectedSongs.size - unlockedSongs.length} locked)`);
        });
    } else {
        // Single song mode: toggle tag for current song only
        if (selectedSongTags.has(tagName)) {
            selectedSongTags.delete(tagName);
        } else {
            selectedSongTags.add(tagName);
        }
        
        // Sync Artist/Album tags to properties
        if (currentlyPlayingFile) {
            const config = getSongConfig(currentlyPlayingFile.name);
            const tagData = masterTags[tagName];
            
            if (tagData) {
                if (tagData.category === 'Artist') {
                    config.artist = tagName;
                    console.log(`Set artist property to: ${tagName}`);
                } else if (tagData.category === 'Album') {
                    config.album = tagName;
                    console.log(`Set album property to: ${tagName}`);
                }
            }
        }
            
        
        renderSongTags();
        
        // Automatically save tags
        saveTags();
    }
}

function renderSongTags() {
    if (isLoadingMetadata) return;
    
    const container = document.getElementById('songTags');
    const selectedContainer = document.getElementById('selectedSongTagsContainer');
    
    container.innerHTML = '';
    
    // Only clear selected container if it exists (otherwise old version of HTML)
    if (selectedContainer) {
        selectedContainer.innerHTML = '';
    }
    
    // Check if tags are locked
    let tagsLocked = false;
    if (multiSelectMode && selectedSongs.size > 0) {
        // Check if all selected songs have locked tags
        tagsLocked = Array.from(selectedSongs).every(filename => {
            const config = getSongConfig(filename);
            return config.tagsLocked === true;
        });
    } else if (currentlyPlayingFile) {
        const config = getSongConfig(currentlyPlayingFile.name);
        tagsLocked = config.tagsLocked === true;
    }
    
// If tags are locked, show locked message and tag list only
    if (tagsLocked) {
        const brighterColor = getBrighterColor(accentColor1, accentColor2);
        
        const lockedDiv = document.createElement('div');
        lockedDiv.style.cssText = `padding: 15px; background: #2a2a2a; border-radius: 8px; border: 1px solid ${brighterColor};`;
        
        const lockIcon = document.createElement('div');
        lockIcon.style.cssText = `color: ${brighterColor}; font-size: 14px; font-weight: 600; margin-bottom: 10px;`;
        lockIcon.textContent = 'ðŸ”’ Tags Locked';
        lockedDiv.appendChild(lockIcon);
        
        // Show current tags as read-only
        const tagsDiv = document.createElement('div');
        tagsDiv.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px;';
        
        const tags = Array.from(selectedSongTags);
        
        // Sort tags based on current sort settings
        tags.sort((a, b) => {
            let comparison = 0;
            
            if (tagSortBy === 'alphabetical') {
                comparison = a.localeCompare(b);
            } else if (tagSortBy === 'songCount') {
                const countA = masterTags[a]?.songCount || 0;
                const countB = masterTags[b]?.songCount || 0;
                comparison = countB - countA;
            }
            
            return tagSortAscending ? comparison : -comparison;
        });
        
        if (tags.length > 0) {
            tags.forEach(tag => {
                const tagSpan = document.createElement('span');
                tagSpan.style.cssText = `padding: 6px 12px; background: linear-gradient(135deg, ${accentColor1}, ${accentColor2}); color: #1a1a1a; border-radius: 15px; font-size: 13px; font-weight: 600;`;
                tagSpan.textContent = tag;
                tagsDiv.appendChild(tagSpan);
            });
        } else {
            const noTags = document.createElement('span');
            noTags.style.cssText = 'color: #888; font-style: italic; font-size: 13px;';
            noTags.textContent = 'No tags';
            tagsDiv.appendChild(noTags);
        }
        
        lockedDiv.appendChild(tagsDiv);
        container.appendChild(lockedDiv);
        
        // Update lock button
        updateLockTagsButton();
        return; // Don't show tag editing interface
    }
    
// NEW: Render selected song tags at top
    if (selectedContainer) {
        // Combine current tags and initial tags (removed tags will be shown grayed out)
        const allTagsToShow = new Set([...selectedSongTags, ...initialSongTags]);
        const tags = Array.from(allTagsToShow);
        
        // Sort tags based on current sort settings
        tags.sort((a, b) => {
            let comparison = 0;
            
            if (tagSortBy === 'alphabetical') {
                comparison = a.localeCompare(b);
            } else if (tagSortBy === 'songCount') {
                const countA = masterTags[a]?.songCount || 0;
                const countB = masterTags[b]?.songCount || 0;
                comparison = countB - countA;
            }
            
            return tagSortAscending ? comparison : -comparison;
        });
        
        tags.forEach(tag => {
            const pill = document.createElement('button');
            pill.className = 'tag-pill';
            
            const isActive = selectedSongTags.has(tag);
            const wasInitial = initialSongTags.has(tag);
            
            if (isActive) {
                // Tag is currently on the song - show with accent colors
                pill.style.background = currentAccentGradient;
                pill.style.color = '#1a1a1a';
                pill.style.borderColor = getBrighterColor(accentColor1, accentColor2);
            } else if (wasInitial) {
                // Tag was removed but was initially on the song - show grayed out
                pill.style.background = '#2a2a2a';
                pill.style.color = '#666';
                pill.style.borderColor = '#444';
                pill.style.opacity = '0.6';
            }
            
            pill.textContent = tag;
            pill.onclick = () => toggleSongTag(tag);
            selectedContainer.appendChild(pill);
        });
        
        // Show placeholder if no tags at all
        if (tags.length === 0) {
            const placeholder = document.createElement('span');
            placeholder.style.color = '#666';
            placeholder.style.fontSize = '12px';
            placeholder.textContent = 'No tags on this song';
            selectedContainer.appendChild(placeholder);
        }
    }
    
    // Show selection info if in multi-select mode
    if (multiSelectMode && selectedSongs.size > 0) {
        const infoDiv = document.createElement('div');
        infoDiv.style.cssText = 'color: #ff6b35; font-size: 12px; margin-bottom: 10px; font-weight: 600;';
        infoDiv.textContent = `Editing ${selectedSongs.size} song${selectedSongs.size !== 1 ? 's' : ''}`;
        container.appendChild(infoDiv);
    }

    // Only show Add button if a specific category is selected (not "All")
    if (currentTagCategory !== 'All') {
        const addBtn = document.createElement('button');
        const brighterColor = getBrighterColor(accentColor1, accentColor2);
        addBtn.className = 'add-tag-btn';
        addBtn.style.borderColor = brighterColor;
        addBtn.style.color = brighterColor;
        
        // Show which category will be added
        addBtn.textContent = `+ Add ${currentTagCategory}`;
        addBtn.onclick = showTagInput;
        container.appendChild(addBtn);
    }

    // Get filtered and sorted tags
    const filteredTags = getFilteredTags();
    
    filteredTags.forEach(tag => {
        const pill = document.createElement('button');
        pill.className = 'tag-pill';
        
        // Check if this tag is selected for the current song
        const brighterColor = getBrighterColor(accentColor1, accentColor2);
        if (selectedSongTags.has(tag)) {
            pill.classList.add('active');
            pill.style.background = currentAccentGradient;
            pill.style.color = '#1a1a1a';
            pill.style.borderColor = brighterColor;
        } else {
            pill.style.borderColor = brighterColor;
            pill.style.color = brighterColor;
            pill.style.background = 'transparent';
        }
        pill.textContent = tag;
        pill.onclick = () => toggleSongTag(tag);
        container.appendChild(pill);
    });
}


// Toggle filter tag selection
function selectFilterTag(tagName) {
    const selectedContainer = document.getElementById('selectedFiltersContainer');
    
    if (tagName === 'all') {
        selectedFilterTags.clear();
        excludedFilterTags.clear();
        selectedFilterTags.add('all');
    } else {
        selectedFilterTags.delete('all');
        
        if (tagFilterMode === 'include') {
            // Include mode
            if (tagSelectMode === 'single') {
                // Single select mode - allow deselection if clicking the same tag
                if (selectedFilterTags.has(tagName)) {
                    selectedFilterTags.delete(tagName);
                    
                    // NEW: Mark as removed in selected container
                    if (selectedContainer) {
                        const pills = selectedContainer.querySelectorAll('.tag-pill');
                        pills.forEach(pill => {
                            if (pill.textContent.startsWith(tagName + ' ') && !pill.classList.contains('removed')) {
                                pill.classList.add('removed');
                            }
                        });
                    }
                    
                    if (selectedFilterTags.size === 0 && excludedFilterTags.size === 0) {
                        selectedFilterTags.add('all');
                    }
                } else {
                    selectedFilterTags.clear();
                    selectedFilterTags.add(tagName);
                }
            } else {
                // Multi select mode
                if (selectedFilterTags.has(tagName)) {
                    selectedFilterTags.delete(tagName);
                    
                    // NEW: Mark as removed in selected container
                    if (selectedContainer) {
                        const pills = selectedContainer.querySelectorAll('.tag-pill');
                        pills.forEach(pill => {
                            if (pill.textContent.startsWith(tagName + ' ') && !pill.classList.contains('removed')) {
                                pill.classList.add('removed');
                            }
                        });
                    }
                    
                    if (selectedFilterTags.size === 0 && excludedFilterTags.size === 0) {
                        selectedFilterTags.add('all');
                    }
                } else {
                    selectedFilterTags.add(tagName);
                    
                    // NEW: Re-enable if was removed
                    if (selectedContainer) {
                        const pills = selectedContainer.querySelectorAll('.tag-pill');
                        pills.forEach(pill => {
                            if (pill.textContent.startsWith(tagName + ' ')) {
                                pill.classList.remove('removed');
                            }
                        });
                    }
                }
            }
        } else {
            // Exclude mode - always multi-select for excludes
            if (excludedFilterTags.has(tagName)) {
                excludedFilterTags.delete(tagName);
                
                // NEW: Mark as removed in selected container
                if (selectedContainer) {
                    const pills = selectedContainer.querySelectorAll('.tag-pill');
                    pills.forEach(pill => {
                        if (pill.textContent.startsWith(tagName + ' ') && !pill.classList.contains('removed')) {
                            pill.classList.add('removed');
                        }
                    });
                }
                
                if (selectedFilterTags.size === 0 && excludedFilterTags.size === 0) {
                    selectedFilterTags.add('all');
                }
            } else {
                excludedFilterTags.add(tagName);
                
                // NEW: Re-enable if was removed
                if (selectedContainer) {
                    const pills = selectedContainer.querySelectorAll('.tag-pill');
                    pills.forEach(pill => {
                        if (pill.textContent.startsWith(tagName + ' ')) {
                            pill.classList.remove('removed');
                        }
                    });
                }
            }
        }
    }
    
    // Clear search bar when clicking a tag
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.value = '';
        searchQuery = '';
    }
    
    renderFilterTags();
    updateAudioFilesList();
    
    // Save filter state
    saveConfig();
}


// Toggle multi-select mode
function toggleMultiSelect() {
    multiSelectMode = !multiSelectMode;
    const btn = document.getElementById('multiSelectBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    
    if (multiSelectMode) {
        btn.classList.add('active');
        btn.style.background = currentAccentGradient;
        btn.style.color = '#1a1a1a';
        btn.style.borderColor = accentColor1;
        selectAllBtn.style.display = 'block';
    } else {
        btn.classList.remove('active');
        btn.style.background = '';
        btn.style.color = '';
        btn.style.borderColor = '#3a3a3a';
        selectAllBtn.style.display = 'none';
        // Clear all selections
        selectedSongs.clear();
    }
    
    // Re-render playlist with/without checkboxes
    displayPlaylist();
    
    // Update the tagging section to show appropriate message
    updateTaggingDisplay();
}

// Toggle select all/deselect all
function toggleSelectAll() {
    const selectAllBtn = document.getElementById('selectAllBtn');
    
    // Check if all visible songs are already selected
    const allSelected = audioFiles.every(file => selectedSongs.has(file.name));
    
    if (allSelected) {
        // Deselect all visible songs
        audioFiles.forEach(file => selectedSongs.delete(file.name));
        selectAllBtn.textContent = 'Select All';
    } else {
        // Select all visible songs
        audioFiles.forEach(file => selectedSongs.add(file.name));
        selectAllBtn.textContent = 'Deselect All';
    }
    
    // Re-render playlist to update checkboxes
    displayPlaylist();
    updateTaggingDisplay();
}

// Clear all tags from current song(s) with confirmation
async function clearAllTags() {
    // Get the songs to clear tags from
    let songsToProcess = [];
    
    if (multiSelectMode && selectedSongs.size > 0) {
        // Multi-select mode: get file objects for all selected songs
        selectedSongs.forEach(filename => {
            const file = audioFiles.find(f => f.name === filename);
            if (file) songsToProcess.push(file);
        });
    } else if (currentlyPlayingFile) {
        // Single song mode: use currently playing file
        songsToProcess = [currentlyPlayingFile];
    }
    
    if (songsToProcess.length === 0) {
        alert('No song selected');
        return;
    }
    
    // Define protected tags that should not be removed
    const protectedTags = ['DELETE', 'Original from duped'];
    
    // Create confirmation message
    const songText = songsToProcess.length === 1 
        ? `"${songsToProcess[0].name}"` 
        : `${songsToProcess.length} selected songs`;
    
    const confirmed = confirm(
        `Are you sure you want to remove ALL tags from ${songText}?\n\n(Note: "DELETE" and "Original from duped" tags will be preserved)\n\nThis action cannot be undone.`
    );
    
    if (!confirmed) {
        return; // User cancelled
    }
    
    // Clear tags for each selected song
    songsToProcess.forEach(file => {
        const config = getSongConfig(file.name);
        
        // Get the current tags before clearing
        const oldTags = config.tags || [];
        
        // Separate protected tags from tags to remove
        const tagsToRemove = oldTags.filter(tag => !protectedTags.includes(tag));
        const tagsToKeep = oldTags.filter(tag => protectedTags.includes(tag));
        
        // Update master tags count only for tags being removed
        tagsToRemove.forEach(tag => {
            if (masterTags[tag]) {
                masterTags[tag].songCount = Math.max(0, (masterTags[tag].songCount || 0) - 1);
                // Remove tag from master if count reaches 0
                if (masterTags[tag].songCount === 0) {
                    delete masterTags[tag];
                }
            }
        });
        
        // Keep only protected tags
        config.tags = tagsToKeep;
    });
    
    // Save configuration
    await saveConfig();
    
    // Rebuild master tags and update UI
    buildMasterTagsFromConfig();
    renderFilterTags();
    
    // Update the tag display based on mode
    if (multiSelectMode && selectedSongs.size > 0) {
        // Update selectedSongTags to only show protected tags that are common to all
        loadMultiSongTags();
    } else if (currentlyPlayingFile) {
        // Update for single song
        const config = getSongConfig(currentlyPlayingFile.name);
        selectedSongTags.clear();
        if (config.tags) {
            config.tags.forEach(tag => selectedSongTags.add(tag));
        }
        renderSongTags();
    }
    
    // Update colors if tag colors are enabled and current song was affected
    if (useTagColors && currentlyPlayingFile) {
        const wasAffected = songsToProcess.some(file => file.name === currentlyPlayingFile.name);
        if (wasAffected) {
            updateColorsFromCurrentSong();
        }
    }
    
    // Show success message
    const message = songsToProcess.length === 1 
        ? 'All tags cleared from song (protected tags preserved)' 
        : `All tags cleared from ${songsToProcess.length} songs (protected tags preserved)`;
    
    alert(message);
}

// Toggle lock tags for current song(s)
async function toggleLockTags() {
    // Get the songs to lock/unlock
    let songsToProcess = [];
    
    if (multiSelectMode && selectedSongs.size > 0) {
        // Multi-select mode: get file objects for all selected songs
        selectedSongs.forEach(filename => {
            const file = audioFiles.find(f => f.name === filename);
            if (file) songsToProcess.push(file);
        });
    } else if (currentlyPlayingFile) {
        // Single song mode: use currently playing file
        songsToProcess = [currentlyPlayingFile];
    }
    
    if (songsToProcess.length === 0) {
        alert('No song selected');
        return;
    }
    
    // Determine if we're locking or unlocking based on first song
    const firstConfig = getSongConfig(songsToProcess[0].name);
    const shouldLock = !firstConfig.tagsLocked;
    
    // Apply lock/unlock to all selected songs
    songsToProcess.forEach(file => {
        const config = getSongConfig(file.name);
        config.tagsLocked = shouldLock;
    });
    
    // Save configuration
    await saveConfig();
    
    // Update UI
    renderSongTags();
    updateLockTagsButton();
    updateAudioFilesList(); // Refresh playlist to show checkmarks
    
    // Show message
    const action = shouldLock ? 'locked' : 'unlocked';
    const message = songsToProcess.length === 1 
        ? `Tags ${action} for song` 
        : `Tags ${action} for ${songsToProcess.length} songs`;
    
    console.log(message);
}

// Update the lock tags button text and style
function updateLockTagsButton() {
    const btn = document.getElementById('lockTagsBtn');
    if (!btn) return;
    
    const brighterColor = getBrighterColor(accentColor1, accentColor2);
    
    let isLocked = false;
    
    if (multiSelectMode && selectedSongs.size > 0) {
        // Check if all selected songs are locked
        const allLocked = Array.from(selectedSongs).every(filename => {
            const config = getSongConfig(filename);
            return config.tagsLocked === true;
        });
        isLocked = allLocked;
    } else if (currentlyPlayingFile) {
        const config = getSongConfig(currentlyPlayingFile.name);
        isLocked = config.tagsLocked === true;
    }
    
    if (isLocked) {
        btn.textContent = 'ðŸ”’ Unlock Tags';
        btn.style.background = brighterColor;
        btn.style.color = '#1a1a1a';
        btn.style.borderColor = brighterColor;
    } else {
        btn.textContent = 'ðŸ”“ Lock Tags';
        btn.style.background = '#2a2a2a';
        btn.style.color = brighterColor;
        btn.style.borderColor = brighterColor;
    }
}
// Add this function to handle tag search
function handleTagSearch(query) {
    tagSearchQuery = query.toLowerCase().trim();
    
    // Sync both search inputs
    document.getElementById('filterTagSearch').value = query;
    document.getElementById('songTagSearch').value = query;
    
    // Set category to "All" when searching
    if (tagSearchQuery) {
        currentTagCategory = 'All';
        document.getElementById('filterCategorySelect').value = 'All';
        document.getElementById('songCategorySelect').value = 'All';
    }
    
    // Re-render both tag sections with filtered results
    renderFilterTags();
    renderSongTags();
}

// Add this function to clear tag search
function clearTagSearch() {
    tagSearchQuery = '';
    document.getElementById('filterTagSearch').value = '';
    document.getElementById('songTagSearch').value = '';
    renderFilterTags();
    renderSongTags();
}
// Update tagging display based on selection
function updateTaggingDisplay() {
    if (!multiSelectMode || selectedSongs.size === 0) {
        // Show tags for currently playing song
        if (currentlyPlayingFile) {
            loadSongTags(currentlyPlayingFile.name);
        }
    } else {
        // Show combined tags from all selected songs
        loadMultiSongTags();
    }
    updateLockTagsButton();
}

// Load tags that are common or present across selected songs
function loadMultiSongTags() {
    selectedSongTags.clear();
    
    if (selectedSongs.size === 0) return;
    
    // Get all tags from all selected songs
    const allTags = new Map(); // tag -> count of songs that have it
    
    selectedSongs.forEach(filename => {
        const config = getSongConfig(filename);
        if (config.tags) {
            config.tags.forEach(tag => {
                allTags.set(tag, (allTags.get(tag) || 0) + 1);
            });
        }
    });
    
    // Include tags that are in ALL selected songs (for display purposes)
    allTags.forEach((count, tag) => {
        if (count === selectedSongs.size) {
            selectedSongTags.add(tag);
        }
    });
    
    renderSongTags();
    updateLockTagsButton();
}

// Handle song checkbox click
function toggleSongSelection(event, file) {
    event.stopPropagation(); // Prevent playing the song
    
    // Find the index of the clicked file
    const currentIndex = audioFiles.findIndex(f => f.name === file.name);
    
    // Handle shift-click for range selection
    if (event.shiftKey && lastSelectedIndex !== -1 && lastSelectedIndex !== currentIndex) {
        // Determine the range
        const start = Math.min(lastSelectedIndex, currentIndex);
        const end = Math.max(lastSelectedIndex, currentIndex);
        
        // Determine whether to select or deselect based on the current file's state
        const shouldSelect = !selectedSongs.has(file.name);
        
        // Apply the selection state to all files in the range
        for (let i = start; i <= end; i++) {
            if (shouldSelect) {
                selectedSongs.add(audioFiles[i].name);
            } else {
                selectedSongs.delete(audioFiles[i].name);
            }
        }
        
        // Update all checkboxes in the range
        const checkboxes = document.querySelectorAll('.playlist-item-checkbox');
        for (let i = start; i <= end; i++) {
            if (checkboxes[i]) {
                checkboxes[i].checked = shouldSelect;
            }
        }
    } else {
        // Normal single selection toggle
        if (selectedSongs.has(file.name)) {
            selectedSongs.delete(file.name);
        } else {
            selectedSongs.add(file.name);
        }
        
        // Update the checkbox
        const checkbox = event.target;
        checkbox.checked = selectedSongs.has(file.name);
    }
    
    // Update last selected index
    lastSelectedIndex = currentIndex;
    
    // Update select all button text
    const selectAllBtn = document.getElementById('selectAllBtn');
    const allSelected = audioFiles.every(f => selectedSongs.has(f.name));
    selectAllBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
    
    // Update tagging display
    updateTaggingDisplay();
}

// Update the audioFiles list based on current filter and shuffle state
function updateAudioFilesList() {
    // Get filtered files based on selected tags
    let filteredFiles;
    
    // Step 1: Apply INCLUDE filters
    if (selectedFilterTags.has('all')) {
        // Start with all songs
        filteredFiles = [...originalOrder];
    } else if (selectedFilterTags.size > 0) {
        // Filter based on included tags
        filteredFiles = originalOrder.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return false;
            
            // Include mode: Show songs that match the selected tags
            if (tagMatchMode === 'and') {
                // ALL selected tags must be present
                return Array.from(selectedFilterTags).every(tag => config.tags.includes(tag));
            } else {
                // AT LEAST ONE selected tag must be present
                return config.tags.some(tag => selectedFilterTags.has(tag));
            }
        });
    } else {
        // No include tags selected, start with all songs
        filteredFiles = [...originalOrder];
    }
    
    // Step 2: Apply EXCLUDE filters (remove songs with excluded tags)
    if (excludedFilterTags.size > 0) {
        filteredFiles = filteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) {
                // Songs with no tags pass through (can't have excluded tags)
                return true;
            }
            
            // Remove songs that have ANY of the excluded tags
            return !config.tags.some(tag => excludedFilterTags.has(tag));
        });
    }
    
    // Step 3: ALWAYS exclude "DELETE" tag unless explicitly included
    if (!selectedFilterTags.has('DELETE')) {
        filteredFiles = filteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return true;
            
            // Remove songs that have the DELETE tag
            return !config.tags.includes('DELETE');
        });
    }

    // Step 4: ALWAYS exclude "Original from duped" tag unless explicitly included
    if (!selectedFilterTags.has('Original from duped')) {
        filteredFiles = filteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return true;
            
            // Remove songs that have the "Original from duped" tag
            return !config.tags.includes('Original from duped');
        });
    }
    
// Apply search filter
if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filteredFiles = filteredFiles.filter(file => {
        const config = getSongConfig(file.name);
        
        // Search in filename
        if (file.name.toLowerCase().includes(query)) return true;
        
        // Search in artist
        if (config.artist && config.artist.toLowerCase().includes(query)) return true;
        
        // Search in title
        if (config.title && config.title.toLowerCase().includes(query)) return true;
        
        return false;
    });
}
    
    // Apply sorting (before shuffle)
    filteredFiles = sortFiles(filteredFiles);
    
    // Apply shuffle if enabled
    if (isShuffled) {
        audioFiles = [...filteredFiles].sort(() => Math.random() - 0.5);
    } else {
        audioFiles = filteredFiles;
    }
    
    // Update current index based on currently playing file
    if (currentlyPlayingFile) {
        // Find the currently playing file in the new filtered list
        const playingIndex = audioFiles.findIndex(f => f.name === currentlyPlayingFile.name);
        
        if (playingIndex !== -1) {
            // Currently playing song is in the filtered list
            currentIndex = playingIndex;
        } else {
            // Currently playing song is NOT in the filtered list
            currentIndex = -1; // Set to -1 to indicate no valid selection
        }
    } else {
        // No song is currently playing
        currentIndex = audioFiles.length > 0 ? 0 : -1;
    }
    
    // Clear selections for songs that are no longer visible
    if (multiSelectMode) {
        const visibleSongs = new Set(audioFiles.map(f => f.name));
        const selectionsToRemove = [];
        
        selectedSongs.forEach(filename => {
            if (!visibleSongs.has(filename)) {
                selectionsToRemove.push(filename);
            }
        });
        
        selectionsToRemove.forEach(filename => selectedSongs.delete(filename));
        
        // Update select all button if needed
        if (selectionsToRemove.length > 0) {
            const selectAllBtn = document.getElementById('selectAllBtn');
            if (selectAllBtn) {
                const allSelected = audioFiles.every(f => selectedSongs.has(f.name));
                selectAllBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
            }
        }
    }
    
    displayPlaylist();
}
// Render filter tags
function renderFilterTags() {
    if (isLoadingMetadata) return;
    
    const container = document.getElementById('filterTags');
    const selectedContainer = document.getElementById('selectedFiltersContainer');
    
    if (!container) return;
    
    container.innerHTML = '';
    
    // Only clear selected container if it exists (otherwise old version of HTML)
    if (selectedContainer) {
        selectedContainer.innerHTML = '';
    }

    // "All" button
    const allBtn = document.createElement('button');
    allBtn.className = 'tag-pill';
    const brighterColor = getBrighterColor(accentColor1, accentColor2);
    if (selectedFilterTags.has('all')) {
        allBtn.classList.add('active');
        allBtn.style.background = currentAccentGradient;
        allBtn.style.color = '#1a1a1a';
        allBtn.style.borderColor = accentColor1;
    } else {
        allBtn.style.borderColor = brighterColor;
        allBtn.style.color = brighterColor;
        allBtn.style.background = 'transparent';
    }
    allBtn.textContent = 'All';
    allBtn.onclick = () => selectFilterTag('all');
    container.appendChild(allBtn);

    // Get filtered and sorted tags
    const filteredTags = getFilteredTags();
    
    // NEW: Render selected filters at top
    if (selectedContainer) {
        const selectedTags = [];
        const excludedTags = [];
        
        filteredTags.forEach(tag => {
            if (selectedFilterTags.has(tag)) {
                selectedTags.push(tag);
            } else if (excludedFilterTags.has(tag) || (tag === 'DELETE' && !selectedFilterTags.has(tag))) {
                excludedTags.push(tag);
            }
        });
        
        // Add included tags
        selectedTags.forEach(tag => {
            const pill = document.createElement('button');
            pill.className = 'tag-pill';
            pill.style.background = currentAccentGradient;
            pill.style.color = '#1a1a1a';
            pill.style.borderColor = getBrighterColor(accentColor1, accentColor2);
            pill.textContent = `${tag} (${masterTags[tag].songCount})`;
            pill.onclick = () => selectFilterTag(tag);
            selectedContainer.appendChild(pill);
        });
        
        // Add excluded tags
        excludedTags.forEach(tag => {
            const pill = document.createElement('button');
            pill.className = 'tag-pill';
            pill.style.background = 'linear-gradient(135deg, #ff3333, #cc0000)';
            pill.style.color = '#fff';
            pill.style.borderColor = '#ff3333';
            pill.textContent = `${tag} (${masterTags[tag].songCount})`;
            pill.onclick = () => selectFilterTag(tag);
            selectedContainer.appendChild(pill);
        });
        
        // Show placeholder if no filters selected
        if (selectedTags.length === 0 && excludedTags.length === 0) {
            const placeholder = document.createElement('span');
            placeholder.style.color = '#666';
            placeholder.style.fontSize = '12px';
            placeholder.textContent = 'No filters applied';
            selectedContainer.appendChild(placeholder);
        }
    }
    
    // Render all tags in main section
    filteredTags.forEach(tag => {
        const pill = document.createElement('button');
        pill.className = 'tag-pill';
        
        // Show song count
        const tagText = `${tag} (${masterTags[tag].songCount})`;
        
        // Check if included or excluded
        const isIncluded = selectedFilterTags.has(tag);
        const isExcluded = excludedFilterTags.has(tag);
        
        // Special handling for DELETE tag - always red unless explicitly included
        const isDeleteTag = tag === 'DELETE';
        const shouldShowAsExcluded = isExcluded || (isDeleteTag && !isIncluded);
        const brighterColor = getBrighterColor(accentColor1, accentColor2);
        if (isIncluded) {
            // Included tag - use accent color
            pill.classList.add('active');
            pill.style.background = currentAccentGradient;
            pill.style.color = '#1a1a1a';
            pill.style.borderColor = brighterColor;
        } else if (shouldShowAsExcluded) {
            // Excluded tag OR DELETE tag (unless included) - use red
            pill.classList.add('active');
            pill.style.background = 'linear-gradient(135deg, #ff3333, #cc0000)';
            pill.style.color = '#fff';
            pill.style.borderColor = '#ff3333';
        } else {
            // Not selected
            pill.style.borderColor = brighterColor;
            pill.style.color = brighterColor;
            pill.style.background = 'transparent';
        }
        
        pill.textContent = tagText;
        pill.onclick = () => selectFilterTag(tag);
        container.appendChild(pill);
    });
}

// Load tags from current song
function loadSongTags(filename) {
    // Don't override if in multi-select mode with selections
    if (multiSelectMode && selectedSongs.size > 0) {
        return;
    }
    
    selectedSongTags.clear();
    initialSongTags.clear(); // Clear initial tags for new song
    
    const config = getSongConfig(filename);
    if (config.tags) {
        config.tags.forEach(tag => {
            selectedSongTags.add(tag);
            initialSongTags.add(tag); // Store initial tags
        });
    }
    
    renderSongTags();
    updateLockTagsButton();
}

// Save tags for current song
async function saveTags() {
    if (!currentlyPlayingFile) return;
    
    const currentFile = currentlyPlayingFile;
    const tags = Array.from(selectedSongTags);
    
    // Update configuration
    updateSongConfig(currentFile.name, { tags: tags });
    invalidateTagColorCache(currentFile.name);
    // Save configuration file
    await saveConfig();
    
    // Rebuild master tags to update song counts
    buildMasterTagsFromConfig();
    renderFilterTags();
    
    // Update now playing display to show new tag count
    updateNowPlayingDisplay();
    if (collapsedSections.player) {
        updateCompactPlayer();
    }
    
    // UPDATE COLORS INSTANTLY when tags change (but only if no custom colors are set)
    const config = getSongConfig(currentFile.name);
    const hasCustomColor1 = config.customColor1;
    const hasCustomColor2 = config.customColor2;
    
    if (useTagColors && !hasCustomColor1 && !hasCustomColor2) {
        // Only update if using tag colors AND no custom colors are set
        const { color1, color2 } = getAccentColorsFromTags(config.tags || []);
        updateAccentColors(color1, color2);
        document.getElementById('songColor1Picker').value = color1;
        document.getElementById('songColor2Picker').value = color2;
    }
    
    console.log('Tags saved for:', currentFile.name, tags);
}



        // Accent color pickers
        const accentColorPicker1 = document.getElementById('accentColorPicker1');
        const accentColorPicker2 = document.getElementById('accentColorPicker2');
        // Search input handler
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', (e) => {
            searchQuery = e.target.value;
            updateAudioFilesList();
        });

function updateAccentColors(color1, color2) {
    accentColor1 = color1;
    accentColor2 = color2;
    currentAccentGradient = `linear-gradient(135deg, ${color1}, ${color2})`;
    
    // Determine which color is brighter for borders and text
    const brighterColor = getBrighterColor(color1, color2);

    updateFavicon(color1, color2);

 
    const headerLogo = document.getElementById('headerLogo');
    if (!headerLogo) return;
    
    // Update the gradient stops
    const gradient = headerLogo.querySelector('#lg1');
    if (gradient) {
        const stops = gradient.querySelectorAll('stop');
        stops[0].setAttribute('stop-color', color1);
        stops[1].setAttribute('stop-color', color2);
    }
    const help = document.querySelector('.help');
    help.style.borderColor = brighterColor;
    help.style.color = brighterColor;
    
                updateLockTagsButton();
            
            // Update clear all tags button
            const clearAllTagsBtn = document.getElementById('clearAllTagsBtn');
            if (clearAllTagsBtn) {
                clearAllTagsBtn.style.borderColor = '#8b0000'; // Dark red
                clearAllTagsBtn.style.color = '#cd5c5c'; // Lighter red
            }

    // Update all elements with gradient and brighter color
    document.documentElement.style.setProperty('--accent-color', color1);
    document.documentElement.style.setProperty('--accent-gradient', currentAccentGradient);
    document.documentElement.style.setProperty('--accent-color-bright', brighterColor);
            
            // Update specific elements with gradient
            const h1 = document.querySelector('h1');
            const h3 = document.querySelector('h3');
            h1.style.background = currentAccentGradient;
            h1.style.webkitBackgroundClip = 'text';
            h1.style.webkitTextFillColor = 'transparent';
            h1.style.backgroundClip = 'text';

            h3.style.background = currentAccentGradient;
            h3.style.webkitBackgroundClip = 'text';
            h3.style.webkitTextFillColor = 'transparent';
            h3.style.backgroundClip = 'text';
            
            const container = document.querySelector('.container');
            container.style.borderColor = brighterColor;

            const folderBtn = document.querySelector('.folder-btn');
            folderBtn.style.borderColor = brighterColor;
            folderBtn.style.color = brighterColor;

            const searchSection = document.querySelector('.search-section');
            searchSection.style.borderColor = brighterColor;

            // Add these lines to the updateAccentColors function:
                const sortOrderBtn = document.getElementById('sortOrderBtn');
                const scrollToSongBtn = document.querySelector('.scroll-to-song-btn');
                const sortSelect = document.getElementById('sortSelect');

                if (sortOrderBtn) {
                    sortOrderBtn.style.borderColor = brighterColor;
                }
                if (scrollToSongBtn) {
                    scrollToSongBtn.style.borderColor = brighterColor;
                }
                if (sortSelect) {
                    sortSelect.style.borderColor = brighterColor;
                }

            // Update visualizer controls section
            const visualizerControlsSection = document.querySelector('.visualizer-controls-section');
            if (visualizerControlsSection) {
                visualizerControlsSection.style.borderColor = brighterColor;
            }

            const taggingSection = document.querySelector('.tagging-section');
            taggingSection.style.borderColor = brighterColor;

            const filterSection = document.querySelector('.filter-section');
            filterSection.style.borderColor = brighterColor;

            const writeSongEditsBtn = document.getElementById('writeSongEditsBtn');
            if (writeSongEditsBtn) {
                writeSongEditsBtn.style.borderColor = brighterColor;
                if (!writeSongEditsBtn.disabled) {
                    writeSongEditsBtn.style.background = currentAccentGradient;
                }
            }

            const jsonSelectBtns = document.querySelectorAll('.json-select-btn');
            jsonSelectBtns.forEach(btn => {
                btn.style.borderColor = brighterColor;
                btn.style.color = brighterColor;
            });

            const jsonSelectBtnsSelected = document.querySelectorAll('.json-select-btn.selected');
            jsonSelectBtnsSelected.forEach(btn => {
                btn.style.background = currentAccentGradient;
                btn.style.color = '#1a1a1a';
                btn.style.borderColor = brighterColor;
            });

            const mergeArrow = document.querySelector('.merge-arrow');
            if (mergeArrow) {
                mergeArrow.style.color = brighterColor;
            }

            const mergeActionBtn = document.getElementById('mergeBtn');
            if (mergeActionBtn) {
                mergeActionBtn.style.borderColor = brighterColor;
                if (!mergeActionBtn.disabled) {
                    mergeActionBtn.style.background = currentAccentGradient;
                }
            }
                        
            // Update all section labels
            const sectionLabels = document.querySelectorAll('.section-label');
            sectionLabels.forEach(label => {
                label.style.background = currentAccentGradient;
                label.style.webkitBackgroundClip = 'text';
                label.style.webkitTextFillColor = 'transparent';
                label.style.backgroundClip = 'text';
            });
            
           // Update all tag pills
            const tagPills = document.querySelectorAll('.tag-pill');
            tagPills.forEach(pill => {
                pill.style.borderColor = brighterColor;
                pill.style.borderImage = 'none';
                if (!pill.classList.contains('active')) {
                    pill.style.background = 'transparent';
                    pill.style.color = brighterColor;
                }
            });

            // Update active tag pills
            const activeTagPills = document.querySelectorAll('.tag-pill.active');
            activeTagPills.forEach(pill => {
                pill.style.background = currentAccentGradient;
                pill.style.color = '#1a1a1a';
                pill.style.borderColor = brighterColor;
                pill.style.borderImage = 'none';
            });
            
            const visualizerCanvas = document.querySelector('.visualizer-canvas');
            visualizerCanvas.style.borderColor = brighterColor;

            const playlist = document.querySelector('.playlist');
            playlist.style.borderColor = brighterColor;

            const playerSection = document.querySelector('.player-section');
            playerSection.style.borderColor = brighterColor;

            const songCounter = document.getElementById('songCounter');
            if (songCounter) {
                songCounter.style.borderColor = brighterColor;
            }

            
            const nowPlayingEl = document.querySelector('.now-playing');
            nowPlayingEl.style.background = currentAccentGradient;
            nowPlayingEl.style.webkitBackgroundClip = 'text';
            nowPlayingEl.style.webkitTextFillColor = 'transparent';
            nowPlayingEl.style.backgroundClip = 'text';
            
            const progressBar = document.querySelector('.progress-bar');
            progressBar.style.background = currentAccentGradient;
            
            // Update control buttons - use solid color for circular buttons to preserve border-radius
            const controlBtns = document.querySelectorAll('.control-btn');
            controlBtns.forEach(btn => {
                btn.style.borderColor = brighterColor;
                //btn.style.borderImage = 'none';
                btn.style.color = brighterColor;
            });
            
            // Update active buttons
            const activeBtns = document.querySelectorAll('.control-btn.active');
            activeBtns.forEach(btn => {
                btn.style.background = currentAccentGradient;
                btn.style.color = '#1a1a1a';
                btn.style.borderColor = brighterColor;
                //btn.style.borderImage = 'none';
            });
            
            // Update active playlist item if exists
            const activeItem = document.querySelector('.playlist-item.active');
            if (activeItem) {
                activeItem.style.background = currentAccentGradient;
            }

            const toggleOptions = document.querySelectorAll('.toggle-option.active');
            toggleOptions.forEach(option => {
                option.style.background = currentAccentGradient;
            });

            const saveFadesBtn = document.querySelector('.save-fades-btn');
            if (saveFadesBtn) {
                saveFadesBtn.style.borderColor = brighterColor;
                saveFadesBtn.style.color = brighterColor;
            }

            const settingsSection = document.querySelector('.settings-section');
            if (settingsSection) {
                settingsSection.style.borderColor = brighterColor;
            }

            const settingItems = document.querySelectorAll('.setting-item');
            settingItems.forEach(item => {
                item.style.borderColor = brighterColor;
            });

            const settingCheckboxes = document.querySelectorAll('.setting-checkbox');
            settingCheckboxes.forEach(checkbox => {
                checkbox.style.accentcolor = brighterColor;
            });

            const tagSearchInputs = document.querySelectorAll('.tag-search-input');
tagSearchInputs.forEach(input => {
    input.style.borderColor = brighterColor;
});

            // Update visualizer toggle button
            const visualizerToggleBtn = document.getElementById('visualizerToggleBtn');
            if (visualizerToggleBtn) {
                visualizerToggleBtn.style.borderColor = brighterColor;
                visualizerToggleBtn.style.color = brighterColor;
                }

                const speedArrowBtns = document.querySelectorAll('.speed-arrow-btn');
                speedArrowBtns.forEach(btn => {
                    btn.style.borderColor = brighterColor;
                    btn.style.color = brighterColor;
                });

                const saveSpeedBtn = document.querySelector('.save-speed-btn');
                if (saveSpeedBtn) {
                    saveSpeedBtn.style.borderColor = brighterColor;
                    saveSpeedBtn.style.color = brighterColor;
                }

                const calculateDurationsBtn = document.getElementById('calculateDurationsBtn');
                if (calculateDurationsBtn) {
                    calculateDurationsBtn.style.borderColor = brighterColor;
                    if (!calculateDurationsBtn.disabled) {
                        calculateDurationsBtn.style.background = currentAccentGradient;
                    }
                }
                            
            // Update slider thumb color and dynamic hover styles
            const existingStyle = document.getElementById('dynamic-accent-styles');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            
            const style = document.createElement('style');
            style.id = 'dynamic-accent-styles';
            style.innerHTML = `
                .duration-slider::-webkit-slider-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .duration-slider::-moz-range-thumb {
                    background: ${currentAccentGradient} !important;
                }

                .playback-slider::-webkit-slider-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .playback-slider::-moz-range-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .visualizer-control-slider::-webkit-slider-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .visualizer-control-slider::-moz-range-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .control-group label {
                    background: ${currentAccentGradient} !important;
                    -webkit-background-clip: text !important;
                    -webkit-text-fill-color: transparent !important;
                    background-clip: text !important;
                }
                .folder-btn:hover {
                    background: ${color1} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .help:hover {
                    background: ${color1} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .control-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-color: ${color1} !important;
                }
                .collapse-handle {
                    color: ${color1} !important;
                }
                .player-compact-title {
                    background: ${currentAccentGradient} !important;
                    -webkit-background-clip: text !important;
                    -webkit-text-fill-color: transparent !important;
                    background-clip: text !important;
                }
                .checkbox-wrapper input[type="checkbox"] {
                    accent-color: ${color1} !important;
                }
                .speed-arrow-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .save-speed-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .visualizer-toggle-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                    .sort-order-btn:hover,
                    .scroll-to-song-btn:hover,
                    .sort-select:focus {
                        border-color: ${color1} !important;
                    }
                .trim-btn {
                    border-color: ${color1} !important;
                    color: ${color1} !important;
                }
                .trim-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                    .save-fades-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                    .setting-checkbox {
                    accent-color: ${color1} !important;
                }
                #calculateDurationsBtn {
                    border-color: ${color1} !important;
                    background: ${currentAccentGradient} !important;
                }
                #calculateDurationsBtn:hover:not(:disabled) {
                    background: ${color1} !important;
                }
                    .tag-search-input:focus {
    border-color: ${color1} !important;
}
                    .json-select-btn {
    border-color: ${color1} !important;
    color: ${color1} !important;
}
.json-select-btn:hover {
    background: ${color1}40 !important;
}
.json-select-btn.selected {
    background: ${currentAccentGradient} !important;
    color: #1a1a1a !important;
    border-color: ${color1} !important;
}
.merge-arrow {
    color: ${color1} !important;
}
.merge-action-btn {
    border-color: ${color1} !important;
    background: ${currentAccentGradient} !important;
}
.merge-action-btn:hover:not(:disabled) {
    background: ${color1} !important;
}
.merge-action-btn:disabled {
    color: ${color1} !important;
}
    .metadata-loading-content {
        border-color: ${color1} !important;
    }
    
    .metadata-loading-title {
        background: ${currentAccentGradient} !important;
        -webkit-background-clip: text !important;
        -webkit-text-fill-color: transparent !important;
        background-clip: text !important;
    }
    
    .metadata-progress-bar {
        background: ${currentAccentGradient} !important;
    }
    
    .metadata-loading-percentage {
        color: ${color1} !important;
    }
            `;
            document.head.appendChild(style);
        }
        // Update favicon with current accent colors
// Update favicon with current accent colors
function updateFavicon(color1, color2) {
    const favicon = document.getElementById('dynamicFavicon');
    if (!favicon) return;
    
    // URL-encode the colors (replace # with %23)
    const encodedColor1 = color1.replace('#', '%23');
    const encodedColor2 = color2.replace('#', '%23');
    
    // Create SVG with dynamic gradients
    const svgContent = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 197.09 197.09'>
        <defs>
            <linearGradient id='lg1' x1='18.3' y1='51.83' x2='178.93' y2='144.58' gradientUnits='userSpaceOnUse'>
                <stop offset='0' stop-color='${encodedColor1}'/>
                <stop offset='1' stop-color='${encodedColor2}'/>
            </linearGradient>
            <linearGradient id='lg2' x1='96.76' y1='67.87' x2='124.81' y2='84.06' href='%23lg1'/>
            <linearGradient id='lg3' x1='96.76' y1='126.45' x2='124.81' y2='142.64' gradientTransform='translate(221.95 .32) rotate(79.1)' href='%23lg1'/>
            <linearGradient id='lg4' x1='47.35' y1='68.57' x2='161.33' y2='134.37' href='%23lg1'/>
        </defs>
        <circle fill='%23231f20' cx='98.55' cy='98.55' r='98.55'/>
        <circle fill='url(%23lg1)' cx='98.61' cy='98.2' r='92.73'/>
        <circle fill='%23231f20' cx='99.87' cy='98.47' r='87.1'/>
        <circle fill='url(%23lg2)' cx='110.78' cy='75.97' r='16.19'/>
        <circle fill='url(%23lg3)' cx='110.78' cy='134.55' r='16.19' transform='translate(-42.28 217.89) rotate(-79.1)'/>
        <path fill='url(%23lg4)' d='M51.64,144.55c.05,1.91.18,5.43,2.5,7.95,1.12,1.22,3.58,3.14,6.82,4.09,1.33.39,10.31,3.02,15.91-2.73,3.01-3.09,3.47-7.24,3.64-9.32,2.12-25.98,2.03-72.69,2.05-76.36,0-.26,0-.67.05-1.22.76-9.69,10.47-15.74,11.05-16.09,3.91-2.36,7.38-2.91,11.22-3.52,4.04-.64,9.8-.55,15,.65,2.09.48,8.28,4.04,9.78,6.65.38.67,4.02,5.14,4.43,11.61.08,1.23.02,2.17,0,2.48-.86,14.19,1.91,73.11,1.04,79.43-.03.19-.13.9,0,1.83.37,2.54,2.22,4.23,2.61,4.57,3.37,2.93,9.58,2.44,12.13-.52,1-1.17,1.24-2.49,1.3-2.87,2.05-12.34-1.11-68.62-.78-83.35,0-.41.03-1,0-1.83-.29-9.3-5.01-18.76-11.74-24.65-6.05-5.3-12.08-7.35-22.57-8.22-14.15-1.18-26.53-.25-34.83,1.57-9.16,2-12.33,4.76-14.45,6.29-5.77,4.19-8.82,8.82-10.99,13.01-1.5,2.89-4.57,8.97-4.83,17.09-.03,1.09,0,1.9,0,2.22.21,7.42.12,50.09.64,71.24Z'/>
    </svg>`;
    
    favicon.href = `data:image/svg+xml,${svgContent}`;
}

        // Debounce timer for color picker
let colorPickerSaveTimeout = null;


// Tag colors button
document.getElementById('tagColorsBtn').addEventListener('click', openTagColorsModal);

// Close tag colors modal
document.getElementById('closeTagColorsBtn').addEventListener('click', closeTagColorsModal);

// Close on overlay click
document.getElementById('tagColorsOverlay').addEventListener('click', (e) => {
    if (e.target.id === 'tagColorsOverlay') {
        closeTagColorsModal();
    }
});

// Tag color search
document.getElementById('tagColorSearch').addEventListener('input', (e) => {
    renderTagColorsList(e.target.value);
});

// Use tag colors checkbox
document.getElementById('useTagColors').addEventListener('change', async (e) => {
    useTagColors = e.target.checked;
    
    if (useTagColors) {
        // Save current manual colors
        savedAccentColor1 = accentColor1;
        savedAccentColor2 = accentColor2;
        
        // Apply tag-based colors
        await updateColorsFromCurrentSong();
    } else {
        // Restore saved colors
        await transitionToColors(savedAccentColor1, savedAccentColor2);
    }
});

// Update saved colors when manual color pickers change
accentColorPicker1.addEventListener('change', (e) => {
    const color = e.target.value;
    if (!useTagColors) {
        savedAccentColor1 = color;
        accentColor1 = color;
        updateAccentColors(accentColor1, accentColor2);
        saveConfig();
    }
});

accentColorPicker2.addEventListener('change', (e) => {
    const color = e.target.value;
    if (!useTagColors) {
        savedAccentColor2 = color;
        accentColor2 = color;
        updateAccentColors(accentColor1, accentColor2);
        saveConfig();
    }
});


accentColorPicker1.addEventListener('input', (e) => {
    updateAccentColors(e.target.value, accentColor2);
    
    // Clear existing timeout
    if (colorPickerSaveTimeout) {
        clearTimeout(colorPickerSaveTimeout);
    }
    
    // Set new timeout to save after 500ms of inactivity
    colorPickerSaveTimeout = setTimeout(() => {
        saveConfig();
    }, 1500);
});

accentColorPicker2.addEventListener('input', (e) => {
    updateAccentColors(accentColor1, e.target.value);
    
    // Clear existing timeout
    if (colorPickerSaveTimeout) {
        clearTimeout(colorPickerSaveTimeout);
    }
    
    // Set new timeout to save after 500ms of inactivity
    colorPickerSaveTimeout = setTimeout(() => {
        saveConfig();
    }, 1500);
});

let isVisualizerFullscreen = false;

document.getElementById('visualizerFullscreenBtn').addEventListener('click', () => {
    isVisualizerFullscreen = !isVisualizerFullscreen;
    const visualizerSection = document.querySelector('.visualizer-section');
    const fullscreenBtn = document.getElementById('visualizerFullscreenBtn');
    const container = document.querySelector('.container');
    const playerSection = document.querySelector('.player-section');
    const canvas = document.getElementById('visualizer');
    
    if (isVisualizerFullscreen) {
        // Enter fullscreen
        visualizerSection.classList.add('visualizer-fullscreen');
        document.body.classList.add('visualizer-fullscreen-active');
        fullscreenBtn.textContent = 'âœ•';
        fullscreenBtn.style.background = '#ff6b35';
        fullscreenBtn.style.color = '#1a1a1a';
        
        // Hide only the PLAYLIST inside playlist-wrapper, not the whole wrapper
        const playlist = document.querySelector('.playlist');
        if (playlist) {
            playlist.classList.add('hide-when-fullscreen');
        }
        
        // Hide folder section
        const folderSection = document.querySelector('.folder-section');
        if (folderSection) {
            folderSection.classList.add('hide-when-fullscreen');
        }
        
        // Hide ALL visualizer controls
        const visualizerControls = visualizerSection.querySelectorAll('.duration-control, label, input[type="range"], input[type="checkbox"]');
        visualizerControls.forEach(control => {
            if (control.id !== 'visualizerFullscreenBtn') {
                control.classList.add('hide-when-fullscreen');
            }
        });
        
        // Hide control containers
        const controlDivs = visualizerSection.querySelectorAll('div');
        controlDivs.forEach(div => {
            if (div.querySelector('input[type="range"], input[type="checkbox"], label') && !div.querySelector('canvas')) {
                div.classList.add('hide-when-fullscreen');
            }
        });
        
        // Hide other elements
        const elementsToHide = document.querySelectorAll('h1, h3, .color-picker-container');
        elementsToHide.forEach(el => {
            el.classList.add('hide-when-fullscreen');
        });
        
        // Container styles
        container.style.background = 'transparent';
        container.style.border = 'none';
        container.style.boxShadow = 'none';
        container.style.padding = '0';
        
        // Player stays as-is since it's already position: fixed
        if (playerSection) {
            playerSection.style.width = '90%';
            playerSection.style.maxWidth = '1200px';
            playerSection.style.zIndex = '10001';
        }
        
    } else {
        // Exit fullscreen
        visualizerSection.classList.remove('visualizer-fullscreen');
        document.body.classList.remove('visualizer-fullscreen-active');
        fullscreenBtn.textContent = 'â›¶';
        fullscreenBtn.style.background = '#2a2a2a';
        fullscreenBtn.style.color = '#ff6b35';
        
        // Show all hidden elements
        document.querySelectorAll('.hide-when-fullscreen').forEach(el => {
            el.classList.remove('hide-when-fullscreen');
        });
        
        // Restore container
        container.style.background = '#1a1a1a';
        container.style.border = '1px solid #ff6b35';
        container.style.boxShadow = '0 20px 60px rgba(0, 0, 0, 0.8)';
        container.style.padding = '30px';
        
        // Restore player
        if (playerSection) {
            playerSection.style.width = '85%';
            playerSection.style.maxWidth = '800px';
            playerSection.style.zIndex = '1000';
        }
    }
    
    // Resize canvas
    setTimeout(() => {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
    }, 150);
});

// Exit with Escape
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && isVisualizerFullscreen) {
        document.getElementById('visualizerFullscreenBtn').click();
    }
});

        // Initialize audio context on first user interaction
function initAudioContext() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (!audioContext && !isIOS) {
        // Only create audio context on non-iOS
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        compressorNode = audioContext.createDynamicsCompressor();
        compressorNode.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressorNode.knee.setValueAtTime(30, audioContext.currentTime);
        compressorNode.ratio.setValueAtTime(12, audioContext.currentTime);
        compressorNode.attack.setValueAtTime(0.003, audioContext.currentTime);
        compressorNode.release.setValueAtTime(0.25, audioContext.currentTime);
        
        analyserNode = audioContext.createAnalyser();
        gainNode = audioContext.createGain();
        
        gainNode.connect(compressorNode);
        compressorNode.connect(analyserNode);
        analyserNode.connect(audioContext.destination);
        
        analyserNode.fftSize = 256;
        analyserNode.smoothingTimeConstant = 0.8;
    } else if (isIOS) {
        console.log('iOS mode - skipping Web Audio API initialization');
        // Create dummy nodes so code doesn't break
        analyserNode = null;
        gainNode = null;
    }
}

// Simple noise function for organic movement
function noise(x, y) {
    return Math.sin(x * 1.5 + y * 2.3) * Math.cos(x * 2.1 - y * 1.7) * 0.5 + 0.5;
}
// Draw visualizer
function drawVisualizer() {
    if (!analyserNode) {
        // No analyser on iOS - draw a simple static visualization
        const bgColor = '#0f0f0f';
        canvasCtx.fillStyle = bgColor;
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw a simple message
        canvasCtx.fillStyle = accentColor1;
        canvasCtx.font = '16px Arial';
        canvasCtx.textAlign = 'center';
        canvasCtx.fillText('Visualizer disabled on iOS', canvas.width / 2, canvas.height / 2);
        canvasCtx.fillText('(for background playback)', canvas.width / 2, canvas.height / 2 + 20);
        return;
    }

    // CRITICAL: Stop any existing animation loop before starting a new one
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }

    const bufferLength = analyserNode.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const waveformData = new Uint8Array(bufferLength);
    
const draw = () => {
    animationId = requestAnimationFrame(draw);
    
    // Check if visualizer is enabled and tab is visible
    if (!visualizerEnabled || !isTabVisible) {
        const bgColor = '#0f0f0f';
        canvasCtx.fillStyle = bgColor;
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        return;
    }
    
    const bgColor = '#0f0f0f';
    canvasCtx.fillStyle = bgColor;
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Determine which visualizer to actually draw
    const effectiveMode = visualizerMode === 'random' ? randomVisualizerMode : visualizerMode;
    
    if (effectiveMode === 'layered') {
            // Layered frequency bands mode
            analyserNode.getByteFrequencyData(dataArray);
            
            // Define frequency layers (Hz ranges)
            const layers = [
                { min: 0, max: 2000, opacity: 0.15, heightMultiplier: 1.25, name: 'bass' },
                { min: 2000, max: 5000, opacity: 0.3, heightMultiplier: 1.2, name: 'low-mid' },
                { min: 5000, max: 10000, opacity: 0.5, heightMultiplier: 1.15, name: 'mid' },
                { min: 10000, max: 15000, opacity: 1, heightMultiplier: 1.0, name: 'high-mid' }
            ];
            
            const nyquist = audioContext.sampleRate / 2;
            const barCount = 64;
            const barWidth = (canvas.width / barCount) * 0.8;
            const barGap = (canvas.width / barCount) * 0.2;
            
            // Draw layers from back to front (lowest opacity/lowest frequencies first)
            for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
                const layer = layers[layerIndex];
                
                // Calculate frequency bin range for this layer
                const minFreqBin = Math.floor((layer.min / nyquist) * bufferLength);
                const maxFreqBin = Math.floor((layer.max / nyquist) * bufferLength);
                const freqRange = maxFreqBin - minFreqBin;
                
                for (let i = 0; i < barCount; i++) {
                    // Map bar index to frequency bin within this layer's range
                    const dataIndex = minFreqBin + Math.floor((i / barCount) * freqRange);
                    
                    if (dataIndex >= bufferLength) continue;
                    
                    let value = dataArray[dataIndex];
                    
                    // Calculate bar height with layer-specific multiplier
                    const baseHeight = (value / 255) * (canvas.height * 0.8);
                    const height = baseHeight * layer.heightMultiplier;
                    
                    const x = i * (barWidth + barGap);
                    const y = canvas.height - height;
                    
                    // Create gradient for this bar with layer-specific opacity
                    const gradient = canvasCtx.createLinearGradient(0, y, 0, canvas.height);
                    
                    const r1 = parseInt(accentColor1.slice(1, 3), 16);
                    const g1 = parseInt(accentColor1.slice(3, 5), 16);
                    const b1 = parseInt(accentColor1.slice(5, 7), 16);
                    const r2 = parseInt(accentColor2.slice(1, 3), 16);
                    const g2 = parseInt(accentColor2.slice(3, 5), 16);
                    const b2 = parseInt(accentColor2.slice(5, 7), 16);
                    
                    // Apply layer opacity to gradient
                    gradient.addColorStop(0, `rgba(${r1}, ${g1}, ${b1}, ${layer.opacity * 0.7})`);
                    gradient.addColorStop(1, `rgba(${r2}, ${g2}, ${b2}, ${layer.opacity})`);
                    
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(x, y, barWidth, height);
                    canvasCtx.fillStyle = 'rgba(255, 255, 255, 1)';
                    canvasCtx.fillRect(x, y, barWidth, .5);
                }
            }
        } else if (effectiveMode === 'frequency') {
            // Frequency bar mode (existing code)
            analyserNode.getByteFrequencyData(dataArray);
            
            const barCount = 64;
            const barWidth = (canvas.width / barCount) * 0.8;
            const barGap = (canvas.width / barCount) * 0.2;
            
            if (barHeights.length !== barCount) {
                barHeights = new Array(barCount).fill(0);
                barFallSpeeds = new Array(barCount).fill(0);
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const minFreqBin = Math.floor((minFrequency / nyquist) * bufferLength);
            const maxFreqBin = Math.floor((maxFrequency / nyquist) * bufferLength);
            const freqRange = maxFreqBin - minFreqBin;
            
            // Apply low-frequency taper (below 1000 Hz)
const taperThreshold = 1000;
const taperBin = Math.floor((taperThreshold / nyquist) * bufferLength);

for (let i = 0; i < barCount; i++) {
    const dataIndex = minFreqBin + Math.floor((i / barCount) * freqRange);
    let value = dataArray[dataIndex];
    
    // Apply taper to frequencies below 1000 Hz
    if (dataIndex < taperBin) {
        const taperFactor = dataIndex / taperBin; // 0 to 1
        value *= taperFactor * taperFactor; // Quadratic taper for smooth reduction
    }
    
    const minHeightPixels = (minBarHeight / 100) * canvas.height;
    const maxHeightPixels = (maxBarHeight / 100) * canvas.height;
    const heightRange = maxHeightPixels - minHeightPixels;
    
    const targetHeight = minHeightPixels + (value / 255) * heightRange;
    
    const responseSpeed = 1 / (responseDuration / 16.67);
    
    if (targetHeight > barHeights[i]) {
        barHeights[i] += (targetHeight - barHeights[i]) * responseSpeed * 2;
        barFallSpeeds[i] = 0;
    } else {
        const fallSpeed = responseSpeed * 5.5;
        barHeights[i] = Math.max(targetHeight, barHeights[i] - fallSpeed * 10);
    }
    
const x = i * (barWidth + barGap);
    const height = barHeights[i];
    const y = canvas.height - height;
    
    const gradient = canvasCtx.createLinearGradient(0, y, 0, canvas.height);
    
    const r1 = parseInt(accentColor1.slice(1, 3), 16);
    const g1 = parseInt(accentColor1.slice(3, 5), 16);
    const b1 = parseInt(accentColor1.slice(5, 7), 16);
    const r2 = parseInt(accentColor2.slice(1, 3), 16);
    const g2 = parseInt(accentColor2.slice(3, 5), 16);
    const b2 = parseInt(accentColor2.slice(5, 7), 16);
    
// Calculate opacity and brightness based on bar height if enabled
    let topOpacity, bottomOpacity;
    let r1Final, g1Final, b1Final, r2Final, g2Final, b2Final;
    
    if (opacityByVolume) {
        // Normalize height to 0-1 range
        const normalizedHeight = height / canvas.height;
        
        if (normalizedHeight <= 0.5) {
            // 0-50% volume: opacity goes from 0 to 1
            const opacity = normalizedHeight * 2; // Maps 0-0.5 to 0-1
            topOpacity = opacity;
            bottomOpacity = opacity;
            
            // Use original colors at this stage
            r1Final = r1;
            g1Final = g1;
            b1Final = b1;
            r2Final = r2;
            g2Final = g2;
            b2Final = b2;
        } else {
            // 50-100% volume: full opacity, brightness increases toward brighter version
            topOpacity = 1;
            bottomOpacity = 1;
            
            // Calculate brightness factor: 0 at 50% volume, 1 at 100% volume
            const brightnessFactor = (normalizedHeight - 0.5) * 2; // Maps 0.5-1 to 0-1
            
            // Calculate target brightness: increase each RGB component toward max
            // while maintaining color hue by scaling proportionally
            const brightnessBoost = 2.5; // Multiplier for brightness increase
            
            // Apply brightness boost while clamping to 255
            r1Final = Math.min(255, Math.round(r1 + (r1 * brightnessBoost - r1) * brightnessFactor));
            g1Final = Math.min(255, Math.round(g1 + (g1 * brightnessBoost - g1) * brightnessFactor));
            b1Final = Math.min(255, Math.round(b1 + (b1 * brightnessBoost - b1) * brightnessFactor));
            r2Final = Math.min(255, Math.round(r2 + (r2 * brightnessBoost - r2) * brightnessFactor));
            g2Final = Math.min(255, Math.round(g2 + (g2 * brightnessBoost - g2) * brightnessFactor));
            b2Final = Math.min(255, Math.round(b2 + (b2 * brightnessBoost - b2) * brightnessFactor));
        }
    } else {
        // Default opacity and colors
        topOpacity = 1;
        bottomOpacity = 1;
        r1Final = r1;
        g1Final = g1;
        b1Final = b1;
        r2Final = r2;
        g2Final = g2;
        b2Final = b2;
    }
    
    gradient.addColorStop(0, `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${topOpacity})`);
    gradient.addColorStop(1, `rgba(${r2Final}, ${g2Final}, ${b2Final}, ${bottomOpacity})`);
    
    canvasCtx.fillStyle = gradient;
    canvasCtx.fillRect(x, y, barWidth, height);
}
        } else if (effectiveMode === 'particles') {
    // Particles mode
    analyserNode.getByteFrequencyData(dataArray);
    
    const nyquist = audioContext.sampleRate / 2;
    
    // Adjust frequency ranges - start at 1500 Hz for bass, focus on higher frequencies
    const bassMinFreq = 1000; // Start higher to avoid the low-end clutter
    const bassMaxFreq = 2000;
    const midMinFreq = 2000;
    const midMaxFreq = 6000;
    const highMinFreq = 6000;
    const highMaxFreq = 16000;
    
// Convert Hz to FFT bin index
    const sampleRate = audioContext.sampleRate;
    const hzToBin = (hz) => Math.round(hz / (sampleRate / 2) * bufferLength);
    
    // Define frequency ranges in Hz
    const bassRange = { start: 0, end: hzToBin(300) }; // 0-300 Hz (sub-bass)
    const lowMidRange = { start: hzToBin(300), end: hzToBin(1000) }; // 300-1000 Hz (low-mid)
    const midRange = { start: hzToBin(1000), end: hzToBin(3000) }; // 1000-3000 Hz (mid)
    const highRange = { start: hzToBin(3000), end: hzToBin(6000) }; // 3000-6000 Hz (high)
    const veryHighRange = { start: hzToBin(6000), end: hzToBin(10000) }; // 6000-10000 Hz (very high)
    
    let bassPeak = 0;
    let lowMidPeak = 0;
    let midPeak = 0;
    let highPeak = 0;
    let veryHighPeak = 0;
    
    for (let i = bassRange.start; i < bassRange.end; i++) {
        if (dataArray[i] > bassPeak) bassPeak = dataArray[i];
    }
    
    for (let i = lowMidRange.start; i < lowMidRange.end; i++) {
        if (dataArray[i] > lowMidPeak) lowMidPeak = dataArray[i];
    }
    
    for (let i = midRange.start; i < midRange.end; i++) {
        if (dataArray[i] > midPeak) midPeak = dataArray[i];
    }
    
    for (let i = highRange.start; i < highRange.end; i++) {
        if (dataArray[i] > highPeak) highPeak = dataArray[i];
    }
    
    for (let i = veryHighRange.start; i < veryHighRange.end; i++) {
        if (dataArray[i] > veryHighPeak) veryHighPeak = dataArray[i];
    }
    
    const currentTime = Date.now();
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    const lighterColor = getLighterColor(accentColor1, accentColor2);
    const darkerColor = getDarkerColor(accentColor1, accentColor2);
    
// Update energy history for each frequency range
    energyHistory.bass.push(bassPeak);
    if (energyHistory.bass.length > historyLength) energyHistory.bass.shift();
    
    energyHistory.lowMid.push(lowMidPeak);
    if (energyHistory.lowMid.length > historyLength) energyHistory.lowMid.shift();
    
    energyHistory.mid.push(midPeak);
    if (energyHistory.mid.length > historyLength) energyHistory.mid.shift();
    
    energyHistory.high.push(highPeak);
    if (energyHistory.high.length > historyLength) energyHistory.high.shift();
    
    energyHistory.veryHigh.push(veryHighPeak);
    if (energyHistory.veryHigh.length > historyLength) energyHistory.veryHigh.shift();
    
    // Calculate average energy over recent frames
    const avgBassEnergy = getAverageEnergy(energyHistory.bass);
    const avgLowMidEnergy = getAverageEnergy(energyHistory.lowMid);
    const avgMidEnergy = getAverageEnergy(energyHistory.mid);
    const avgHighEnergy = getAverageEnergy(energyHistory.high);
    const avgVeryHighEnergy = getAverageEnergy(energyHistory.veryHigh);
    
    // Calculate how much energy increased from average
    const bassIncrease = bassPeak - avgBassEnergy;
    const lowMidIncrease = lowMidPeak - avgLowMidEnergy;
    const midIncrease = midPeak - avgMidEnergy;
    const highIncrease = highPeak - avgHighEnergy;
    const veryHighIncrease = veryHighPeak - avgVeryHighEnergy;
    
// Different thresholds for each frequency range
    const bassThreshold = peakThreshold * .8;
    const lowMidThreshold = peakThreshold * 0.8;
    const midThreshold = peakThreshold * 0.7;
    const highThreshold = peakThreshold * 0.6;
    const veryHighThreshold = peakThreshold * 0.5;

    // Low-Mid particles (300-1000 Hz) - VERY LARGE, mostly transparent
    if (lowMidPeak > lowMidThreshold && 
        lowMidIncrease > attackThreshold * 0.9 && 
        currentTime - lastPeakTime.lowMid > peakCooldown * 0.9) {
        
        lastPeakTime.lowMid = currentTime;
        
        // Create few but HUGE transparent particles
        const numParticles = Math.round((6 + Math.floor(Math.random() * 2)) * particleBurstMultiplier);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const size = 40 + Math.random() * 20; // 40-60px - HUGE
            const speed = (1.0 + Math.random() * 0.5) * particleSpeed; // VERY SLOW
            const opacity = 0.15 + (lowMidPeak / 255) * 0.15; // 0.15-0.30 - VERY TRANSPARENT
            
            const offsetX = (Math.random() - 0.5) * 2 * particleSpread;
            const offsetY = (Math.random() - 0.5) * 2 * particleSpread;
            particles.push(new Particle(centerX + offsetX, centerY + offsetY, size, speed, angle, opacity, darkerColor));
        }
    }
    
    // Bass particles - trigger on sudden energy increase (transient/attack)
    if (bassPeak > bassThreshold && 
        bassIncrease > attackThreshold && 
        currentTime - lastPeakTime.bass > peakCooldown) {
        
        lastPeakTime.bass = currentTime;
        
        // Create large bass particles
                const numParticles = Math.round((12 + Math.floor(Math.random() * 2)) * particleBurstMultiplier);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const size = 10;
            const speed = (2.5 + Math.random() * 0.7) * particleSpeed;
            const opacity = 1 + (bassPeak / 255) * 0.25;
            
            const offsetX = (Math.random() - 0.5) * 2 * particleSpread;
            const offsetY = (Math.random() - 0.5) * 2 * particleSpread;
            particles.push(new Particle(centerX + offsetX, centerY + offsetY, size, speed, angle, opacity, darkerColor));
        }
    }
    
    // Mid particles - trigger on sudden energy increase
    if (midPeak > midThreshold && 
        midIncrease > attackThreshold * 0.8 && 
        currentTime - lastPeakTime.mid > peakCooldown * 1.1) {
        
        lastPeakTime.mid = currentTime;
        
        // Create medium particles
                const numParticles = Math.round((18 + Math.floor(Math.random() * 2)) * particleBurstMultiplier);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const size = 20;
            const speed = (2.5 + Math.random() * 1.0) * particleSpeed;
            const opacity = 1 + (midPeak / 255) * 0.35;
            
            // Mix of both colors
            const r1 = parseInt(darkerColor.slice(1, 3), 16);
            const g1 = parseInt(darkerColor.slice(3, 5), 16);
            const b1 = parseInt(darkerColor.slice(5, 7), 16);
            const r2 = parseInt(lighterColor.slice(1, 3), 16);
            const g2 = parseInt(lighterColor.slice(3, 5), 16);
            const b2 = parseInt(lighterColor.slice(5, 7), 16);
            
            const r = Math.round(r1 * 0.6 + r2 * 0.4);
            const g = Math.round(g1 * 0.6 + g2 * 0.4);
            const b = Math.round(b1 * 0.6 + b2 * 0.4);
            const midColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            
            const offsetX = (Math.random() - 0.5) * 2 * particleSpread;
            const offsetY = (Math.random() - 0.5) * 2 * particleSpread;
            particles.push(new Particle(centerX + offsetX, centerY + offsetY, size, speed, angle, opacity, midColor));
        }
    }
    
    // High particles - trigger on sudden energy increase (like snare hits!)
    if (highPeak > highThreshold && 
        highIncrease > attackThreshold * 0.6 && 
        currentTime - lastPeakTime.high > peakCooldown * 1.25) {
        
        lastPeakTime.high = currentTime;
        
        // Create many small bright particles - BURST effect
                const numParticles = Math.round((24 + Math.floor(Math.random() * 2)) * particleBurstMultiplier);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const size = 5 + (highPeak / 255) * 2;
            const speed = (2.5 + Math.random() * 2.0) * particleSpeed;
            const opacity = 1 + (highPeak / 255) * 0.3;
            
            const offsetX = (Math.random() - 0.5) * 2 * particleSpread;
            const offsetY = (Math.random() - 0.5) * 2 * particleSpread;
            particles.push(new Particle(centerX + offsetX, centerY + offsetY, size, speed, angle, opacity, lighterColor));
        }
    }

    // Very High particles (6000-10000 Hz) - MANY tiny particles like fine dust
    if (veryHighPeak > veryHighThreshold && 
        veryHighIncrease > attackThreshold * 0.5 && 
        currentTime - lastPeakTime.veryHigh > peakCooldown * 1.5) {
        
        lastPeakTime.veryHigh = currentTime;
        
        // Create MANY tiny particles - like a fine mist
                const numParticles = Math.round((30 + Math.floor(Math.random() * 2)) * particleBurstMultiplier);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const size = 1 + Math.random() * 2; // 1-3px - TINY
            const speed = (3.0 + Math.random() * 3.0) * particleSpeed; // 3.0-6.0 - VERY FAST
            const opacity = 0.6 + (veryHighPeak / 255) * 0.4; // 0.6-1.0 - BRIGHT
            
            const offsetX = (Math.random() - 0.5) * 2 * particleSpread;
            const offsetY = (Math.random() - 0.5) * 2 * particleSpread;
            particles.push(new Particle(centerX + offsetX, centerY + offsetY, size, speed, angle, opacity, lighterColor));
        }
    }
    for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.update();
        particle.draw(canvasCtx);
        
        // Remove dead particles
        if (particle.isDead()) {
            particles.splice(i, 1);
        }
    }
    
    // Draw subtle center indicator
    canvasCtx.save();
    canvasCtx.globalAlpha = 0.2;
    canvasCtx.strokeStyle = lighterColor;
    canvasCtx.lineWidth = 1;
    canvasCtx.beginPath();
    canvasCtx.arc(centerX, centerY, 4, 0, Math.PI * 2);
    canvasCtx.stroke();
    canvasCtx.restore();
} else if (effectiveMode === 'radial') {
    // Radial frequency mode
    analyserNode.getByteFrequencyData(dataArray);
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const maxRadius = canvas.width / 2 - 10;
    const innerRadius = maxRadius * (radialInnerRadius / 100);
    
    const barCount = 64;
    const angleStep = (Math.PI * 2) / barCount;
    
    if (radialBarHeights.length !== barCount) {
        radialBarHeights = new Array(barCount).fill(0);
        radialBarFallSpeeds = new Array(barCount).fill(0);
    }
    
    const nyquist = audioContext.sampleRate / 2;
    const radialMinFreq = 1000; // Custom min frequency for radial
    const radialMaxFreq = 14000; // Custom max frequency for radial
    const minFreqBin = Math.floor((radialMinFreq / nyquist) * bufferLength);
    const maxFreqBin = Math.floor((radialMaxFreq / nyquist) * bufferLength);
    const freqRange = maxFreqBin - minFreqBin;
    
    // Update rotation
    radialRotation += radialRotationSpeed * 0.02; // Convert to radians
    
    // Apply low-frequency taper
    const taperThreshold = 2000;
    const taperBin = Math.floor((taperThreshold / nyquist) * bufferLength);
    
    for (let i = 0; i < barCount; i++) {
        const dataIndex = minFreqBin + Math.floor((i / barCount) * freqRange);
        let value = dataArray[dataIndex];
        
        // Apply taper to frequencies below 2000 Hz
        if (dataIndex < taperBin) {
            const taperFactor = dataIndex / taperBin;
            value *= taperFactor * taperFactor;
        }
        
        const minHeightPixels = (minBarHeight / 100) * (maxRadius - innerRadius);
        const maxHeightPixels = (maxBarHeight / 100) * (maxRadius - innerRadius);
        const heightRange = maxHeightPixels - minHeightPixels;
        
        const targetHeight = minHeightPixels + (value / 255) * heightRange;
        
        const responseSpeed = 1 / (responseDuration / 16.67);
        
        if (targetHeight > radialBarHeights[i]) {
            radialBarHeights[i] += (targetHeight - radialBarHeights[i]) * responseSpeed * 2;
            radialBarFallSpeeds[i] = 0;
        } else {
            const fallSpeed = responseSpeed * 5.5;
            radialBarHeights[i] = Math.max(targetHeight, radialBarHeights[i] - fallSpeed * 10);
        }
    }
    canvasCtx.lineCap = 'round';
    // Draw bars
    for (let i = 0; i < barCount; i++) {
        const angle = i * angleStep + radialRotation;
        const barHeight = radialBarHeights[i];
        
        // Calculate positions
        const startRadius = innerRadius;
        const endRadius = innerRadius + barHeight;
        
        const startX = centerX + Math.cos(angle) * startRadius;
        const startY = centerY + Math.sin(angle) * startRadius;
        const endX = centerX + Math.cos(angle) * endRadius;
        const endY = centerY + Math.sin(angle) * endRadius;
        
        // Create gradient
        const gradient = canvasCtx.createLinearGradient(startX, startY, endX, endY);
        
        const r1 = parseInt(accentColor1.slice(1, 3), 16);
        const g1 = parseInt(accentColor1.slice(3, 5), 16);
        const b1 = parseInt(accentColor1.slice(5, 7), 16);
        const r2 = parseInt(accentColor2.slice(1, 3), 16);
        const g2 = parseInt(accentColor2.slice(3, 5), 16);
        const b2 = parseInt(accentColor2.slice(5, 7), 16);
        
        // Calculate opacity and brightness based on bar height if pulse mode is enabled
        let topOpacity, bottomOpacity;
        let r1Final, g1Final, b1Final, r2Final, g2Final, b2Final;
        
        if (opacityByVolume) {
            // Normalize height to 0-1 range
            const normalizedHeight = barHeight / (maxRadius - innerRadius);
            
            if (normalizedHeight <= 0.5) {
                // 0-50% volume: opacity goes from 0 to 1
                const opacity = normalizedHeight * 2; // Maps 0-0.5 to 0-1
                topOpacity = opacity;
                bottomOpacity = opacity;
                
                // Use original colors at this stage
                r1Final = r1;
                g1Final = g1;
                b1Final = b1;
                r2Final = r2;
                g2Final = g2;
                b2Final = b2;
            } else {
                // 50-100% volume: full opacity, brightness increases
                topOpacity = 1;
                bottomOpacity = 1;
                
                // Calculate brightness factor: 0 at 50% volume, 1 at 100% volume
                const brightnessFactor = (normalizedHeight - 0.5) * 2; // Maps 0.5-1 to 0-1
                
                // Brightness boost
                const brightnessBoost = 2.5;
                
                // Apply brightness boost while clamping to 255
                r1Final = Math.min(255, Math.round(r1 + (r1 * brightnessBoost - r1) * brightnessFactor));
                g1Final = Math.min(255, Math.round(g1 + (g1 * brightnessBoost - g1) * brightnessFactor));
                b1Final = Math.min(255, Math.round(b1 + (b1 * brightnessBoost - b1) * brightnessFactor));
                r2Final = Math.min(255, Math.round(r2 + (r2 * brightnessBoost - r2) * brightnessFactor));
                g2Final = Math.min(255, Math.round(g2 + (g2 * brightnessBoost - g2) * brightnessFactor));
                b2Final = Math.min(255, Math.round(b2 + (b2 * brightnessBoost - b2) * brightnessFactor));
            }
        } else {
            // Pulse mode disabled - full opacity and original colors
            topOpacity = 1;
            bottomOpacity = 1;
            r1Final = r1;
            g1Final = g1;
            b1Final = b1;
            r2Final = r2;
            g2Final = g2;
            b2Final = b2;
        }
        
        gradient.addColorStop(0, `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${topOpacity})`);
        gradient.addColorStop(1, `rgba(${r2Final}, ${g2Final}, ${b2Final}, ${bottomOpacity})`);
        
        canvasCtx.strokeStyle = gradient;
        canvasCtx.lineWidth = canvas.width / 125;
        canvasCtx.beginPath();
        canvasCtx.moveTo(startX, startY);
        canvasCtx.lineTo(endX, endY);
        canvasCtx.stroke();
        
        // Draw mirror bars (inward) if enabled
        if (radialMirrorMode) {
            const mirrorEndRadius = innerRadius - barHeight;
            const mirrorEndX = centerX + Math.cos(angle) * Math.max(0, mirrorEndRadius);
            const mirrorEndY = centerY + Math.sin(angle) * Math.max(0, mirrorEndRadius);
            
            const mirrorGradient = canvasCtx.createLinearGradient(startX, startY, mirrorEndX, mirrorEndY);
            mirrorGradient.addColorStop(0, `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${topOpacity * 0.6})`);
            mirrorGradient.addColorStop(1, `rgba(${r2Final}, ${g2Final}, ${b2Final}, ${bottomOpacity * 0.6})`);
            
            canvasCtx.strokeStyle = mirrorGradient;
            canvasCtx.beginPath();
            canvasCtx.moveTo(startX, startY);
            canvasCtx.lineTo(mirrorEndX, mirrorEndY);
            canvasCtx.stroke();
        }
    }
    
    // Draw center circle
    canvasCtx.save();
    canvasCtx.strokeStyle = accentColor1;
    canvasCtx.lineWidth = 2;
    canvasCtx.globalAlpha = 0.5;
    canvasCtx.beginPath();
    canvasCtx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
    canvasCtx.stroke();
    canvasCtx.restore();
} else if (effectiveMode === 'helix') {
    // DNA Helix mode - two spiraling waveforms
    analyserNode.getByteTimeDomainData(waveformData); // Use time domain for waveform
    
    const centerY = canvas.height / 2;
    const amplitude = canvas.height * 0.3; // Maximum wave height
    const numPoints = canvas.width;
    
    // Initialize smoothing arrays if needed
    if (helixSmoothedWaveform.length !== numPoints) {
        helixSmoothedWaveform = new Array(numPoints).fill(0);
        helixSmoothedFrequency = new Array(numPoints).fill(0);
    }
    
    // Update rotation
    helixRotation += helixSpeed * 0.02;
    
    // Parse colors
    const r1 = parseInt(accentColor1.slice(1, 3), 16);
    const g1 = parseInt(accentColor1.slice(3, 5), 16);
    const b1 = parseInt(accentColor1.slice(5, 7), 16);
    const r2 = parseInt(accentColor2.slice(1, 3), 16);
    const g2 = parseInt(accentColor2.slice(3, 5), 16);
    const b2 = parseInt(accentColor2.slice(5, 7), 16);
    
    // Calculate average amplitude for pulse effect
    let avgAmplitude = 0;
    for (let i = 0; i < waveformData.length; i++) {
        avgAmplitude += Math.abs((waveformData[i] - 128) / 32);
    }
    avgAmplitude /= waveformData.length;
    
    // Calculate opacity and brightness based on pulse mode
    let opacity1, opacity2;
    let r1Final, g1Final, b1Final, r2Final, g2Final, b2Final;
    
    if (opacityByVolume) {
        if (avgAmplitude <= 0.8) {
            // 0-50% volume: opacity goes from 0 to 1
            const opacity = avgAmplitude * 2;
            opacity1 = opacity;
            opacity2 = opacity;
            
            r1Final = r1;
            g1Final = g1;
            b1Final = b1;
            r2Final = r2;
            g2Final = g2;
            b2Final = b2;
        } else {
            // 50-100% volume: full opacity, brightness increases
            opacity1 = 1;
            opacity2 = 1;
            
            const brightnessFactor = (avgAmplitude - 0.5) * 2;
            const brightnessBoost = 2.5;
            
            r1Final = Math.min(255, Math.round(r1 + (r1 * brightnessBoost - r1) * brightnessFactor));
            g1Final = Math.min(255, Math.round(g1 + (g1 * brightnessBoost - g1) * brightnessFactor));
            b1Final = Math.min(255, Math.round(b1 + (b1 * brightnessBoost - b1) * brightnessFactor));
            r2Final = Math.min(255, Math.round(r2 + (r2 * brightnessBoost - r2) * brightnessFactor));
            g2Final = Math.min(255, Math.round(g2 + (g2 * brightnessBoost - g2) * brightnessFactor));
            b2Final = Math.min(255, Math.round(b2 + (b2 * brightnessBoost - b2) * brightnessFactor));
        }
    } else {
        opacity1 = 1;
        opacity2 = 1;
        r1Final = r1;
        g1Final = g1;
        b1Final = b1;
        r2Final = r2;
        g2Final = g2;
        b2Final = b2;
    }
    
    // Sample and smooth the data
    for (let x = 0; x < numPoints; x++) {
        const dataIndex = Math.floor((x / numPoints) * waveformData.length);
        const rawWaveValue = (waveformData[dataIndex] - 128) / 32;
        
        // Apply exponential smoothing
        helixSmoothedWaveform[x] = helixSmoothedWaveform[x] * helixSmoothingFactor + rawWaveValue * (1 - helixSmoothingFactor);
        // Both waves use the same waveform data now
        helixSmoothedFrequency[x] = helixSmoothedWaveform[x];
    }
    
// Draw first helix (waveform-based, positive direction)
    canvasCtx.beginPath();
    canvasCtx.lineWidth = helixThickness;
    canvasCtx.strokeStyle = `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${opacity1})`;
    
    // Calculate points with step size for smoother curves
    const points1 = [];
    const step = 3; // Sample every 3 pixels for smoother interpolation
    for (let x = 0; x < numPoints; x += step) {
        const waveValue = helixSmoothedWaveform[x];
        const spiralPhase = (x / numPoints) * Math.PI * 2 * helixTightness + helixRotation;
        const spiralOffset = Math.sin(spiralPhase) * amplitude * 0.5;
        const y = centerY + spiralOffset + (waveValue * amplitude * 0.5);
        points1.push({ x, y });
    }
    
    // Draw smooth Catmull-Rom spline through points
    if (points1.length > 0) {
        canvasCtx.moveTo(points1[0].x, points1[0].y);
        
        for (let i = 0; i < points1.length - 1; i++) {
            const p0 = points1[Math.max(0, i - 1)];
            const p1 = points1[i];
            const p2 = points1[i + 1];
            const p3 = points1[Math.min(points1.length - 1, i + 2)];
            
            // Calculate control points for smoother curve
            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;
            
            canvasCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }
    }
    canvasCtx.stroke();
    
// Draw second helix (waveform-based, NEGATIVE direction, phase-shifted)
    canvasCtx.beginPath();
    canvasCtx.strokeStyle = `rgba(${r2Final}, ${g2Final}, ${b2Final}, ${opacity2})`;
    
    // Calculate points with step size for smoother curves
    const points2 = [];
    const step2 = 3; // Sample every 3 pixels for smoother interpolation
    for (let x = 0; x < numPoints; x += step2) {
        const waveValue = helixSmoothedFrequency[x];
        const spiralPhase = (x / numPoints) * Math.PI * 2 * helixTightness + helixRotation + Math.PI;
        const spiralOffset = Math.sin(spiralPhase) * amplitude * 0.5;
        const y = centerY + spiralOffset - (waveValue * amplitude * 0.5);
        points2.push({ x, y });
    }
    
    // Draw smooth Catmull-Rom spline through points
    if (points2.length > 0) {
        canvasCtx.moveTo(points2[0].x, points2[0].y);
        
        for (let i = 0; i < points2.length - 1; i++) {
            const p0 = points2[Math.max(0, i - 1)];
            const p1 = points2[i];
            const p2 = points2[i + 1];
            const p3 = points2[Math.min(points2.length - 1, i + 2)];
            
            // Calculate control points for smoother curve
            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;
            
            canvasCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }
    }
    canvasCtx.stroke();
    
    // Draw connecting lines between the helices (like DNA base pairs)
    const connectionSpacing = 10; // Draw connection every X pixels
    canvasCtx.strokeStyle = `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${opacity1 * 0.2})`;
    canvasCtx.lineWidth = 1;
    
    for (let x = 0; x < numPoints; x += connectionSpacing) {
        // Calculate positions for both helices at this x
        const waveValue = helixSmoothedWaveform[x];
        const spiralPhase1 = (x / numPoints) * Math.PI * 2 * helixTightness + helixRotation;
        const spiralOffset1 = Math.sin(spiralPhase1) * amplitude * 0.5;
        const y1 = centerY + spiralOffset1 + (waveValue * amplitude * 0.5);
        
        const spiralPhase2 = (x / numPoints) * Math.PI * 2 * helixTightness + helixRotation + Math.PI;
        const spiralOffset2 = Math.sin(spiralPhase2) * amplitude * 0.5;
        const y2 = centerY + spiralOffset2 - (waveValue * amplitude * 0.5);
        
        // Draw connection line
        canvasCtx.beginPath();
        canvasCtx.moveTo(x, y1);
        canvasCtx.lineTo(x, y2);
        canvasCtx.stroke();
    }
    
    // Add glow effect to the helices
    canvasCtx.shadowBlur = 10;
    canvasCtx.shadowColor = `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${opacity1})`;
    
// Redraw first helix with glow
    canvasCtx.beginPath();
    canvasCtx.lineWidth = helixThickness * 0.5;
    canvasCtx.strokeStyle = `rgba(${r1Final}, ${g1Final}, ${b1Final}, ${opacity1})`;
    
    // Reuse points1 from above
    if (points1.length > 0) {
        canvasCtx.moveTo(points1[0].x, points1[0].y);
        
        for (let i = 0; i < points1.length - 1; i++) {
            const p0 = points1[Math.max(0, i - 1)];
            const p1 = points1[i];
            const p2 = points1[i + 1];
            const p3 = points1[Math.min(points1.length - 1, i + 2)];
            
            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;
            
            canvasCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }
    }
    canvasCtx.stroke();
    
    // Change glow color for second helix
    canvasCtx.shadowColor = `rgba(${r2Final}, ${g2Final}, ${b2Final}, ${opacity2})`;
    
// Redraw second helix with glow
    canvasCtx.beginPath();
    canvasCtx.strokeStyle = `rgba(${r2Final}, ${g2Final}, ${b2Final}, ${opacity2})`;
    
    // Reuse points2 from above
    if (points2.length > 0) {
        canvasCtx.moveTo(points2[0].x, points2[0].y);
        
        for (let i = 0; i < points2.length - 1; i++) {
            const p0 = points2[Math.max(0, i - 1)];
            const p1 = points2[i];
            const p2 = points2[i + 1];
            const p3 = points2[Math.min(points2.length - 1, i + 2)];
            
            const cp1x = p1.x + (p2.x - p0.x) / 6;
            const cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6;
            const cp2y = p2.y - (p3.y - p1.y) / 6;
            
            canvasCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }
    }
    canvasCtx.stroke();
    
    // Reset shadow
    canvasCtx.shadowBlur = 0;
}else {
    // Waveform mode - Audacity-style scrolling
    analyserNode.getByteTimeDomainData(waveformData);
    
    // Add new data to buffer
    for (let i = 0; i < bufferLength; i++) {
        waveformBuffer.push(waveformData[i]);
    }
    
    // Adjust buffer size based on slider (zoom level)
    waveformBufferSize = Math.floor(4096 * (waveformSensitivity / 1.0));
    
    // Keep buffer at target size
    while (waveformBuffer.length > waveformBufferSize) {
        waveformBuffer.shift();
    }
    
    // Clear canvas
    canvasCtx.fillStyle = '#0f0f0f';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw center line
    canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    canvasCtx.lineWidth = 1;
    canvasCtx.beginPath();
    canvasCtx.moveTo(0, canvas.height / 2);
    canvasCtx.lineTo(canvas.width, canvas.height / 2);
    canvasCtx.stroke();
    
    // Draw waveform
    if (waveformBuffer.length > 1) {
        const samplesPerPixel = Math.max(1, Math.floor(waveformBuffer.length / canvas.width));
        const centerY = canvas.height / 2;
        
        canvasCtx.beginPath();
        
        for (let x = 0; x < canvas.width; x++) {
            const bufferIndex = Math.floor((x / canvas.width) * waveformBuffer.length);
            
            // Get min and max for this pixel column (like Audacity does)
            let min = 255;
            let max = 0;
            
            for (let s = 0; s < samplesPerPixel && bufferIndex + s < waveformBuffer.length; s++) {
                const value = waveformBuffer[bufferIndex + s];
                min = Math.min(min, value);
                max = Math.max(max, value);
            }
            
            // Convert to screen coordinates
            const yMin = centerY - ((min - 128) / 128) * (canvas.height / 2);
            const yMax = centerY - ((max - 128) / 128) * (canvas.height / 2);
            
            // Draw vertical line for this pixel
            canvasCtx.moveTo(x, yMin);
            canvasCtx.lineTo(x, yMax);
        }
        
        const gradient = canvasCtx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, accentColor1);
        gradient.addColorStop(1, accentColor2);
        canvasCtx.strokeStyle = gradient;
        canvasCtx.lineWidth = 1;
        canvasCtx.stroke();
    }
}
    };
    
    draw();
}

        function stopVisualizer() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            // Clear canvas
            const bgColor = '#0f0f0f';
            canvasCtx.fillStyle = bgColor;
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            barHeights = [];
            barFallSpeeds = [];
        }

function setupAudioSource() {
    // Detect if we're on iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (!isAudioContextSetup && audioContext && !isIOS) {
        // Only use Web Audio API on non-iOS devices
        sourceNode = audioContext.createMediaElementSource(audioPlayer);
        sourceNode.connect(gainNode);
        isAudioContextSetup = true;
        console.log('Web Audio API connected (desktop mode)');
    } else if (isIOS) {
        console.log('iOS detected - using direct audio playback for background compatibility');
        // On iOS, don't use Web Audio API - just play directly
        // This sacrifices normalization but enables background playback
        isAudioContextSetup = true; // Set to true to prevent trying again
    }
}

        // Calculate RMS (Root Mean Square) for loudness
        function calculateRMS() {
            if (!analyserNode) return 0;
            
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            analyserNode.getFloatTimeDomainData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i] * dataArray[i];
            }
            
            return Math.sqrt(sum / bufferLength);
        }

        // Variables for hybrid normalization
        let trackStartTime = 0;
        let initialGainSet = false;
        let rmsHistory = [];
        const INITIAL_ANALYSIS_DURATION = 200; // ms - analyze first 200ms quickly
        const FAST_RESPONSE_DURATION = 2000; // ms - fast response for first 2 seconds

        // Normalize audio levels with hybrid approach
        function normalizeAudio() {
            if (!isNormalized || !gainNode) return;
            
            const rms = calculateRMS();
            if (rms < 0.001) return; // Avoid division by very small numbers
            
            const targetRMS = 0.1; // Target loudness level
            const maxGain = 3.0; // Maximum gain multiplier
            const minGain = 0.3; // Minimum gain multiplier
            const currentTime = Date.now();
            const timeSinceStart = currentTime - trackStartTime;
            
            // Calculate desired gain
            let desiredGain = targetRMS / rms;
            desiredGain = Math.max(minGain, Math.min(maxGain, desiredGain));
            
            // Adaptive smoothing based on how long track has been playing
            let smoothing;
            if (timeSinceStart < INITIAL_ANALYSIS_DURATION) {
                // Very fast initial response - almost instant
                smoothing = 0.8;
                rmsHistory.push(rms);
            } else if (timeSinceStart < FAST_RESPONSE_DURATION) {
                // Fast response in first 2 seconds
                smoothing = 0.3;
            } else {
                // Smooth and stable after 2 seconds
                smoothing = 0.05;
            }
            
            const currentGain = gainNode.gain.value;
            const newGain = currentGain + (desiredGain - currentGain) * smoothing;
            
            gainNode.gain.setValueAtTime(newGain, audioContext.currentTime);
        }

        // Start normalization monitoring with faster initial interval
        let normalizationInterval;
        function startNormalization() {
            if (normalizationInterval) clearInterval(normalizationInterval);
            
            trackStartTime = Date.now();
            initialGainSet = false;
            rmsHistory = [];
            
            if (isNormalized && audioContext) {
                // Start with very fast polling for initial analysis
                let checkCount = 0;
                const fastInterval = 20; // Check every 20ms initially
                const normalInterval = 100; // Then every 100ms
                
                normalizationInterval = setInterval(() => {
                    normalizeAudio();
                    checkCount++;
                    
                    // After initial fast response period, switch to normal interval
                    if (checkCount * fastInterval >= FAST_RESPONSE_DURATION) {
                        clearInterval(normalizationInterval);
                        normalizationInterval = setInterval(normalizeAudio, normalInterval);
                    }
                }, fastInterval);
            }
        }

        function stopNormalization() {
            if (normalizationInterval) {
                clearInterval(normalizationInterval);
                normalizationInterval = null;
            }
        }

        function toggleNormalization() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (isIOS) {
        alert('Audio normalization is not available on iOS to enable background playback.');
        normalizeBtn.classList.remove('active');
        normalizeBtn.style.background = '';
        normalizeBtn.style.color = '';
        return;
    }
    
    initAudioContext();
    isNormalized = !isNormalized;
            
            if (isNormalized) {
                normalizeBtn.classList.add('active');
                normalizeBtn.style.background = currentAccentGradient;
                normalizeBtn.style.color = '#1a1a1a';
                normalizeBtn.style.borderColor = accentColor1;
                if (isPlaying) {
                    startNormalization();
                }
            } else {
                normalizeBtn.classList.remove('active');
                normalizeBtn.style.background = '';
                normalizeBtn.style.color = '';
                normalizeBtn.style.borderColor = accentColor1;
                stopNormalization();
                // Reset gain to 1.0 when disabled
                if (gainNode) {
                    gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
                }
            }
        }

        // Toggle sort order
function toggleSortOrder() {
    sortAscending = !sortAscending;
    const btn = document.getElementById('sortOrderBtn');
    btn.textContent = sortAscending ? 'â†“' : 'â†‘';
    updateAudioFilesList();
}

// Sort files based on current sort settings
function sortFiles(files) {
    const sorted = [...files];
    
    if (sortBy === 'name' || sortBy === 'title') {
    // Sort by title (use identified title if available, otherwise filename)
    sorted.sort((a, b) => {
        const configA = getSongConfig(a.name);
        const configB = getSongConfig(b.name);
        
        // Get title - use identified title if available, otherwise use filename
        const titleA = (configA.identified && configA.title) ? configA.title : a.name;
        const titleB = (configB.identified && configB.title) ? configB.title : b.name;
        
        const titleALower = titleA.toLowerCase();
        const titleBLower = titleB.toLowerCase();
        
        return sortAscending ? titleALower.localeCompare(titleBLower) : titleBLower.localeCompare(titleALower);
    });
} else if (sortBy === 'artist') {
    // Sort by artist (unidentified songs go to bottom)
    sorted.sort((a, b) => {
        const configA = getSongConfig(a.name);
        const configB = getSongConfig(b.name);
        
        const hasArtistA = configA.identified && configA.artist;
        const hasArtistB = configB.identified && configB.artist;
        
        // Unidentified songs (no artist) go to bottom
        if (!hasArtistA && hasArtistB) return 1;  // A to bottom
        if (hasArtistA && !hasArtistB) return -1; // B to bottom
        
        // Both unidentified - sort alphabetically by filename
        if (!hasArtistA && !hasArtistB) {
            return sortAscending ? 
                a.name.toLowerCase().localeCompare(b.name.toLowerCase()) :
                b.name.toLowerCase().localeCompare(a.name.toLowerCase());
        }
        
        // Both have artists - compare artists
        const artistA = configA.artist.toLowerCase();
        const artistB = configB.artist.toLowerCase();
        
        const artistCompare = artistA.localeCompare(artistB);
        
        // If artists are different, sort by artist
        if (artistCompare !== 0) {
            return sortAscending ? artistCompare : -artistCompare;
        }
        
        // Same artist - sort by title as secondary sort
        const titleA = configA.title ? configA.title.toLowerCase() : a.name.toLowerCase();
        const titleB = configB.title ? configB.title.toLowerCase() : b.name.toLowerCase();
        
        return sortAscending ? titleA.localeCompare(titleB) : titleB.localeCompare(titleA);
    });
}else if (sortBy === 'modified') {
        sorted.sort((a, b) => {
            const dateA = a.lastModified || 0;
            const dateB = b.lastModified || 0;
            return sortAscending ? dateA - dateB : dateB - dateA;
        });
    } else if (sortBy === 'size') {
        sorted.sort((a, b) => {
            const sizeA = a.size || 0;
            const sizeB = b.size || 0;
            return sortAscending ? sizeA - sizeB : sizeB - sizeA;
        });
} else if (sortBy === 'album') {
        sorted.sort((a, b) => {
            const configA = getSongConfig(a.name);
            const configB = getSongConfig(b.name);
            
            const albumA = configA.album || '';
            const albumB = configB.album || '';
            
            // Parse track numbers - handle both string and number formats
            let trackA = configA.track;
            let trackB = configB.track;
            
            // Convert track to number if it's a string like "3/12" (track 3 of 12)
            if (typeof trackA === 'string' && trackA.includes('/')) {
                trackA = parseInt(trackA.split('/')[0]);
            } else if (trackA !== null && trackA !== undefined) {
                trackA = parseInt(trackA);
            }
            
            if (typeof trackB === 'string' && trackB.includes('/')) {
                trackB = parseInt(trackB.split('/')[0]);
            } else if (trackB !== null && trackB !== undefined) {
                trackB = parseInt(trackB);
            }
            
            // If track number is missing or invalid, set to very high number
            if (isNaN(trackA) || trackA === null || trackA === undefined) {
                trackA = 999999;
            }
            if (isNaN(trackB) || trackB === null || trackB === undefined) {
                trackB = 999999;
            }
            
            // Songs without albums go to bottom
            if (!albumA && albumB) return 1;
            if (albumA && !albumB) return -1;
            if (!albumA && !albumB) {
                // Both have no album, sort by filename
                return sortAscending ? 
                    a.name.toLowerCase().localeCompare(b.name.toLowerCase()) :
                    b.name.toLowerCase().localeCompare(a.name.toLowerCase());
            }
            
            // Compare albums alphabetically
            const albumCompare = albumA.toLowerCase().localeCompare(albumB.toLowerCase());
            if (albumCompare !== 0) {
                return sortAscending ? albumCompare : -albumCompare;
            }
            
            // Same album - sort by track number
            const trackCompare = trackA - trackB;
            if (trackCompare !== 0) {
                return sortAscending ? trackCompare : -trackCompare;
            }
            
            // Same album and track number (or both missing) - sort by filename as fallback
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
    } else if (sortBy === 'tagCount') {
        sorted.sort((a, b) => {
            const configA = getSongConfig(a.name);
            const configB = getSongConfig(b.name);
            
            const tagCountA = configA.tags ? configA.tags.length : 0;
            const tagCountB = configB.tags ? configB.tags.length : 0;
            
            // Sort by tag count
            const countCompare = tagCountA - tagCountB;
            if (countCompare !== 0) {
                return sortAscending ? countCompare : -countCompare;
            }
            
            // If tag counts are equal, sort alphabetically by filename as fallback
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
    } else if (sortBy === 'locked') {
        sorted.sort((a, b) => {
            const configA = getSongConfig(a.name);
            const configB = getSongConfig(b.name);
            
            const lockedA = configA.tagsLocked === true ? 1 : 0;
            const lockedB = configB.tagsLocked === true ? 1 : 0;
            
            // Sort locked songs first (or last depending on sortAscending)
            const lockedCompare = lockedB - lockedA; // Locked (1) before unlocked (0)
            if (lockedCompare !== 0) {
                return sortAscending ? -lockedCompare : lockedCompare;
            }
            
            // If lock status is equal, sort alphabetically by filename as fallback
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
    } else if (sortBy === 'lastPlayed') {
        sorted.sort((a, b) => {
            const configA = getSongConfig(a.name);
            const configB = getSongConfig(b.name);
            
            const lastPlayedA = configA.lastPlayed ? new Date(configA.lastPlayed).getTime() : 0;
            const lastPlayedB = configB.lastPlayed ? new Date(configB.lastPlayed).getTime() : 0;
            
            // Songs never played (0) go to bottom
            if (lastPlayedA === 0 && lastPlayedB !== 0) return 1;  // A to bottom
            if (lastPlayedA !== 0 && lastPlayedB === 0) return -1; // B to bottom
            
            // Both never played - sort alphabetically by filename
            if (lastPlayedA === 0 && lastPlayedB === 0) {
                return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            }
            
            // Both have been played - sort by date
            const dateCompare = lastPlayedA - lastPlayedB;
            if (dateCompare !== 0) {
                return sortAscending ? dateCompare : -dateCompare;
            }
            
            // If dates are equal, sort alphabetically by filename as fallback
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
    }
    
    return sorted;
}

// Scroll to currently playing song
function scrollToCurrentSong() {
    if (audioFiles.length === 0 || currentIndex < 0) return;
    
    const playlistItems = playlist.querySelectorAll('.playlist-item');
    if (playlistItems[currentIndex]) {
        playlistItems[currentIndex].scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });
    }
}

// Toggle auto-scroll feature
function toggleAutoScroll() {
    autoScrollEnabled = !autoScrollEnabled;
    const btn = document.getElementById('autoScrollToggle');
    
    if (autoScrollEnabled) {
        btn.textContent = 'ðŸ“ Auto-Scroll: ON';
        btn.style.background = '#2a2a2a';
        btn.style.borderColor = getBrighterColor(accentColor1, accentColor2);
        btn.style.color = getBrighterColor(accentColor1, accentColor2);
    } else {
        btn.textContent = 'ðŸ“ Auto-Scroll: OFF';
        btn.style.background = '#1a1a1a';
        btn.style.borderColor = '#3a3a3a';
        btn.style.color = '#666';
    }
}

// Reset speed to 100%
function resetSpeed() {
    speedSlider.value = 100;
    speedValue.textContent = 100;
    audioPlayer.playbackRate = 1.0;
    audioPlayer.preservesPitch = false;
}

async function selectFolder() {
    // Check if File System Access API is supported (Chrome/Edge desktop)
    if ('showDirectoryPicker' in window) {
        try {
            const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
            audioFiles = [];
            fileHandles.clear();
            
            // Load or create configuration file
            await loadOrCreateConfig(dirHandle);
            
            async function loadFilesRecursively(dirHandle, path = '') {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        if (file.type.startsWith('audio/') || file.name.endsWith('.mp3')) {
                            audioFiles.push(file);
                            fileHandles.set(file.name, entry);
                        }
                    } else if (entry.kind === 'directory') {
                        await loadFilesRecursively(entry, path + entry.name + '/');
                    }
                }
            }

            await loadFilesRecursively(dirHandle);

            if (audioFiles.length === 0) {
                playlist.innerHTML = '<div class="empty-state">No audio files found in the selected folder.</div>';
                return;
            }

            originalOrder = sortFiles(audioFiles);
            audioFiles = [...originalOrder];

            await loadMetadataWithCache(dirHandle);
            
            // Check for new songs not in config
            const existingSongs = new Set(Object.keys(songConfig));
            const newSongs = originalOrder.filter(f => !existingSongs.has(f.name));
        

            //startBackgroundIdentification();
   
            // Only rebuild master tags if they weren't already loaded from config
            if (!masterTags || Object.keys(masterTags).length === 0) {
                buildMasterTagsFromConfig();
            } else {
                // Master tags were loaded from config, just recalculate song counts
                // Reset all counts to 0
                // Master tags were loaded from config, just recalculate song counts
// Reset all counts to 0
Object.keys(masterTags).forEach(tagName => {
    masterTags[tagName].songCount = 0;
});

// NEW: Create a Set of loaded filenames for fast lookup
const loadedFilenames = new Set();
originalOrder.forEach(file => loadedFilenames.add(file.name));

// Recount based on ONLY currently loaded songs
Object.keys(songConfig).forEach(filename => {
    // CRITICAL: Skip songs that aren't in the current folder
    if (!loadedFilenames.has(filename)) {
        return; // Skip this song, it's not loaded
    }
    
    const config = songConfig[filename];
    if (config.tags && Array.isArray(config.tags)) {
        config.tags.forEach(tag => {
            if (masterTags[tag]) {
                masterTags[tag].songCount++;
            } else {
                // Tag from song not in masterTags - add it
                console.warn(`Found tag "${tag}" not in masterTags for ${filename}`);
                masterTags[tag] = {
                    category: 'LastFM Tags',
                    songCount: 1
                };
            }
        });
    }
});

                
                
                // Remove tags with 0 songs
                Object.keys(masterTags).forEach(tagName => {
                    if (masterTags[tagName].songCount === 0) {
                        delete masterTags[tagName];
                    }
                });
                
                console.log('Master tags song counts updated. Total tags:', Object.keys(masterTags).length);
            }
            displayPlaylist();
            renderFilterTags();
            restoreFilterModeUI();
            updateWriteEditsStatus();

            console.log('Loaded', audioFiles.length, 'songs');
            console.log('Master tags:', masterTags);

            setTimeout(() => {
                updateAudioFilesList();
                console.log('Applied saved filter tags:', Array.from(selectedFilterTags));
            }, 500);
            
        } catch (err) {
            console.error('Error accessing folder:', err);
        }
    } else {
        // Fallback for mobile/iOS - use file input
        useMobileFileInput();
    }
}

// Run auto-identification manually (from Advanced Controls)
async function startBackgroundIdentification() {
    console.log('Starting manual auto-identification...');
    
    // Get the minimum tag threshold
    const minTagThreshold = parseInt(document.getElementById('autoIdMinTagThreshold').value) || 2;
    
    const unidentifiedSongs = originalOrder.filter(file => {
        const config = getSongConfig(file.name);
        // Only scan if never scanned before (identified property doesn't exist)
        return config.identified === undefined;
    });
    
    if (unidentifiedSongs.length === 0) {
        document.getElementById('autoIdStatus').textContent = 'All songs already identified';
        document.getElementById('autoIdStatus').style.color = '#4CAF50';
        return;
    }
    
    // Disable run button during process
    const runBtn = document.getElementById('autoIdRunBtn');
    runBtn.disabled = true;
    runBtn.textContent = 'Running...';
    
    document.getElementById('autoIdStatus').textContent = `Processing ${unidentifiedSongs.length} songs...`;
    document.getElementById('autoIdStatus').style.color = '#e0e0e0';
    
    console.log(`Auto-identifying ${unidentifiedSongs.length} songs...`);
    
    let identifiedCount = 0;
    let processedCount = 0;
    
    // First pass: collect all tags from identified songs
    const tagCounts = {};
    
    for (const file of unidentifiedSongs) {
        // Use setTimeout to allow UI to remain responsive
        await new Promise(resolve => setTimeout(resolve, 0));
        
        const config = getSongConfig(file.name);
        const updatedConfig = await autoIdentifySong(file.name);
        songConfig[file.name] = updatedConfig;
        
        if (updatedConfig.identified) {
            identifiedCount++;
            
            // Count tag occurrences
            if (updatedConfig.tags && updatedConfig.tags.length > 0) {
                updatedConfig.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            }
        }
        
        processedCount++;
        
        // Update status every 5 songs
        if (processedCount % 5 === 0) {
            document.getElementById('autoIdStatus').textContent = `Processing ${processedCount}/${unidentifiedSongs.length}...`;
        }
        
        // Save progress every 10 songs
        if (processedCount % 10 === 0) {
            await saveConfig();
            console.log(`Progress: ${processedCount}/${unidentifiedSongs.length} processed, ${identifiedCount} identified`);
        }
        
        // Rate limit between requests
        await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    // Second pass: filter tags based on threshold and update master tags
    console.log(`Tag threshold: ${minTagThreshold}. Filtering tags...`);
    document.getElementById('autoIdStatus').textContent = `Filtering tags and updating UI...`;
    
    unidentifiedSongs.forEach(file => {
        const config = songConfig[file.name];
        
        if (config.identified && config.tags && config.tags.length > 0) {
            // Filter tags that don't meet the threshold
            config.tags = config.tags.filter(tag => tagCounts[tag] > minTagThreshold);
            
            // Update master tags with filtered tags
            config.tags.forEach(tag => {
                if (!masterTags[tag]) {
                    masterTags[tag] = {
                        category: 'genre',
                        songCount: 0,
                        color: '#ff6b35',
                        weight: 5
                    };
                }
                masterTags[tag].songCount++;
            });
            
            if (config.tags.length > 0) {
                console.log(`âœ“ Identified: ${config.artist} - ${config.title} | Tags: ${config.tags.join(', ')}`);
            }
        }
    });
    
    // Final save
    await saveConfig();
    
    // NOW update UI - only once at the very end
    updateAudioFilesList();
    renderFilterTags();
    
    // Re-enable button
    runBtn.disabled = false;
    runBtn.textContent = 'Run';
    
    document.getElementById('autoIdStatus').textContent = `âœ“ Complete: ${identifiedCount}/${unidentifiedSongs.length} songs identified`;
    document.getElementById('autoIdStatus').style.color = '#4CAF50';
    
    console.log(`âœ“ Auto-identification complete: ${identifiedCount}/${unidentifiedSongs.length} songs identified`);
}
// Mobile fallback function
function useMobileFileInput() {
    // Create a container for file inputs
    const inputContainer = document.createElement('div');
    inputContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1a1a1a;
        padding: 30px;
        border-radius: 15px;
        border: 2px solid ${accentColor1};
        z-index: 3000;
        max-width: 90%;
    `;
    
    inputContainer.innerHTML = `
        <h3 style="color: ${accentColor1}; margin-bottom: 20px; text-align: center;">Select Files (Mobile Mode)</h3>
        <p style="color: #e0e0e0; margin-bottom: 15px; font-size: 14px;">First, select your config JSON file (optional):</p>
        <button id="selectConfigBtn" style="
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            color: ${accentColor1};
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
        ">Select Config JSON</button>
        <p id="configStatus" style="color: #999; margin-bottom: 15px; font-size: 12px; text-align: center;">No config selected</p>
        <p style="color: #e0e0e0; margin-bottom: 15px; font-size: 14px;">Then, select your music files:</p>
        <p id="loadedSongsCount" style="color: ${accentColor1}; margin-bottom: 10px; font-size: 13px; text-align: center; font-weight: 600;">0 songs loaded</p>
        <button id="selectMusicBtn" style="
            width: 100%;
            padding: 12px;
            background: ${accentColor1};
            color: #1a1a1a;
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
        ">Add Music Files (Batch)</button>
        <p style="color: #999; margin-bottom: 15px; font-size: 11px; text-align: center; font-style: italic;">Tip: Select 200-500 songs at a time, then click "Add More" to load additional batches</p>
        <button id="addMoreBtn" style="
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            color: ${accentColor1};
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 10px;
            display: none;
        ">Add More Songs</button>
        <button id="doneBtn" style="
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            color: ${accentColor1};
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            display: none;
        ">Done Loading</button>
        <button id="cancelBtn" style="
            width: 100%;
            padding: 12px;
            background: transparent;
            color: ${accentColor1};
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        ">Cancel</button>
    `;
    
    document.body.appendChild(inputContainer);
    
    let configLoaded = false;
    let accumulatedFiles = []; // Store files from multiple batches
    
    // Config file selector
    document.getElementById('selectConfigBtn').onclick = () => {
        const configInput = document.createElement('input');
        configInput.type = 'file';
        configInput.accept = '.json';
        
        configInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    const loadedConfig = JSON.parse(text);
                    
                    // Load the config
                    if (loadedConfig.songs) {
                        songConfig = loadedConfig.songs;
                    } else {
                        songConfig = loadedConfig;
                    }
                    
                    if (loadedConfig.songDurations) {
                        songDurations = loadedConfig.songDurations;
                    }
                    
                    if (loadedConfig.masterTags) {
                        Object.keys(PREDEFINED_TAGS).forEach(tagName => {
                            if (!loadedConfig.masterTags[tagName]) {
                                loadedConfig.masterTags[tagName] = {
                                    category: PREDEFINED_TAGS[tagName],
                                    songCount: 0
                                };
                            }
                        });
                        
                        masterTags = loadedConfig.masterTags;
                        tagAliases = loadedConfig.tagAliases || {};
                        blacklistedTags = new Set(loadedConfig.blacklistedTags || []);
                        
                        
                    } else {
                        buildMasterTagsFromConfig();
                    }
                    
                    if (loadedConfig.appSettings) {
                        const settings = loadedConfig.appSettings;
                        
                        if (settings.accentColor1 && settings.accentColor2) {
                            updateAccentColors(settings.accentColor1, settings.accentColor2);
                            document.getElementById('accentColorPicker1').value = settings.accentColor1;
                            document.getElementById('accentColorPicker2').value = settings.accentColor2;
                        }
                        
                        if (settings.volume !== null && settings.volume !== undefined) {
                            volumeSlider.value = settings.volume;
                            volumeValue.textContent = settings.volume;
                            audioPlayer.volume = settings.volume / 100;
                        }
                        
                        if (settings.useSavedSpeed !== null && settings.useSavedSpeed !== undefined) {
                            useSavedSpeed = settings.useSavedSpeed;
                            const checkbox = document.getElementById('useSavedSpeedCheckbox');
                            if (checkbox) checkbox.checked = useSavedSpeed;
                        }
                        
                        if (settings.useSavedFades !== null && settings.useSavedFades !== undefined) {
                            useSavedFades = settings.useSavedFades;
                            const checkbox = document.getElementById('useSavedFadesCheckbox');
                            if (checkbox) checkbox.checked = useSavedFades;
                        }
                        
                        if (settings.prioritizeNewSongs !== null && settings.prioritizeNewSongs !== undefined) {
                            prioritizeNewSongs = settings.prioritizeNewSongs;
                            const checkbox = document.getElementById('prioritizeNewSongsCheckbox');
                            if (checkbox) checkbox.checked = prioritizeNewSongs;
                        }
                        
                        if (settings.selectedFilterTags && Array.isArray(settings.selectedFilterTags)) {
                            selectedFilterTags = new Set(settings.selectedFilterTags);
                        }
                        
                        if (settings.excludedFilterTags && Array.isArray(settings.excludedFilterTags)) {
                            excludedFilterTags = new Set(settings.excludedFilterTags);
                        }
                        
                        if (settings.tagFilterMode) {
                            tagFilterMode = settings.tagFilterMode;
                        }
                        
                        if (settings.tagSelectMode) {
                            tagSelectMode = settings.tagSelectMode;
                        }
                        
                        if (settings.tagMatchMode) {
                            tagMatchMode = settings.tagMatchMode;
                        }
                    }
                    
                    configLoaded = true;
                    document.getElementById('configStatus').textContent = `âœ“ Config loaded: ${file.name}`;
                    document.getElementById('configStatus').style.color = '#4CAF50';
                    
                    console.log('Loaded configuration from JSON:', Object.keys(songConfig).length, 'songs');
                } catch (error) {
                    console.error('Error loading config:', error);
                    document.getElementById('configStatus').textContent = 'âœ— Error loading config';
                    document.getElementById('configStatus').style.color = '#ff3333';
                }
            }
        };
        
        configInput.click();
    };
    
    // Function to handle file selection (can be called multiple times)
    function selectMusicFiles() {
        const musicInput = document.createElement('input');
        musicInput.type = 'file';
        musicInput.multiple = true;
        musicInput.accept = 'audio/*,.mp3,.m4a,.wav,.flac';
        
        musicInput.onchange = async (e) => {
            const files = Array.from(e.target.files);
            
            if (files.length === 0) {
                return;
            }
            
            const validFiles = files.filter(file => 
                file.type.startsWith('audio/') || 
                file.name.match(/\.(mp3|m4a|wav|flac)$/i)
            );
            
            // Add to accumulated files, avoiding duplicates
            validFiles.forEach(file => {
                const isDuplicate = accumulatedFiles.some(f => f.name === file.name && f.size === file.size);
                if (!isDuplicate) {
                    accumulatedFiles.push(file);
                }
            });
            
            // Update counter
            document.getElementById('loadedSongsCount').textContent = `${accumulatedFiles.length} songs loaded`;
            
            // Show the "Add More" and "Done" buttons
            document.getElementById('addMoreBtn').style.display = 'block';
            document.getElementById('doneBtn').style.display = 'block';
            
            console.log(`Added ${validFiles.length} songs. Total: ${accumulatedFiles.length}`);
        };
        
        musicInput.click();
    }
    
    // Initial music file selector
    document.getElementById('selectMusicBtn').onclick = selectMusicFiles;
    
    // Add more songs button
    document.getElementById('addMoreBtn').onclick = selectMusicFiles;
    
    // Done button - finalize loading
    document.getElementById('doneBtn').onclick = () => {
        if (accumulatedFiles.length === 0) {
            alert('No songs loaded yet!');
            return;
        }
        
        audioFiles = accumulatedFiles;
        
        // If no config was loaded, try localStorage as fallback
        if (!configLoaded) {
            loadConfigFromLocalStorage();
        }
        
        // Hide editing features in mobile mode
        hideMobileEditingFeatures();
        
        originalOrder = sortFiles(audioFiles);
        audioFiles = [...originalOrder];
        
        buildMasterTagsFromConfig();
        displayPlaylist();
        renderFilterTags();
        restoreFilterModeUI();
        
        console.log('Loaded', audioFiles.length, 'songs (mobile mode)');
        
        setTimeout(() => {
            updateAudioFilesList();
        }, 500);
        
        // Remove the input container
        document.body.removeChild(inputContainer);
    };
    
    // Cancel button
    document.getElementById('cancelBtn').onclick = () => {
        document.body.removeChild(inputContainer);
    };
}

// Hide editing features when in mobile mode
function hideMobileEditingFeatures() {
    // Hide the entire tagging section
    const taggingSection = document.querySelector('.tagging-section');
    if (taggingSection) {
        taggingSection.style.display = 'none';
    }
    
    // Hide the entire left column (visualizer section and settings)
    const mainContent = document.querySelector('.main-content');
    if (mainContent) {
        const leftColumn = mainContent.querySelector('div[style*="max-width: 35%"]');
        if (leftColumn) {
            leftColumn.style.display = 'none';
        }
        
        // Make the playlist take full width
        const playlistWrapper = mainContent.querySelector('.playlist-wrapper');
        if (playlistWrapper) {
            playlistWrapper.style.width = '100%';
            playlistWrapper.style.maxWidth = '100%';
        }
    }
    
    // Hide ONLY the save speed button (keep the checkbox!)
    const saveSpeedBtn = document.querySelector('.save-speed-btn');
    if (saveSpeedBtn) {
        saveSpeedBtn.style.display = 'none';
    }
    
    // Keep the "Use Saved" checkbox visible
    // (don't hide .speed-save-controls)
    
    // Hide ONLY the save fades button (keep the checkbox!)
    const saveFadesBtn = document.querySelector('.save-fades-btn');
    if (saveFadesBtn) {
        saveFadesBtn.style.display = 'none';
    }
    
    // Keep the "Use Saved" checkbox visible
    // (don't hide .fade-save-controls)
    
    // Hide trim button (but trim settings will still apply automatically)
    const trimBtn = document.querySelector('.trim-btn');
    if (trimBtn) {
        trimBtn.style.display = playerExpanded ? 'block' : 'none';
document.getElementById('songColorPickerWrapper').style.display = playerExpanded ? 'flex' : 'none';
    }
    
    // Hide the last two advanced control items (Merge JSON and Calculate Setlist)
    const settingItems = document.querySelectorAll('.setting-item');
    if (settingItems.length >= 2) {
        // Hide Merge JSON Configs (second to last)
        settingItems[settingItems.length - 2].style.display = 'none';
        // Hide Calculate Setlist Lengths (last)
        settingItems[settingItems.length - 1].style.display = 'none';
    }
    
    // Auto-enable "Use Saved" checkboxes on mobile
    const useSavedSpeedCheckbox = document.getElementById('useSavedSpeedCheckbox');
    if (useSavedSpeedCheckbox) {
        useSavedSpeedCheckbox.checked = true;
        useSavedSpeed = true;
    }
    
    const useSavedFadesCheckbox = document.getElementById('useSavedFadesCheckbox');
    if (useSavedFadesCheckbox) {
        useSavedFadesCheckbox.checked = true;
        useSavedFades = true;
    }
    
    console.log('Mobile editing features hidden - Use Saved options enabled');
}

// Load config from localStorage (mobile fallback)
function loadConfigFromLocalStorage() {
    try {
        const savedConfig = localStorage.getItem('u-groove-config');
        if (savedConfig) {
            const loadedConfig = JSON.parse(savedConfig);
            
            if (loadedConfig.songs) {
                songConfig = loadedConfig.songs;
            } else {
                songConfig = loadedConfig;
            }
            
            if (loadedConfig.masterTags) {
                Object.keys(PREDEFINED_TAGS).forEach(tagName => {
                    if (!loadedConfig.masterTags[tagName]) {
                        loadedConfig.masterTags[tagName] = {
                            category: PREDEFINED_TAGS[tagName],
                            songCount: 0
                        };
                    }
                });
                masterTags = loadedConfig.masterTags;
                tagAliases = loadedConfig.tagAliases || {};
                blacklistedTags = new Set(loadedConfig.blacklistedTags || []);
            } else {
                buildMasterTagsFromConfig();
            }
            
            console.log('Loaded configuration from localStorage');
        }
        
        // Also load mobile-specific settings
        const mobileSettings = localStorage.getItem('u-groove-mobile-settings');
        if (mobileSettings) {
            const settings = JSON.parse(mobileSettings);
            if (settings.appSettings) {
                const s = settings.appSettings;
                
                if (s.selectedFilterTags) selectedFilterTags = new Set(s.selectedFilterTags);
                if (s.excludedFilterTags) excludedFilterTags = new Set(s.excludedFilterTags);
                if (s.tagFilterMode) tagFilterMode = s.tagFilterMode;
                if (s.tagSelectMode) tagSelectMode = s.tagSelectMode;
                if (s.tagMatchMode) tagMatchMode = s.tagMatchMode;
            }
        }
    } catch (error) {
        console.error('Error loading config from localStorage:', error);
        songConfig = {};
    }
}


function displayPlaylist() {
    playlist.innerHTML = '';
    audioFiles.forEach((file, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        
        if (multiSelectMode) {
            item.classList.add('has-checkbox');
            
            // Add checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'playlist-item-checkbox';
            checkbox.checked = selectedSongs.has(file.name);
            checkbox.onclick = (e) => toggleSongSelection(e, file);
            item.appendChild(checkbox);
            
            // Add text span that's clickable for playing
            const textSpan = document.createElement('span');
            const config = getSongConfig(file.name);
if (config.identified && config.artist && config.title) {
    // If sorting by title, show "Title by Artist" format
    // Otherwise, show "Artist - Title" format
    if (sortBy === 'title') {
        textSpan.textContent = `${config.title} by ${config.artist}`;
    } else {
        textSpan.textContent = `${config.artist} - ${config.title}`;
    }
} else {
    textSpan.textContent = file.name;
}
            textSpan.onclick = () => playTrack(index);
            item.appendChild(textSpan);
            
// Create a right-aligned container for checkmark and icon
            const rightContainer = document.createElement('div');
            rightContainer.style.cssText = 'margin-left: auto; display: flex; align-items: center; gap: 4px;';
            
            // Add checkmark if tags are locked
            if (config.tagsLocked) {
                const checkmark = document.createElement('span');
                checkmark.className = 'tags-locked-checkmark';
                checkmark.textContent = 'âœ“';
                rightContainer.appendChild(checkmark);
            }

            // Add identify button if not identified, edit button if identified
            if (!config.identified) {
                const identifyBtn = document.createElement('button');
                identifyBtn.className = 'identify-btn';
                identifyBtn.textContent = 'ðŸ”';
                identifyBtn.title = 'Identify with Last.fm';
                identifyBtn.onclick = (e) => {
                    e.stopPropagation();
                    openLastFMIdentifyModalForSong(file.name);
                };
                rightContainer.appendChild(identifyBtn);
            } else {
                const editBtn = document.createElement('button');
                editBtn.className = 'identify-btn';
                editBtn.textContent = 'âœï¸';
                editBtn.title = 'Edit song info';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    openEditSongModal(file.name);
                };
                rightContainer.appendChild(editBtn);
            }
            
            item.appendChild(rightContainer);
        } else {
            // Create text span for song name
            const textSpan = document.createElement('span');
const config = getSongConfig(file.name);
if (config.identified && config.artist && config.title) {
    // If sorting by title, show "Title by Artist" format
    // Otherwise, show "Artist - Title" format
    if (sortBy === 'title') {
        textSpan.textContent = `${config.title} by ${config.artist}`;
    } else {
        textSpan.textContent = `${config.artist} - ${config.title}`;
    }
} else {
    textSpan.textContent = file.name;
}
            item.appendChild(textSpan);
            item.onclick = () => playTrack(index);
            
// Create a right-aligned container for checkmark and icon
            const rightContainer = document.createElement('div');
            rightContainer.style.cssText = 'margin-left: auto; display: flex; align-items: center; gap: 4px;';
            
            // Add checkmark if tags are locked
            if (config.tagsLocked) {
                const checkmark = document.createElement('span');
                checkmark.className = 'tags-locked-checkmark';
                checkmark.textContent = 'âœ“';
                rightContainer.appendChild(checkmark);
            }

            // Add identify button if not identified, edit button if identified
            if (!config.identified) {
                const identifyBtn = document.createElement('button');
                identifyBtn.className = 'identify-btn';
                identifyBtn.textContent = 'ðŸ”';
                identifyBtn.title = 'Identify with Last.fm';
                identifyBtn.onclick = (e) => {
                    e.stopPropagation();
                    openLastFMIdentifyModalForSong(file.name);
                };
                rightContainer.appendChild(identifyBtn);
            } else {
                const editBtn = document.createElement('button');
                editBtn.className = 'identify-btn';
                editBtn.textContent = 'âœï¸';
                editBtn.title = 'Edit song info';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    openEditSongModal(file.name);
                };
                rightContainer.appendChild(editBtn);
            }
            
            item.appendChild(rightContainer);
        }
        
        playlist.appendChild(item);
    });
    updatePlaylistHighlight();
    updateSongCounter();
}

// Show manual entry form (None of These)
function showManualEntry() {
    // Get the filename without extension
    const filename = songBeingIdentified || '';
    const trackName = filename.replace(/\.[^/.]+$/, ''); // Remove file extension
    
    // Try to parse artist and title from filename
    let artist = '';
    let title = trackName;
    
    // Check for " - " pattern (space-hyphen-space)
    const hyphenIndex = trackName.indexOf(' - ');
    if (hyphenIndex !== -1) {
        // Split on first occurrence of " - "
        artist = trackName.substring(0, hyphenIndex).trim();
        title = trackName.substring(hyphenIndex + 3).trim(); // +3 to skip " - "
    }
    
    showReviewStep(artist, title, []);
}

// Open edit modal for identified song
function openEditSongModal(filename) {
    songBeingIdentified = filename;
    isEditingExistingSong = true; // This is editing existing data, not initial identification
    const config = getSongConfig(filename);
    
    document.getElementById('lastfmIdentifyOverlay').style.display = 'flex';
    document.getElementById('confirmLastFMBtn').disabled = false;
    
    // Clear search input
    document.getElementById('lastfmSearchInput').value = '';
    
    // Show review step with existing data
    showReviewStep(
        config.artist || '',
        config.title || '',
        config.tags || []
    );
}

function updateSongCounter() {
    const counter = document.getElementById('songCounter');
    const count = audioFiles.length;
    
    // Calculate total duration from stored durations
    let totalDuration = 0;
    let songsWithDuration = 0;
    
    audioFiles.forEach(file => {
        if (songDurations[file.name]) {
            const config = getSongConfig(file.name);
            // Use trim duration if available, otherwise full duration
            if (config.trimEnd && config.trimStart !== null) {
                totalDuration += (config.trimEnd - (config.trimStart || 0));
            } else if (config.trimEnd) {
                totalDuration += config.trimEnd;
            } else {
                totalDuration += songDurations[file.name];
            }
            songsWithDuration++;
        }
    });
    
    // Format total duration
    let durationText = '';
    if (songsWithDuration > 0) {
        const hours = Math.floor(totalDuration / 3600);
        const minutes = Math.floor((totalDuration % 3600) / 60);
        
        if (hours > 0) {
            durationText = ` (${hours}h ${minutes}m)`;
        } else if (minutes > 0) {
            durationText = ` (${minutes}m)`;
        } else {
            const seconds = Math.floor(totalDuration);
            durationText = ` (${seconds}s)`;
        }
    }
    
    counter.textContent = `${count} song${count !== 1 ? 's' : ''}${durationText}`;
    
    // Apply accent color to border
    counter.style.borderColor = accentColor1;
}

// Get duration of a song without playing it
async function getSongDuration(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const tempContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
        await tempContext.close();
        return audioBuffer.duration;
    } catch (error) {
        console.error('Error getting duration for', file.name, error);
        return 0;
    }
}

// Load durations for all songs in the library (called once when folder is selected)
function updateDurationStatus() {
    const statusEl = document.getElementById('durationStatus');
    const calculateBtn = document.getElementById('calculateDurationsBtn');
    
    if (!statusEl || !calculateBtn) {
        console.warn('Duration status elements not found');
        return;
    }
    
    if (!originalOrder || originalOrder.length === 0) {
        statusEl.textContent = 'No folder selected';
        calculateBtn.disabled = true;
        return;
    }
    
    const totalSongs = originalOrder.length;
    const calculatedSongs = originalOrder.filter(file => songDurations[file.name]).length;
    
    if (calculatedSongs === 0) {
        statusEl.textContent = 'Not yet calculated';
        statusEl.style.color = '#999';
        calculateBtn.disabled = false;
    } else if (calculatedSongs < totalSongs) {
        statusEl.textContent = `Partially calculated (${calculatedSongs}/${totalSongs} songs)`;
        statusEl.style.color = '#ff8c42';
        calculateBtn.disabled = false;
    } else {
        statusEl.textContent = `âœ“ All ${totalSongs} songs calculated`;
        statusEl.style.color = '#4CAF50';
        calculateBtn.disabled = false;
    }
    
    updateSongCounter();
}

// Manual duration calculation function
async function calculateAllDurations() {
    if (!originalOrder || originalOrder.length === 0) {
        alert('Please select a music folder first');
        return;
    }
    
    const calculateBtn = document.getElementById('calculateDurationsBtn');
    const statusEl = document.getElementById('durationStatus');
    
    // Disable button and show progress
    calculateBtn.disabled = true;
    calculateBtn.textContent = 'Calculating...';
    
    console.log('Starting duration calculation for', originalOrder.length, 'songs...');
    
    let loaded = 0;
    let skipped = 0;
    
    for (const file of originalOrder) {
        // Skip if already calculated
        if (songDurations[file.name]) {
            skipped++;
            continue;
        }
        
        const duration = await getSongDuration(file);
        songDurations[file.name] = duration;
        loaded++;
        
        // Update status every 5 songs
        if (loaded % 5 === 0) {
            statusEl.textContent = `Calculating... ${loaded + skipped}/${originalOrder.length}`;
            updateSongCounter();
        }
    }
    
    console.log(`Finished! Calculated ${loaded} new durations, skipped ${skipped} already calculated`);
    
    // Save to config
    await saveConfig();
    
    // Re-enable button and update status
    calculateBtn.disabled = false;
    calculateBtn.textContent = 'Run';
    updateDurationStatus();
    
}

// Count songs that need to be duplicated
function countSongsNeedingDuplication() {
    let count = 0;
    
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        
        // Skip if already duped
        if (config.duped === true) return;
        
        // Check if song has edits
        const hasSpeedEdit = config.speed !== null && config.speed !== 100;
        const hasTrimStart = config.trimStart !== null && config.trimStart !== 0;
        const hasTrimEnd = config.trimEnd !== null && config.trimEnd !== 0;
        const hasFadeIn = config.FI && config.FI > 0;
        const hasFadeOut = config.FO && config.FO > 0;
        
        if (hasSpeedEdit || hasTrimStart || hasTrimEnd || hasFadeIn || hasFadeOut) {
            count++;
        }
    });
    
    return count;
}

// Update write edits status
function updateWriteEditsStatus() {
    const statusEl = document.getElementById('writeEditsStatus');
    if (!statusEl) {
        console.warn('writeEditsStatus element not found');
        return;
    }
    
    const count = countSongsNeedingDuplication();
    
    if (count === 0) {
        statusEl.textContent = 'No songs with edits found';
        statusEl.style.color = '#999';
    } else {
        statusEl.textContent = `${count} song${count !== 1 ? 's' : ''} will be processed`;
        statusEl.style.color = '#ff6b35';
    }
}

// Process audio with effects
async function processAudioFile(file, config) {
    try {
        // Load the audio file
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        const originalDuration = audioBuffer.duration;
        const sampleRate = audioBuffer.sampleRate;
        const numberOfChannels = audioBuffer.numberOfChannels;
        
        // Calculate new duration based on trim and speed
        const trimStart = config.trimStart || 0;
        const trimEnd = config.trimEnd || originalDuration;
        const trimmedDuration = trimEnd - trimStart;
        const speed = (config.speed || 100) / 100;
        const newDuration = trimmedDuration / speed;
        
        // Create offline context for processing
        const offlineContext = new OfflineAudioContext(
            numberOfChannels,
            Math.ceil(newDuration * sampleRate),
            sampleRate
        );
        
        // Create source
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        source.playbackRate.value = speed;
        
        // Create gain node for fading
        const gainNode = offlineContext.createGain();
        source.connect(gainNode);
        gainNode.connect(offlineContext.destination);
        
        // Apply fade in
        const fadeIn = config.FI || 0;
        if (fadeIn > 0) {
            gainNode.gain.setValueAtTime(0, 0);
            gainNode.gain.linearRampToValueAtTime(1, fadeIn);
        } else {
            gainNode.gain.setValueAtTime(1, 0);
        }
        
        // Apply fade out
        const fadeOut = config.FO || 0;
        if (fadeOut > 0) {
            gainNode.gain.setValueAtTime(1, newDuration - fadeOut);
            gainNode.gain.linearRampToValueAtTime(0, newDuration);
        }
        
        // Start playback from trim start
        source.start(0, trimStart, trimmedDuration);
        
        // Render the audio
        const renderedBuffer = await offlineContext.startRendering();
        
        // Convert to MP3 instead of WAV
        const mp3Blob = await audioBufferToMp3(renderedBuffer);
        
        await audioContext.close();
        
        return mp3Blob;
        
    } catch (error) {
        console.error('Error processing audio:', error);
        throw error;
    }
}

// Convert Float32 to Int16 for MP3 encoding
function convertFloat32ToInt16(buffer) {
    const l = buffer.length;
    const buf = new Int16Array(l);
    for (let i = 0; i < l; i++) {
        const s = Math.max(-1, Math.min(1, buffer[i]));
        buf[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return buf;
}

// Convert AudioBuffer to MP3 blob
async function audioBufferToMp3(buffer, bitrate = 192) {
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const samples = buffer.length;
    
    // Prepare channel data
    const leftChannel = buffer.getChannelData(0);
    const rightChannel = channels > 1 ? buffer.getChannelData(1) : leftChannel;
    
    // Convert to 16-bit PCM
    const leftData = convertFloat32ToInt16(leftChannel);
    const rightData = convertFloat32ToInt16(rightChannel);
    
    // Encode to MP3
    const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
    const mp3Data = [];
    
    const sampleBlockSize = 1152;
    for (let i = 0; i < samples; i += sampleBlockSize) {
        const leftChunk = leftData.subarray(i, i + sampleBlockSize);
        const rightChunk = rightData.subarray(i, i + sampleBlockSize);
        const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
        if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
        }
    }
    
    const mp3buf = mp3encoder.flush();
    if (mp3buf.length > 0) {
        mp3Data.push(mp3buf);
    }
    
    return new Blob(mp3Data, { type: 'audio/mp3' });
}

// Write song edits to copies
async function writeSongEdits() {
    if (!configDirHandle) {
        alert('Please select a music folder first');
        return;
    }
    
    const writeBtn = document.getElementById('writeSongEditsBtn');
    const statusEl = document.getElementById('writeEditsStatus');
    
    // Get songs that need processing
    const songsToProcess = [];
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        
        // Skip if already duped
        if (config.duped === true) return;
        
        // Check if song has edits
        const hasSpeedEdit = config.speed !== null && config.speed !== 100;
        const hasTrimStart = config.trimStart !== null && config.trimStart !== 0;
        const hasTrimEnd = config.trimEnd !== null && config.trimEnd !== 0;
        const hasFadeIn = config.FI && config.FI > 0;
        const hasFadeOut = config.FO && config.FO > 0;
        
        if (hasSpeedEdit || hasTrimStart || hasTrimEnd || hasFadeIn || hasFadeOut) {
            songsToProcess.push({ filename, config });
        }
    });
    
    if (songsToProcess.length === 0) {
        alert('No songs with edits found');
        return;
    }
    
    const confirmed = confirm(`This will process ${songsToProcess.length} song(s). Original files will be moved to an "Original from duped" folder. This may take a while. Continue?`);
    if (!confirmed) return;
    
    // Disable button
    writeBtn.disabled = true;
    writeBtn.textContent = 'Processing...';
    
    try {
        // Create or get "Original from duped" folder
        let originalsFolder;
        try {
            originalsFolder = await configDirHandle.getDirectoryHandle('Original from duped', { create: true });
        } catch (error) {
            console.error('Error creating originals folder:', error);
            alert('Could not create "Original from duped" folder');
            return;
        }
        
        let processed = 0;
        
        for (const { filename, config } of songsToProcess) {
            try {
                statusEl.textContent = `Processing ${processed + 1}/${songsToProcess.length}: ${filename}`;
                
                // Get the original file handle
                const fileHandle = fileHandles.get(filename);
                if (!fileHandle) {
                    console.warn(`File handle not found for ${filename}`);
                    continue;
                }
                
                const file = await fileHandle.getFile();
                
                // Process the audio
                // Process the audio
                const processedBlob = await processAudioFile(file, config);
                
                // Get file extension and create names
                const lastDotIndex = filename.lastIndexOf('.');
                const nameWithoutExt = filename.substring(0, lastDotIndex);
                const ext = filename.substring(lastDotIndex);
                const originalName = `${nameWithoutExt} (original)${ext}`;
                
                // For the processed file, change extension to .wav
                const processedName = `${nameWithoutExt}.mp3`;
                
                // Step 1: Copy original file to "Original from duped" folder with (original) name
                const originalFileHandle = await originalsFolder.getFileHandle(originalName, { create: true });
                const originalWritable = await originalFileHandle.createWritable();
                await originalWritable.write(await file.arrayBuffer());
                await originalWritable.close();
                
                // Step 2: Delete the original file from its location
                // Note: We can't directly delete using File System Access API, so we'll just overwrite
                
                // Step 3: Write the processed file as a new .wav file
                const processedFileHandle = await configDirHandle.getFileHandle(processedName, { create: true });
                const processedWritable = await processedFileHandle.createWritable();
                await processedWritable.write(processedBlob);
                await processedWritable.close();
                
                // Update config for original file in "Original from duped" folder
                // Copy all the original settings so it sounds the same
                updateSongConfig(originalName, {
                    tags: ['Original from duped'],
                    speed: config.speed,
                    trimStart: config.trimStart,
                    trimEnd: config.trimEnd,
                    FI: config.FI,
                    FO: config.FO,
                    heardb4: config.heardb4,
                    duped: false
                });
                
                // Update config for processed file (keep tags, reset edits, mark as duped)
                updateSongConfig(processedName, {
                    tags: config.tags,
                    speed: null,
                    trimStart: null,
                    trimEnd: null,
                    FI: 0,
                    FO: 0,
                    duped: true
                });
                
                // Update the file handle reference
                fileHandles.set(processedName, processedFileHandle);
                
                processed++;
                console.log(`Processed: ${filename} â†’ ${processedName} (original saved as ${originalName})`);
                
            } catch (error) {
                console.error(`Error processing ${filename}:`, error);
            }
        }
        
        // Add "Original from duped" to master tags if not already there
        if (!masterTags['Original from duped']) {
            masterTags['Original from duped'] = {
                category: 'Utility',
                songCount: processed
            };
        } else {
            masterTags['Original from duped'].songCount += processed;
        }
        
        // Save config
        await saveConfig();
        
        // Rebuild master tags
        buildMasterTagsFromConfig();
        
        alert(`Successfully processed ${processed} song(s)! Originals have been moved to "Original from duped" folder. The edited versions have replaced the original files in their original locations.`);
        
        // Update status
        updateWriteEditsStatus();
        
    } catch (error) {
        console.error('Error writing song edits:', error);
        alert('An error occurred while processing songs. Check console for details.');
    } finally {
        writeBtn.disabled = false;
        writeBtn.textContent = 'Write Edits';
    }
}

// Get duration of a song without playing it
async function getSongDuration(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const tempContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
        await tempContext.close();
        return audioBuffer.duration;
    } catch (error) {
        console.error('Error getting duration for', file.name, error);
        return 0;
    }
}

// Load durations for all songs in the current list
async function loadAllSongDurations() {
    console.log('Loading durations for', audioFiles.length, 'songs...');
    
    for (const file of audioFiles) {
        if (!songDurations[file.name]) {
            const duration = await getSongDuration(file);
            songDurations[file.name] = duration;
        }
    }
    
    console.log('Finished loading durations');
    updateSongCounter();
}

function updatePlaylistHighlight() {
    const items = playlist.querySelectorAll('.playlist-item');
    items.forEach((item, index) => {
        item.classList.remove('active', 'playing');
        item.style.background = '';
        item.style.color = '';
        
        // Only highlight if currentIndex is valid and matches
        if (currentIndex !== -1 && index === currentIndex) {
            item.classList.add('active');
            item.style.background = currentAccentGradient;
            item.style.color = '#1a1a1a';
            if (isPlaying) {
                item.classList.add('playing');
            }
        }
    });
}

        // Get fresh file from handle, with retry logic
async function getFreshFileFromHandle(filename, retries = 3) {
    const handle = fileHandles.get(filename);
    if (!handle) return null;
    
    for (let i = 0; i < retries; i++) {
        try {
            const file = await handle.getFile();
            return file;
        } catch (error) {
            console.warn(`Attempt ${i + 1} to get fresh file failed:`, error);
            if (i < retries - 1) {
                await new Promise(resolve => setTimeout(resolve, 200 * (i + 1)));
            }
        }
    }
    
    console.error(`Failed to get fresh file after ${retries} attempts`);
    return null;
}

// Enable background playback and media controls
function setupMediaSession(file) {
    if ('mediaSession' in navigator) {
        const config = getSongConfig(file.name);
        const tagCount = config.tags ? config.tags.length : 0;
        
        navigator.mediaSession.metadata = new MediaMetadata({
            title: file.name,
            artist: tagCount > 0 ? `${tagCount} tag${tagCount !== 1 ? 's' : ''}` : 'U-Groove',
            album: 'U-Groove Player',
            artwork: [
                { src: getFaviconDataUrl(), sizes: '512x512', type: 'image/png' }
            ]
        });
        
        // Set up action handlers for car controls
        navigator.mediaSession.setActionHandler('play', () => {
            audioPlayer.play();
            isPlaying = true;
            playBtn.textContent = 'â¸¨';
            if (document.getElementById('playBtnCompact')) {
                document.getElementById('playBtnCompact').textContent = 'â¸¨';
            }
        });
        
        navigator.mediaSession.setActionHandler('pause', () => {
            audioPlayer.pause();
            isPlaying = false;
            playBtn.textContent = 'â–¶';
            if (document.getElementById('playBtnCompact')) {
                document.getElementById('playBtnCompact').textContent = 'â–¶';
            }
        });
        
        navigator.mediaSession.setActionHandler('previoustrack', () => {
            previousTrack();
        });
        
        navigator.mediaSession.setActionHandler('nexttrack', () => {
            nextTrack();
        });
        
        // Optional: seek handlers for car controls
        navigator.mediaSession.setActionHandler('seekbackward', (details) => {
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - (details.seekOffset || 10));
        });
        
        navigator.mediaSession.setActionHandler('seekforward', (details) => {
            audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + (details.seekOffset || 10));
        });
        
        console.log('Media Session API configured for background playback');
    }
}

// Helper function to get favicon as data URL for media session artwork
function getFaviconDataUrl() {
    // Create a canvas with the U-Groove logo
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // Draw background
    ctx.fillStyle = '#231f20';
    ctx.fillRect(0, 0, 512, 512);
    
    // Draw circle with gradient
    const gradient = ctx.createLinearGradient(0, 0, 512, 512);
    gradient.addColorStop(0, accentColor1);
    gradient.addColorStop(1, accentColor2);
    
    ctx.beginPath();
    ctx.arc(256, 256, 200, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
    
    return canvas.toDataURL('image/png');
}

async function playTrack(index) {
    initAudioContext();

    // ENSURE AUDIO CONTEXT IS RUNNING (important for iOS)
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    
    // Stop any active fades
    stopFades();
    
    hasMarkedAsHeard = false;
    
    currentIndex = index;
    const file = audioFiles[currentIndex];
    currentlyPlayingFile = file;
        // Update colors from tags if enabled
    updateColorsFromCurrentSong(); 
    const url = URL.createObjectURL(file);
    audioPlayer.src = url;
    
    // SETUP MEDIA SESSION FOR BACKGROUND PLAYBACK
    setupMediaSession(file);
    
    // Setup audio source for Web Audio API on first play
    if (!isAudioContextSetup) {
        audioPlayer.addEventListener('loadedmetadata', () => {
            setupAudioSource();
        }, { once: true });
    }
    
    // Brief fade-in to mask initial normalization adjustment
    if (isNormalized && gainNode && audioContext) {
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.05);
    }
    
    audioPlayer.play();
    isPlaying = true;
    playBtn.textContent = 'â¸';
    nowPlaying.textContent = `Now playing: ${file.name}`;

        // Update both now playing displays with tag count
    updateNowPlayingDisplay();
    updatePlaylistHighlight();

     // Get tag count for this song
    const config = getSongConfig(file.name);
    const tagCount = config.tags ? config.tags.length : 0;
    const tagCountText = tagCount > 0 ? ` (${tagCount} tag${tagCount !== 1 ? 's' : ''})` : '';

    updatePlaylistHighlight();
    
    if (isNormalized) {
        startNormalization();
    }

    stopVisualizer();


// If in random mode, pick a new visualizer for this song
if (visualizerMode === 'random') {
    randomVisualizerMode = pickRandomVisualizer();
    console.log('New random visualizer for this song:', randomVisualizerMode);
    
    // Update controls display
    setVisualizerMode('random');
}

    // Start visualizer
    drawVisualizer();
    
    // Load tags for this song
    loadSongTags(file.name);

    // Load saved speed if checkbox is enabled
    if (useSavedSpeed) {
        loadSavedSpeed(file.name);
    }
    
    // Load saved fades if checkbox is enabled
    if (useSavedFades) {
        loadSavedFades(file.name);
    }
    
// Apply trim settings when metadata loads
    audioPlayer.addEventListener('loadedmetadata', () => {
        const config = getSongConfig(file.name);
        if (config.trimStart !== null && config.trimStart !== undefined) {
            audioPlayer.currentTime = config.trimStart;
        }
        
        // Apply fade in when song starts
        if (currentFadeInDuration > 0) {
            applyFadeIn();
        }
    }, { once: true });

    // Update compact player display
    if (collapsedSections.player) {
        updateCompactPlayer();
    }
        if (autoScrollEnabled) {
        scrollToCurrentSong();
    }
}

async function togglePlay() {
    if (audioFiles.length === 0) return;
    
    // Ensure audio context is ready (iOS requirement)
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }

    if (isPlaying) {
        audioPlayer.pause();
        playBtn.textContent = 'â–¶';
        isPlaying = false;
        stopNormalization();
        stopVisualizer();
    } else {
        if (!audioPlayer.src) {
            await playTrack(0);
        } else {
            audioPlayer.play();
            playBtn.textContent = 'â¸';
            isPlaying = true;
            if (isNormalized) {
                startNormalization();
            }
             // Only start if not already running
            if (!animationId) {
                drawVisualizer();
            }
        }
    }
    updatePlaylistHighlight();
}

async function nextTrack() {
    if (audioFiles.length === 0) return;
    
    console.log('nextTrack called');
    
    // Auto-save current speed if "Use Saved" is checked
    if (useSavedSpeed && currentlyPlayingFile) {
        const currentSpeed = parseInt(speedSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.speed !== currentSpeed) {
            updateSongConfig(currentlyPlayingFile.name, { speed: currentSpeed });
            await saveConfig();
        }
    }
    
    // Auto-save current fades if "Use Saved" is checked
    if (useSavedFades && currentlyPlayingFile) {
        const fadeIn = parseInt(fadeInSlider.value);
        const fadeOut = parseInt(fadeOutSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.FI !== fadeIn || config.FO !== fadeOut) {
            updateSongConfig(currentlyPlayingFile.name, { FI: fadeIn, FO: fadeOut });
            await saveConfig();
        }
    }
    
    // If current song is not in list (currentIndex is -1), start from beginning
    if (currentIndex === -1) {
        currentIndex = 0;
    } else {
        // Use the new function to get next index
        const nextIndex = getNextUnheardSongIndex('next');
        console.log('nextTrack will play index:', nextIndex);
        currentIndex = nextIndex;
    }
    
    await playTrack(currentIndex);
}

async function previousTrack() {
    if (audioFiles.length === 0) return;
    
    console.log('previousTrack called');
    
    // Auto-save current speed if "Use Saved" is checked
    if (useSavedSpeed && currentlyPlayingFile) {
        const currentSpeed = parseInt(speedSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.speed !== currentSpeed) {
            updateSongConfig(currentlyPlayingFile.name, { speed: currentSpeed });
            await saveConfig();
        }
    }
    
    // Auto-save current fades if "Use Saved" is checked
    if (useSavedFades && currentlyPlayingFile) {
        const fadeIn = parseInt(fadeInSlider.value);
        const fadeOut = parseInt(fadeOutSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.FI !== fadeIn || config.FO !== fadeOut) {
            updateSongConfig(currentlyPlayingFile.name, { FI: fadeIn, FO: fadeOut });
            await saveConfig();
        }
    }
    
    // If current song is not in list (currentIndex is -1), start from beginning
    if (currentIndex === -1) {
        currentIndex = 0;
    } else {
        // Use the new function to get next index
        const prevIndex = getNextUnheardSongIndex('previous');
        console.log('previousTrack will play index:', prevIndex);
        currentIndex = prevIndex;
    }
    
    await playTrack(currentIndex);
}


function toggleShuffle() {
    if (audioFiles.length === 0) return;
    
    isShuffled = !isShuffled;
    
    if (isShuffled) {
        shuffleBtn.classList.add('active');
        shuffleBtn.style.background = currentAccentGradient;
        shuffleBtn.style.color = '#1a1a1a';
        shuffleBtn.style.borderColor = accentColor1;
    } else {
        shuffleBtn.classList.remove('active');
        shuffleBtn.style.background = '';
        shuffleBtn.style.color = '';
        shuffleBtn.style.borderColor = accentColor1;
    }
    
    updateAudioFilesList();
    saveConfig(); // Save shuffle state
}

        function toggleLoop() {
            isLooping = !isLooping;
            audioPlayer.loop = isLooping;
            if (isLooping) {
                loopBtn.classList.add('active');
                loopBtn.style.background = currentAccentGradient;
                loopBtn.style.color = '#1a1a1a';
                loopBtn.style.borderColor = accentColor1;
            } else {
                loopBtn.classList.remove('active');
                loopBtn.style.background = '';
                loopBtn.style.color = '';
                loopBtn.style.borderColor = accentColor1;
            }
            saveConfig(); // Save loop state
        }

        function seekAudio(event) {
            if (!audioPlayer.src) return;
            
            // Get trim settings for current song
            let trimStart = 0;
            let trimEnd = audioPlayer.duration;
            
            if (audioFiles.length > 0 && currentIndex >= 0) {
                const file = audioFiles[currentIndex];
                const config = getSongConfig(file.name);
                trimStart = config.trimStart || 0;
                trimEnd = config.trimEnd || audioPlayer.duration;
            }
            
            // Calculate position within trim range
            const rect = event.currentTarget.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            const trimmedDuration = trimEnd - trimStart;
            
            // Seek to position within trimmed range
            audioPlayer.currentTime = trimStart + (pos * trimmedDuration);
        }


        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

audioPlayer.addEventListener('timeupdate', () => {
    // Get trim settings for current song
    let trimStart = 0;
    let trimEnd = audioPlayer.duration;
    
    if (audioFiles.length > 0 && currentIndex >= 0) {
        const file = audioFiles[currentIndex];
        const config = getSongConfig(file.name);
        trimStart = config.trimStart || 0;
        trimEnd = config.trimEnd || audioPlayer.duration;
    }
    
    // Calculate progress relative to trim range
    const trimmedDuration = trimEnd - trimStart;
    const currentTimeRelativeToTrim = audioPlayer.currentTime - trimStart;
    const progress = (currentTimeRelativeToTrim / trimmedDuration) * 100;
    
    // Clamp progress between 0-100%
    progressBar.style.width = Math.max(0, Math.min(100, progress)) + '%';
    
    // Display current time relative to trim start
    currentTimeEl.textContent = formatTime(Math.max(0, currentTimeRelativeToTrim));
    
    
    // Check for fade out
    if (currentFadeOutDuration > 0 && !isFadingOut && !isFadingIn) {
        const timeRemaining = audioPlayer.duration - audioPlayer.currentTime;
        if (timeRemaining <= currentFadeOutDuration && timeRemaining > 0) {
            applyFadeOut();
        }
    }
    
    // Check if we've reached the trim end point
    if (audioFiles.length > 0 && currentIndex >= 0) {
        const file = audioFiles[currentIndex];
        const config = getSongConfig(file.name);
        
        if (config.trimEnd !== null && config.trimEnd !== undefined) {
            if (audioPlayer.currentTime >= config.trimEnd) {
                // Trigger next track
                if (!isLooping) {
                    nextTrack();
                } else {
                    audioPlayer.currentTime = config.trimStart || 0;
                }
            }
        }
    }
    
    // Update compact view if collapsed
    if (collapsedSections.player) {
        updateCompactPlayer();
    }
    checkAndMarkAsHeard();
});

        audioPlayer.addEventListener('loadedmetadata', () => {
            // Get trim settings for current song
            let trimStart = 0;
            let trimEnd = audioPlayer.duration;
            
            if (audioFiles.length > 0 && currentIndex >= 0) {
                const file = audioFiles[currentIndex];
                const config = getSongConfig(file.name);
                trimStart = config.trimStart || 0;
                trimEnd = config.trimEnd || audioPlayer.duration;
            }
            
            // Display trimmed duration
            const trimmedDuration = trimEnd - trimStart;
            durationEl.textContent = formatTime(trimmedDuration);
        });

audioPlayer.addEventListener('ended', async () => {
    // Auto-save current speed if "Use Saved" is checked
    if (useSavedSpeed && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        const currentSpeed = parseInt(speedSlider.value);
        const config = getSongConfig(currentFile.name);
        
        if (config.speed !== currentSpeed) {
            updateSongConfig(currentFile.name, { speed: currentSpeed });
            await saveConfig();
            console.log('Auto-saved speed on track end:', currentFile.name, currentSpeed);
        }
    }
    
    // Auto-save current fades if "Use Saved" is checked
    if (useSavedFades && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        const fadeIn = parseInt(fadeInSlider.value);
        const fadeOut = parseInt(fadeOutSlider.value);
        const config = getSongConfig(currentFile.name);
        
        if (config.FI !== fadeIn || config.FO !== fadeOut) {
            updateSongConfig(currentFile.name, { FI: fadeIn, FO: fadeOut });
            await saveConfig();
            console.log('Auto-saved fades on track end:', currentFile.name, fadeIn, fadeOut);
        }
    }
    
    if (!isLooping) {
        await nextTrack();
    }
});

        // Collapse/expand functionality
const collapsedSections = {
    filter: false,
    tagging: false,
    visualizer: false,
    player: false
};

function toggleCollapse(section) {
    collapsedSections[section] = !collapsedSections[section];
    
    if (section === 'filter') {
        const content = document.getElementById('filterContent');
        const btn = document.getElementById('filterCollapseBtn');
        content.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
    } else if (section === 'tagging') {
        const content = document.getElementById('taggingContent');
        const btn = document.getElementById('taggingCollapseBtn');
        content.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
    } else if (section === 'visualizer') {
        const content = document.getElementById('visualizerContent');
        const btn = document.getElementById('visualizerCollapseBtn');
        content.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
    } else if (section === 'player') {
        const playerSection = document.getElementById('playerSection');
        const btn = document.getElementById('playerCollapseBtn');
        playerSection.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
        
        // Update compact view when collapsing
        if (collapsedSections[section]) {
            updateCompactPlayer();
        }
    }
}

// Adjust speed by increment
function adjustSpeed(increment) {
    const currentSpeed = parseInt(speedSlider.value);
    const newSpeed = Math.max(25, Math.min(200, currentSpeed + increment));
    speedSlider.value = newSpeed;
    speedValue.textContent = newSpeed;
    audioPlayer.playbackRate = newSpeed / 100;
    audioPlayer.preservesPitch = false;
}

// Visualizer toggle
function toggleVisualizer() {
    visualizerEnabled = !visualizerEnabled;
    const btn = document.getElementById('visualizerToggleBtn');
    btn.textContent = `Visualizer: ${visualizerEnabled ? 'ON' : 'OFF'}`;
    
    if (!visualizerEnabled) {
        // Clear canvas when disabled
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    }
}

// Set visualizer mode
function setVisualizerMode(mode) {
    visualizerMode = mode;
    
    // If random mode, pick a random visualizer
    if (mode === 'random') {
        randomVisualizerMode = pickRandomVisualizer();
        console.log('Random visualizer selected:', randomVisualizerMode);
    } else {
        randomVisualizerMode = null;
    }
    
    // Update dropdown value
    const dropdown = document.getElementById('visualizerModeSelect');
    if (dropdown) dropdown.value = mode;
    
    // Show/hide appropriate controls
    const frequencyControls = document.getElementById('frequencyControls');
    const waveformControls = document.getElementById('waveformControls');
    const particlesControls = document.getElementById('particlesControls');
    const radialControls = document.getElementById('radialControls');
    const helixControls = document.getElementById('helixControls');
    const pulseCheckbox = document.getElementById('opacityByVolume')?.parentElement;
    
    // Hide all controls first
    frequencyControls.style.display = 'none';
    waveformControls.style.display = 'none';
    if (particlesControls) particlesControls.style.display = 'none';
    if (radialControls) radialControls.style.display = 'none';
    if (helixControls) helixControls.style.display = 'none';
    if (pulseCheckbox) pulseCheckbox.style.display = 'none';
    
    // Determine which mode to use for controls display
    const effectiveMode = mode === 'random' ? randomVisualizerMode : mode;
    
    // Show relevant controls based on effective mode
    if (effectiveMode === 'frequency') {
        frequencyControls.style.display = 'block';
        if (pulseCheckbox) pulseCheckbox.style.display = 'flex';
    } else if (effectiveMode === 'waveform') {
        waveformControls.style.display = 'block';
    } else if (effectiveMode === 'particles') {
        if (particlesControls) particlesControls.style.display = 'block';
        particles = [];
    } else if (effectiveMode === 'radial') {
        if (radialControls) radialControls.style.display = 'block';
        if (pulseCheckbox) pulseCheckbox.style.display = 'flex';
        radialBarHeights = [];
        radialBarFallSpeeds = [];
    } else if (effectiveMode === 'helix') {
        if (helixControls) helixControls.style.display = 'block';
        if (pulseCheckbox) pulseCheckbox.style.display = 'flex';
    }
    saveConfig();
}

// Tag match mode (AND/OR)
function setTagMatchMode(mode) {
    tagMatchMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#tagMatchSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    const activeBtn = mode === 'and' ? buttons[0] : buttons[1];
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // Save config
    saveConfig();
    
    // Re-filter the playlist
    updateAudioFilesList();
}

// Tag select mode (single/multi)
function setTagSelectMode(mode) {
    tagSelectMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#tagSelectSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    const activeBtn = mode === 'single' ? buttons[0] : buttons[1];
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // If switching to single select and multiple tags are selected, keep only the first
    if (mode === 'single' && selectedFilterTags.size > 1) {
        const firstTag = Array.from(selectedFilterTags)[0];
        selectedFilterTags.clear();
        selectedFilterTags.add(firstTag);
        renderFilterTags();
        updateAudioFilesList();
    }
    
    // Save config
    saveConfig();
}

// Tag filter mode (include/exclude)
function setTagFilterMode(mode) {
    tagFilterMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#tagFilterModeSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    const activeBtn = mode === 'include' ? buttons[0] : buttons[1];
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // Save config
    saveConfig();
    
    // Re-render tags to show proper colors
    renderFilterTags();
}

// Randomize filter settings
function randomizeFilters() {
    // First, set select mode to multi
    setTagSelectMode('multi');
    
    // Get all available tags (excluding special tags)
    const allTags = Object.keys(masterTags).filter(tag => 
        tag !== 'DELETE' && tag !== 'Original from duped'
    );
    
    if (allTags.length < 2) {
        alert('Not enough tags available to randomize filters. Please add more tags first.');
        return;
    }
    
    // Keep trying until we get a valid configuration
    let attempts = 0;
    const maxAttempts = 50;
    let validConfigFound = false;
    
    while (!validConfigFound && attempts < maxAttempts) {
        attempts++;
        
        // Clear current selections
        selectedFilterTags.clear();
        excludedFilterTags.clear();
        
        // Randomly decide how many tags to select (2-10)
        const numTags = Math.floor(Math.random() * 9) + 2; // 2 to 10
        
        // Shuffle tags array
        const shuffledTags = [...allTags].sort(() => Math.random() - 0.5);
        
        // Randomly decide include vs exclude ratio (3:1 ratio favoring include)
        // For each tag, 75% chance to include, 25% chance to exclude
        let includeTags = [];
        let excludeTags = [];
        
        for (let i = 0; i < numTags && i < shuffledTags.length; i++) {
            const tag = shuffledTags[i];
            const includeChance = Math.random();
            
            if (includeChance < 0.75) {
                // 75% chance to include
                includeTags.push(tag);
            } else {
                // 25% chance to exclude
                excludeTags.push(tag);
            }
        }
        
        // Make sure we have at least one include tag
        if (includeTags.length === 0 && excludeTags.length > 0) {
            // Move one exclude tag to include
            includeTags.push(excludeTags.pop());
        }
        
        // If we have no tags at all, skip this attempt
        if (includeTags.length === 0 && excludeTags.length === 0) {
            continue;
        }
        
        // Decide match mode (AND/OR)
        // Can only use AND if we have fewer than 4 include tags
        let matchMode;
        if (includeTags.length < 5 && Math.random() < 0.5) {
            matchMode = 'and';
        } else {
            matchMode = 'or';
        }
        
        // Apply the selections
        includeTags.forEach(tag => selectedFilterTags.add(tag));
        excludeTags.forEach(tag => excludedFilterTags.add(tag));
        
        // Temporarily set the match mode and filter mode
        const oldMatchMode = tagMatchMode;
        const oldFilterMode = tagFilterMode;
        tagMatchMode = matchMode;
        
        // Calculate how many songs would result from this configuration
        let testFilteredFiles;
        
        // Test with include tags
        if (selectedFilterTags.size > 0) {
            testFilteredFiles = originalOrder.filter(file => {
                const config = getSongConfig(file.name);
                if (!config.tags || !config.tags.length) return false;
                
                if (tagMatchMode === 'and') {
                    return Array.from(selectedFilterTags).every(tag => config.tags.includes(tag));
                } else {
                    return config.tags.some(tag => selectedFilterTags.has(tag));
                }
            });
        } else {
            testFilteredFiles = [...originalOrder];
        }
        
        // Apply exclude filters
        if (excludedFilterTags.size > 0) {
            testFilteredFiles = testFilteredFiles.filter(file => {
                const config = getSongConfig(file.name);
                if (!config.tags || !config.tags.length) return true;
                return !config.tags.some(tag => excludedFilterTags.has(tag));
            });
        }
        
        // Apply automatic exclusions (DELETE and Original from duped)
        testFilteredFiles = testFilteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return true;
            return !config.tags.includes('DELETE') && !config.tags.includes('Original from duped');
        });
        
        // Check if we have at least 10 songs
        if (testFilteredFiles.length >= 10) {
            validConfigFound = true;
            
            // Apply the match mode
            setTagMatchMode(matchMode);
            
            
            // Render and update
            renderFilterTags();
            updateAudioFilesList();
            
            console.log(`Randomize successful: ${includeTags.length} include tags, ${excludeTags.length} exclude tags, match mode: ${matchMode}, resulting in ${testFilteredFiles.length} songs`);
        } else {
            // Restore old settings for next attempt
            tagMatchMode = oldMatchMode;
            tagFilterMode = oldFilterMode;
        }
    }
    
    if (!validConfigFound) {
        // If we couldn't find a valid configuration, reset to "All"
        selectedFilterTags.clear();
        excludedFilterTags.clear();
        selectedFilterTags.add('all');
        
        // Clear the status display
        const statusDiv = document.getElementById('randomizeStatus');
        if (statusDiv) statusDiv.textContent = '';
        
        renderFilterTags();
        updateAudioFilesList();
        
        alert('Could not find a random filter configuration with at least 10 songs after 50 attempts. Try adding more songs or tags.');
    }
}

// Restore filter mode UI from loaded settings
function restoreFilterModeUI() {
    // Restore tag filter mode (Include/Exclude)
    const filterModeButtons = document.querySelectorAll('#tagFilterModeSwitch .toggle-option');
    filterModeButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    const activeFilterBtn = tagFilterMode === 'include' ? filterModeButtons[0] : filterModeButtons[1];
    if (activeFilterBtn) {
        activeFilterBtn.classList.add('active');
        activeFilterBtn.style.background = currentAccentGradient;
        activeFilterBtn.style.color = '#1a1a1a';
    }
    
    // Restore tag select mode (Single/Multi)
    const selectModeButtons = document.querySelectorAll('#tagSelectSwitch .toggle-option');
    selectModeButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    const activeSelectBtn = tagSelectMode === 'single' ? selectModeButtons[0] : selectModeButtons[1];
    if (activeSelectBtn) {
        activeSelectBtn.classList.add('active');
        activeSelectBtn.style.background = currentAccentGradient;
        activeSelectBtn.style.color = '#1a1a1a';
    }
    
    // Restore tag match mode (AND/OR)
    const matchModeButtons = document.querySelectorAll('#tagMatchSwitch .toggle-option');
    matchModeButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    const activeMatchBtn = tagMatchMode === 'and' ? matchModeButtons[0] : matchModeButtons[1];
    if (activeMatchBtn) {
        activeMatchBtn.classList.add('active');
        activeMatchBtn.style.background = currentAccentGradient;
        activeMatchBtn.style.color = '#1a1a1a';
    }
    
    console.log('Restored filter UI:', { tagFilterMode, tagSelectMode, tagMatchMode });
}

// Toggle use saved speed
function toggleUseSavedSpeed() {
    useSavedSpeed = document.getElementById('useSavedSpeedCheckbox').checked;
    
    // If enabling and there's a current song, load its saved speed
    if (useSavedSpeed && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        loadSavedSpeed(currentFile.name);
    }
    
    // Save setting
    saveConfig();
}

// Save speed for current song
async function saveSpeed() {
    if (!currentlyPlayingFile) {
        console.warn('No song currently playing');
        return;
    }
    if (currentlyPlayingFile) {
        markAsNotDuped(currentlyPlayingFile.name);
    }
    const currentFile = currentlyPlayingFile;
    const currentSpeed = parseInt(speedSlider.value);
    
    // Update configuration
    updateSongConfig(currentFile.name, { speed: currentSpeed });
    
    // Save configuration file
    await saveConfig();
    
    console.log(`Speed saved: ${currentFile.name}: ${currentSpeed}%`);
    
    // Visual feedback
    const saveBtn = document.querySelector('.save-speed-btn');
    if (saveBtn) {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = 'âœ“ Saved';
        saveBtn.style.background = currentAccentGradient;
        saveBtn.style.color = '#1a1a1a';
        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
            saveBtn.style.color = '';
        }, 1500);
    }
}

// Load saved speed for a song
function loadSavedSpeed(filename) {
    const config = getSongConfig(filename);
    let savedSpeed = 100; // Default to 100%
    
    if (config.speed !== null && config.speed !== undefined) {
        savedSpeed = config.speed;
        console.log(`Loaded saved speed for ${filename}: ${savedSpeed}%`);
    } else {
        console.log(`No saved speed for ${filename}, using default: 100%`);
    }
    
    // Always update the slider and playback rate, even if it's the default
    speedSlider.value = savedSpeed;
    speedValue.textContent = savedSpeed;
    const adjustedSpeed = savedSpeed - (100 - globalSpeedAdjustment);
    audioPlayer.playbackRate = adjustedSpeed / 100;
    audioPlayer.preservesPitch = false;
}

// Toggle use saved speed
function toggleUseSavedSpeed() {
    useSavedSpeed = document.getElementById('useSavedSpeedCheckbox').checked;
    
    // If enabling and there's a current song, load its saved speed
    if (useSavedSpeed && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        loadSavedSpeed(currentFile.name);
    }
}

// Save fades for current song
async function saveFades() {
    if (!currentlyPlayingFile) {
        console.warn('No song currently playing');
        return;
    }
    if (currentlyPlayingFile) {
        markAsNotDuped(currentlyPlayingFile.name);
    }
    const currentFile = currentlyPlayingFile;
    const fadeIn = parseInt(fadeInSlider.value);
    const fadeOut = parseInt(fadeOutSlider.value);
    
    // Update configuration
    updateSongConfig(currentFile.name, { FI: fadeIn, FO: fadeOut });
    
    // Save configuration file
    await saveConfig();
    
    console.log(`Fades saved: ${currentFile.name}: FI=${fadeIn}s, FO=${fadeOut}s`);
    
    // Visual feedback
    const saveBtn = document.querySelector('.save-fades-btn');
    if (saveBtn) {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = 'âœ“ Saved';
        saveBtn.style.background = currentAccentGradient;
        saveBtn.style.color = '#1a1a1a';
        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
            saveBtn.style.color = '';
        }, 1500);
    }
}

// Load saved fades for a song
function loadSavedFades(filename) {
    const config = getSongConfig(filename);
    let savedFadeIn = 0;
    let savedFadeOut = 0;
    
    if (config.FI !== null && config.FI !== undefined) {
        savedFadeIn = config.FI;
    }
    
    if (config.FO !== null && config.FO !== undefined) {
        savedFadeOut = config.FO;
    }
    
    console.log(`Loaded saved fades for ${filename}: FI=${savedFadeIn}s, FO=${savedFadeOut}s`);
    
    // Update sliders
    fadeInSlider.value = savedFadeIn;
    fadeInValue.textContent = savedFadeIn;
    fadeOutSlider.value = savedFadeOut;
    fadeOutValue.textContent = savedFadeOut;
    
    currentFadeInDuration = savedFadeIn;
    currentFadeOutDuration = savedFadeOut;
}

// Toggle use saved fades
function toggleUseSavedFades() {
    useSavedFades = document.getElementById('useSavedFadesCheckbox').checked;
    
    // If enabling and there's a current song, load its saved fades
    if (useSavedFades && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        loadSavedFades(currentFile.name);
    }
    
    // Save setting
    saveConfig();
}

// Apply fade in effect
function applyFadeIn() {
    if (currentFadeInDuration === 0 || !audioPlayer.src) return;
    
    isFadingIn = true;
    originalVolume = volumeSlider.value / 100;
    
    // Start at 0 volume
    audioPlayer.volume = 0;
    
    const startTime = Date.now();
    const fadeInMs = currentFadeInDuration * 1000;
    
    if (fadeInInterval) clearInterval(fadeInInterval);
    
    fadeInInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fadeInMs, 1);
        
        // Linear fade in
        audioPlayer.volume = originalVolume * progress;
        
        if (progress >= 1) {
            clearInterval(fadeInInterval);
            fadeInInterval = null;
            isFadingIn = false;
            audioPlayer.volume = originalVolume;
        }
    }, 20);
}

// Apply fade out effect
function applyFadeOut() {
    if (currentFadeOutDuration === 0 || !audioPlayer.src) return;
    
    isFadingOut = true;
    originalVolume = volumeSlider.value / 100;
    
    const fadeOutMs = currentFadeOutDuration * 1000;
    const startTime = Date.now();
    const startVolume = audioPlayer.volume;
    
    if (fadeOutInterval) clearInterval(fadeOutInterval);
    
    fadeOutInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fadeOutMs, 1);
        
        // Linear fade out
        audioPlayer.volume = startVolume * (1 - progress);
        
        if (progress >= 1) {
            clearInterval(fadeOutInterval);
            fadeOutInterval = null;
            isFadingOut = false;
        }
    }, 20);
}

// Stop any active fades
function stopFades() {
    if (fadeInInterval) {
        clearInterval(fadeInInterval);
        fadeInInterval = null;
    }
    if (fadeOutInterval) {
        clearInterval(fadeOutInterval);
        fadeOutInterval = null;
    }
    isFadingIn = false;
    isFadingOut = false;
    
    // Restore original volume
    if (audioPlayer.src) {
        audioPlayer.volume = volumeSlider.value / 100;
    }
}

// Toggle prioritize new songs
function togglePrioritizeNewSongs() {
    prioritizeNewSongs = document.getElementById('prioritizeNewSongsCheckbox').checked;
    
    // Save setting
    saveConfig();
    
    console.log('Prioritize tagging:', prioritizeNewSongs ? 'enabled' : 'disabled');
}

// Toggle repeat prevention
function toggleRepeatPrevention() {
    repeatPrevention = document.getElementById('repeatPreventionCheckbox').checked;
    
    // Save setting
    saveConfig();
    
    console.log('Repeat prevention:', repeatPrevention ? 'enabled' : 'disabled', 'Days:', repeatPreventionDays);
}

// Update repeat prevention days
function updateRepeatPreventionDays() {
    repeatPreventionDays = parseInt(document.getElementById('repeatPreventionDays').value) || 7;
    
    // Save setting
    saveConfig();
    
    console.log('Repeat prevention days updated to:', repeatPreventionDays);
}



// Check if all songs have <=4 tags and reset if so
function checkAndResetHeardStatus() {
    if (!prioritizeNewSongs) return false;
    
    // Get all songs in the folder (audioFiles represents the actual files)
    const allFilesInFolder = originalOrder.map(file => file.name);
    
    if (allFilesInFolder.length === 0) return false;
    
    // Check if ALL songs in the folder have more than 4 tags
    const allHaveMoreThan4Tags = allFilesInFolder.every(filename => {
        const config = getSongConfig(filename);
        const tagCount = (config.tags || []).length;
        return tagCount > 4;
    });
    
    if (allHaveMoreThan4Tags) {
        console.log('All songs in folder have more than 4 tags. Allowing all songs to play.');
        return true;
    }
    
    return false;
}

// Check if a song was played within the repeat prevention window
function wasPlayedRecently(filename) {
    if (!repeatPrevention) return false;
    
    const config = getSongConfig(filename);
    if (!config.lastPlayed) return false; // Never played before
    
    const lastPlayedDate = new Date(config.lastPlayed);
    const currentDate = new Date();
    const daysSinceLastPlayed = (currentDate - lastPlayedDate) / (1000 * 60 * 60 * 24);
    
    return daysSinceLastPlayed < repeatPreventionDays;
}

// Check if all songs have been played recently
function checkAllSongsPlayedRecently() {
    if (!repeatPrevention) return false;
    
    const allFilesInFolder = originalOrder.map(file => file.name);
    
    if (allFilesInFolder.length === 0) return false;
    
    // Check if ALL songs were played within the repeat prevention window
    const allPlayedRecently = allFilesInFolder.every(filename => {
        return wasPlayedRecently(filename);
    });
    
    if (allPlayedRecently) {
        console.log('All songs have been played within the last', repeatPreventionDays, 'days. Allowing all songs to play.');
        return true;
    }
    
    return false;
}

// Mark current song with last played date
function updateLastPlayedDate() {
    if (!currentlyPlayingFile) return;
    
    const currentDate = new Date().toISOString();
    updateSongConfig(currentlyPlayingFile.name, { lastPlayed: currentDate });
    
    // Save immediately
    saveConfig();
    
    console.log(`Updated last played date for: ${currentlyPlayingFile.name} to ${currentDate}`);
}

// Mark current song as heard if conditions are met
function checkAndMarkAsHeard() {
    if (!currentlyPlayingFile || hasMarkedAsHeard) return;
    
    const duration = audioPlayer.duration;
    const currentTime = audioPlayer.currentTime;
    
    // Mark as heard if played for 10+ seconds, or entire song if less than 10 seconds
    const threshold = duration < 10 ? duration : 10;
    
    if (currentTime >= threshold) {
        // Always update last played date (regardless of repeat prevention setting)
        const currentDate = new Date().toISOString();
        updateSongConfig(currentlyPlayingFile.name, { lastPlayed: currentDate });
        
        hasMarkedAsHeard = true;
        
        // Save immediately
        saveConfig();
        
        console.log(`Marked last played date: ${currentDate} for ${currentlyPlayingFile.name}`);
    }
}

// Select JSON file for merging
async function selectJsonFile(jsonNumber) {
    try {
        // Open file picker for JSON files
        const [fileHandle] = await window.showOpenFilePicker({
            types: [{
                description: 'JSON Files',
                accept: { 'application/json': ['.json'] }
            }],
            multiple: false
        });
        
        const file = await fileHandle.getFile();
        const text = await file.text();
        
        // Parse and validate JSON
        let jsonData;
        try {
            jsonData = JSON.parse(text);
        } catch (e) {
            alert('Invalid JSON file. Please select a valid u-groove-config.json file.');
            return;
        }
        
        // Store the data
        if (jsonNumber === 1) {
            json1Data = jsonData;
            json1FileName = file.name;
            document.getElementById('json1Btn').classList.add('selected');
            document.getElementById('json1Info').textContent = file.name;
            console.log('JSON 1 loaded:', file.name);
        } else {
            json2Data = jsonData;
            json2FileName = file.name;
            document.getElementById('json2Btn').classList.add('selected');
            document.getElementById('json2Info').textContent = file.name;
            console.log('JSON 2 loaded:', file.name);
        }
        
        // Enable merge button if both files are selected
        if (json1Data && json2Data) {
            document.getElementById('mergeBtn').disabled = false;
        }
        
    } catch (err) {
        console.error('Error selecting file:', err);
    }
}

// Merge JSON files
async function mergeJsonFiles() {
    if (!json1Data || !json2Data) {
        alert('Please select both JSON files before merging.');
        return;
    }
    
    console.log('Starting merge...');
    
    // Create merged data structure starting with JSON 1
    const mergedData = {
        songs: JSON.parse(JSON.stringify(json1Data.songs || {})),
        masterTags: JSON.parse(JSON.stringify(json1Data.masterTags || {})),
        appSettings: JSON.parse(JSON.stringify(json2Data.appSettings || json1Data.appSettings || {}))
    };
    
    // Merge songs from JSON 2 into JSON 1
    const json2Songs = json2Data.songs || {};
    
    Object.keys(json2Songs).forEach(filename => {
        const json2Song = json2Songs[filename];
        
        if (!mergedData.songs[filename]) {
            // Song doesn't exist in JSON 1, add it completely
            mergedData.songs[filename] = JSON.parse(JSON.stringify(json2Song));
            console.log(`Added new song: ${filename}`);
        } else {
            // Song exists in both, merge properties
            const json1Song = mergedData.songs[filename];
            
            // Merge tags (add unique tags from JSON 2)
            if (json2Song.tags && Array.isArray(json2Song.tags)) {
                const json1Tags = new Set(json1Song.tags || []);
                json2Song.tags.forEach(tag => json1Tags.add(tag));
                mergedData.songs[filename].tags = Array.from(json1Tags);
            }
            
            // Overwrite speed if JSON 2 has a non-null value
            if (json2Song.speed !== null && json2Song.speed !== undefined) {
                mergedData.songs[filename].speed = json2Song.speed;
            }
            
            // Overwrite trimStart if JSON 2 has a non-null value
            if (json2Song.trimStart !== null && json2Song.trimStart !== undefined) {
                mergedData.songs[filename].trimStart = json2Song.trimStart;
            }
            
            // Overwrite trimEnd if JSON 2 has a non-null value
            if (json2Song.trimEnd !== null && json2Song.trimEnd !== undefined) {
                mergedData.songs[filename].trimEnd = json2Song.trimEnd;
            }
            
            // Overwrite FI if JSON 2 has a value greater than 0
            if (json2Song.FI && json2Song.FI > 0) {
                mergedData.songs[filename].FI = json2Song.FI;
            }
            
            // Overwrite FO if JSON 2 has a value greater than 0
            if (json2Song.FO && json2Song.FO > 0) {
                mergedData.songs[filename].FO = json2Song.FO;
            }
            
            // Overwrite heardb4 if JSON 2 has it as true
            if (json2Song.heardb4 === true) {
                mergedData.songs[filename].heardb4 = true;
            }
            
            // Overwrite customColor1 if JSON 2 has a non-null value
            if (json2Song.customColor1 !== null && json2Song.customColor1 !== undefined) {
                mergedData.songs[filename].customColor1 = json2Song.customColor1;
            }
            
            // Overwrite customColor2 if JSON 2 has a non-null value
            if (json2Song.customColor2 !== null && json2Song.customColor2 !== undefined) {
                mergedData.songs[filename].customColor2 = json2Song.customColor2;
            }
            
            // Overwrite lastPlayed if JSON 2 has a non-null value
            if (json2Song.lastPlayed !== null && json2Song.lastPlayed !== undefined) {
                mergedData.songs[filename].lastPlayed = json2Song.lastPlayed;
            }
            
            // Overwrite duped if JSON 2 has it as true
            if (json2Song.duped === true) {
                mergedData.songs[filename].duped = true;
            }
            
            console.log(`Merged song: ${filename}`);
        }
    });
    
    // Merge master tags from JSON 2
    const json2Tags = json2Data.masterTags || {};
    
    Object.keys(json2Tags).forEach(tagName => {
        if (!mergedData.masterTags[tagName]) {
            // Tag doesn't exist in JSON 1, add it
            mergedData.masterTags[tagName] = JSON.parse(JSON.stringify(json2Tags[tagName]));
            console.log(`Added new tag: ${tagName}`);
        } else {
            // Tag exists in both - merge color and weight from JSON 2 if they exist
            if (json2Tags[tagName].color !== null && json2Tags[tagName].color !== undefined) {
                mergedData.masterTags[tagName].color = json2Tags[tagName].color;
            }
            if (json2Tags[tagName].weight !== null && json2Tags[tagName].weight !== undefined) {
                mergedData.masterTags[tagName].weight = json2Tags[tagName].weight;
            }
        }
        // Song counts will be recalculated below
    });
    
    // Recalculate song counts for all tags based on merged songs
    Object.keys(mergedData.masterTags).forEach(tagName => {
        let count = 0;
        Object.keys(mergedData.songs).forEach(filename => {
            const song = mergedData.songs[filename];
            if (song.tags && song.tags.includes(tagName)) {
                count++;
            }
        });
        mergedData.masterTags[tagName].songCount = count;
        console.log(`Updated tag count for ${tagName}: ${count}`);
    });
    
    // Remove tags with 0 songs
    Object.keys(mergedData.masterTags).forEach(tagName => {
        if (mergedData.masterTags[tagName].songCount === 0) {
            delete mergedData.masterTags[tagName];
            console.log(`Removed tag with 0 songs: ${tagName}`);
        }
    });
    
    console.log('Merge complete!');
    console.log('Total songs:', Object.keys(mergedData.songs).length);
    console.log('Total tags:', Object.keys(mergedData.masterTags).length);
    
    // Download the merged JSON
    downloadMergedJson(mergedData);
    
    // Reset the merge UI
    resetMergeUI();
}

// Download merged JSON file
function downloadMergedJson(mergedData) {
    const jsonString = JSON.stringify(mergedData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'u-groove-config-merged.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    alert('Merged JSON file has been downloaded as "u-groove-config-merged.json". Replace your current config file with this merged version.');
}

// Reset merge UI
function resetMergeUI() {
    json1Data = null;
    json2Data = null;
    json1FileName = '';
    json2FileName = '';
    
    document.getElementById('json1Btn').classList.remove('selected');
    document.getElementById('json2Btn').classList.remove('selected');
    document.getElementById('json1Info').textContent = 'No file selected';
    document.getElementById('json2Info').textContent = 'No file selected';
    document.getElementById('mergeBtn').disabled = true;
}

// Get next song based on filters (tagging priority and repeat prevention)
function getNextUnheardSongIndex(direction = 'next') {
    console.log('=== getNextUnheardSongIndex called ===');
    console.log('prioritizeNewSongs:', prioritizeNewSongs);
    console.log('repeatPrevention:', repeatPrevention);
    console.log('direction:', direction);
    console.log('currentIndex:', currentIndex);
    console.log('audioFiles.length:', audioFiles.length);
    
    if ((!prioritizeNewSongs && !repeatPrevention) || audioFiles.length === 0) {
        const nextIndex = direction === 'next' 
            ? (currentIndex + 1) % audioFiles.length 
            : (currentIndex - 1 + audioFiles.length) % audioFiles.length;
        console.log('Both filters disabled or no files, returning:', nextIndex);
        return nextIndex;
    }
    
    // Check if all songs meet the filter criteria (either >4 tags or played recently)
    const allHaveMoreThan4Tags = prioritizeNewSongs ? checkAndResetHeardStatus() : false;
    const allPlayedRecently = repeatPrevention ? checkAllSongsPlayedRecently() : false;
    
    console.log('All songs have >4 tags?', allHaveMoreThan4Tags);
    console.log('All songs played recently?', allPlayedRecently);
    
    // If all songs meet ALL active filter criteria, just play next in sequence
    if ((prioritizeNewSongs && allHaveMoreThan4Tags) || (repeatPrevention && allPlayedRecently)) {
        const nextIndex = direction === 'next' 
            ? (currentIndex + 1) % audioFiles.length 
            : (currentIndex - 1 + audioFiles.length) % audioFiles.length;
        console.log('All songs meet filter criteria, returning sequential index:', nextIndex);
        return nextIndex;
    }
    
    // Find next song that passes all active filters
    let searchIndex = currentIndex;
    let attempts = 0;
    const maxAttempts = audioFiles.length;
    
    console.log('Starting search from index:', searchIndex);
    
    while (attempts < maxAttempts) {
        // Move to next/previous song
        if (direction === 'next') {
            searchIndex = (searchIndex + 1) % audioFiles.length;
        } else {
            searchIndex = (searchIndex - 1 + audioFiles.length) % audioFiles.length;
        }
        
        const file = audioFiles[searchIndex];
        const config = getSongConfig(file.name);
        const tagCount = (config.tags || []).length;
        const playedRecently = wasPlayedRecently(file.name);
        
        console.log(`Checking index ${searchIndex}: ${file.name}`);
        console.log('  tag count:', tagCount);
        console.log('  played recently:', playedRecently);
        
        // Check if song passes all active filters
        let passesFilters = true;
        
        if (prioritizeNewSongs && tagCount > 4) {
            passesFilters = false;
            console.log('  âœ— Failed tag filter (>4 tags)');
        }
        
        if (repeatPrevention && playedRecently) {
            passesFilters = false;
            console.log('  âœ— Failed repeat prevention (played recently)');
        }
        
        if (passesFilters) {
            console.log(`âœ“ Found song that passes all filters at index ${searchIndex}: ${file.name}`);
            return searchIndex;
        }
        
        attempts++;
    }
    
    // If all songs in current list fail filters, return next in sequence
    console.log('All songs in current list fail filters, playing next in sequence');
    const nextIndex = direction === 'next' 
        ? (currentIndex + 1) % audioFiles.length 
        : (currentIndex - 1 + audioFiles.length) % audioFiles.length;
    console.log('Returning sequential index:', nextIndex);
    return nextIndex;
}

// Parse saved speed from comments
function parseSpeedFromComments(comments) {
    const match = comments.match(/PS:\s*(\d+)/);
    if (match) {
        return parseInt(match[1]);
    }
    return null;
}

// Update compact player display
function updateCompactPlayer() {
    const compactTitle = document.getElementById('compactTitle');
    const compactTime = document.getElementById('compactTime');
    const playBtnCompact = document.getElementById('playBtnCompact');
    
    if (currentlyPlayingFile) {
        // Get config for display name and tag count
        const config = getSongConfig(currentlyPlayingFile.name);
        const displayName = (config.identified && config.artist && config.title) 
            ? `${config.artist} - ${config.title}` 
            : currentlyPlayingFile.name;
        
        const tagCount = config.tags ? config.tags.length : 0;
        const tagCountText = tagCount > 0 ? ` (${tagCount} tag${tagCount !== 1 ? 's' : ''})` : '';
        
        compactTitle.textContent = `${displayName}${tagCountText}`;
    } else {
        compactTitle.textContent = 'No track playing';
    }
    
    // Get trim settings for current song
    let trimStart = 0;
    let trimEnd = audioPlayer.duration;
    
    if (audioFiles.length > 0 && currentIndex >= 0) {
        const file = audioFiles[currentIndex];
        const config = getSongConfig(file.name);
        trimStart = config.trimStart || 0;
        trimEnd = config.trimEnd || audioPlayer.duration;
    }
    
    // Calculate trimmed duration and current time relative to trim
    const trimmedDuration = trimEnd - trimStart;
    const currentTimeRelativeToTrim = audioPlayer.currentTime - trimStart;
    
    compactTime.textContent = `${formatTime(Math.max(0, currentTimeRelativeToTrim))} / ${formatTime(trimmedDuration)}`;
    playBtnCompact.textContent = isPlaying ? 'â¸' : 'â–¶';
}

// Update now playing display with tag count
function updateNowPlayingDisplay() {
    if (!currentlyPlayingFile) {
        document.getElementById('nowPlaying').textContent = 'No track playing';
        document.getElementById('compactTitle').textContent = 'No track playing';
        return;
    }
    
    // Get config for display name and tag count
    const config = getSongConfig(currentlyPlayingFile.name);
    const displayName = (config.identified && config.artist && config.title) 
        ? `${config.artist} - ${config.title}` 
        : currentlyPlayingFile.name;
    
    const tagCount = config.tags ? config.tags.length : 0;
    const tagCountText = tagCount > 0 ? ` (${tagCount} tag${tagCount !== 1 ? 's' : ''})` : '';
    
    const fullText = `Now playing: ${displayName}${tagCountText}`;
    const compactText = `${displayName}${tagCountText}`;
    
    document.getElementById('nowPlaying').textContent = fullText;
    document.getElementById('compactTitle').textContent = compactText;
}

        // Set normalize button to active on load since it's on by default

// Visualizer control sliders
const minFreqSlider = document.getElementById('minFreqSlider');
const minFreqValue = document.getElementById('minFreqValue');
const maxFreqSlider = document.getElementById('maxFreqSlider');
const maxFreqValue = document.getElementById('maxFreqValue');
const minHeightSlider = document.getElementById('minHeightSlider');
const minHeightValue = document.getElementById('minHeightValue');
const maxHeightSlider = document.getElementById('maxHeightSlider');
const maxHeightValue = document.getElementById('maxHeightValue');
const waveformSensitivitySlider = document.getElementById('waveformSensitivitySlider');
const waveformSensitivityValue = document.getElementById('waveformSensitivityValue');

minFreqSlider.addEventListener('input', (e) => {
    minFrequency = parseInt(e.target.value);
    minFreqValue.textContent = minFrequency;
});
minFreqSlider.addEventListener('change', () => saveConfig());

maxFreqSlider.addEventListener('input', (e) => {
    maxFrequency = parseInt(e.target.value);
    maxFreqValue.textContent = maxFrequency;
});
maxFreqSlider.addEventListener('change', () => saveConfig());

minHeightSlider.addEventListener('input', (e) => {
    minBarHeight = parseInt(e.target.value);
    minHeightValue.textContent = minBarHeight;
});
minHeightSlider.addEventListener('change', () => saveConfig());

maxHeightSlider.addEventListener('input', (e) => {
    maxBarHeight = parseInt(e.target.value);
    maxHeightValue.textContent = maxBarHeight;
});
maxHeightSlider.addEventListener('change', () => saveConfig());

waveformSensitivitySlider.addEventListener('input', (e) => {
    waveformSensitivity = parseFloat(e.target.value);
    waveformSensitivityValue.textContent = waveformSensitivity.toFixed(1) + 'x';
});
waveformSensitivitySlider.addEventListener('change', () => saveConfig());

// Tab visibility detection
document.addEventListener('visibilitychange', () => {
    isTabVisible = !document.hidden;
});

// Track if we're programmatically updating color pickers to prevent saving
let isUpdatingColorPickers = false;

// Song-specific color picker event listeners
document.getElementById('songColor1Picker').addEventListener('change', async (e) => {
    if (!currentlyPlayingFile) return;
    
    // Don't save if this is a programmatic update
    if (isUpdatingColorPickers) return;
    
    const config = getSongConfig(currentlyPlayingFile.name);
    config.customColor1 = e.target.value;
    await saveConfig();
    
    // Update visualizer colors immediately
    updateAccentColors(config.customColor1, config.customColor2 || accentColor2);
});

document.getElementById('songColor2Picker').addEventListener('change', async (e) => {
    if (!currentlyPlayingFile) return;
    
    // Don't save if this is a programmatic update
    if (isUpdatingColorPickers) return;
    
    const config = getSongConfig(currentlyPlayingFile.name);
    config.customColor2 = e.target.value;
    await saveConfig();
    
    // Update visualizer colors immediately
    updateAccentColors(config.customColor1 || accentColor1, config.customColor2);
});

// Sort select change handler
const sortSelect = document.getElementById('sortSelect');
if (sortSelect) {
    sortSelect.addEventListener('change', (e) => {
        sortBy = e.target.value;
        
        // Turn off shuffle when changing sort
        if (isShuffled) {
            isShuffled = false;
            shuffleBtn.classList.remove('active');
            shuffleBtn.style.background = '';
            shuffleBtn.style.color = '';
            shuffleBtn.style.borderColor = accentColor1;
            console.log('Shuffle disabled due to sort change');
        }
        
        updateAudioFilesList();
    });
}

// Apply accent colors to sort controls
const sortOrderBtn = document.getElementById('sortOrderBtn');
const scrollToSongBtn = document.querySelector('.scroll-to-song-btn');

sortSelect.addEventListener('focus', () => {
    sortSelect.style.borderColor = accentColor1;
});

sortSelect.addEventListener('blur', () => {
    sortSelect.style.borderColor = '#3a3a3a';
});

// Trim functionality
let trimStartTime = 0;
let trimEndTime = 0;
let trimZoomLevel = 1;
let trimScrollOffset = 0;
let trimWaveformData = null;
let trimCurrentFile = null;
let isDraggingTrimHandle = null;
let isPanningWaveform = false;
let panStartX = 0;
let panStartOffset = 0;

// Open trim window
async function openTrimWindow() {
    if (audioFiles.length === 0 || currentIndex < 0) {
        alert('Please select a song first');
        return;
    }
    
    trimCurrentFile = audioFiles[currentIndex];
    const config = getSongConfig(trimCurrentFile.name);
    
    // Load existing trim points or use defaults
    trimStartTime = config.trimStart || 0;
    trimEndTime = config.trimEnd || audioPlayer.duration || 0;
    
    // If no trim end is set, use the audio duration
    if (trimEndTime === 0 && audioPlayer.duration) {
        trimEndTime = audioPlayer.duration;
    }
    
    // Reset zoom and scroll
    trimZoomLevel = 1;
    trimScrollOffset = 0;
    
    // Show overlay
    document.getElementById('trimOverlay').classList.add('active');
    document.getElementById('trimHeader').textContent = `Trim: ${trimCurrentFile.name}`;
    
    // Load waveform data
    await loadTrimWaveform();
    
    // Setup drag handlers
    setupTrimHandlers();
    
    // Initial draw
    drawTrimWaveform();
    updateTrimDisplay();
}

// Close trim window
function closeTrimWindow() {
    document.getElementById('trimOverlay').classList.remove('active');
    trimWaveformData = null;
    trimCurrentFile = null;
}

// Load waveform data for trimming
async function loadTrimWaveform() {
    if (!trimCurrentFile) return;
    
    try {
        // Create an offline audio context to decode the entire file
        const arrayBuffer = await trimCurrentFile.arrayBuffer();
        const offlineContext = new OfflineAudioContext(1, 44100 * 30, 44100);
        const audioBuffer = await offlineContext.decodeAudioData(arrayBuffer);
        
        // Get channel data
        const channelData = audioBuffer.getChannelData(0);
        const duration = audioBuffer.duration;
        
        // If we don't have a trim end time yet, set it to duration
        if (trimEndTime === 0) {
            trimEndTime = duration;
        }
        
        trimWaveformData = {
            data: channelData,
            duration: duration,
            sampleRate: audioBuffer.sampleRate
        };
        
    } catch (error) {
        console.error('Error loading waveform:', error);
        alert('Error loading waveform data');
    }
}

// Draw trim waveform
function drawTrimWaveform() {
    if (!trimWaveformData) return;
    
    const canvas = document.getElementById('trimWaveformCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('trimWaveformContainer');
    
    // Set canvas size
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    
    // Clear canvas
    ctx.fillStyle = '#0f0f0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const { data, duration } = trimWaveformData;
    const width = canvas.width;
    const height = canvas.height;
    const centerY = height / 2;
    
    // Calculate visible time range based on zoom and scroll
    const visibleDuration = duration / trimZoomLevel;
    const startTime = trimScrollOffset;
    const endTime = Math.min(startTime + visibleDuration, duration);
    
    // Calculate samples per pixel
    const samplesPerPixel = Math.floor((data.length * (endTime - startTime) / duration) / width);
    
    // Draw waveform
    ctx.beginPath();
    ctx.strokeStyle = accentColor1;
    ctx.lineWidth = 1;
    
    for (let x = 0; x < width; x++) {
        const time = startTime + (x / width) * (endTime - startTime);
        const sampleIndex = Math.floor((time / duration) * data.length);
        
        // Get min/max for this pixel
        let min = 1;
        let max = -1;
        
        for (let s = 0; s < samplesPerPixel && sampleIndex + s < data.length; s++) {
            const value = data[sampleIndex + s];
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        
        const yMin = centerY - (min * centerY);
        const yMax = centerY - (max * centerY);
        
        ctx.moveTo(x, yMin);
        ctx.lineTo(x, yMax);
    }
    
    ctx.stroke();
    
    // Update handle positions
    updateTrimHandlePositions();
}

// Global speed slider
document.getElementById('globalSpeedSlider').addEventListener('input', (e) => {
    globalSpeedAdjustment = parseFloat(e.target.value);
    document.getElementById('globalSpeedValue').textContent = globalSpeedAdjustment.toFixed(2);
    
    // If a song is currently playing, update its speed immediately
    if (audioPlayer && currentlyPlayingFile) {
        const config = getSongConfig(currentlyPlayingFile.name);
        const savedSpeed = config.speed || 100;
        const adjustedSpeed = savedSpeed - (100 - globalSpeedAdjustment);
        audioPlayer.playbackRate = adjustedSpeed / 100;
    }
});
// Update trim handle positions
function updateTrimHandlePositions() {
    if (!trimWaveformData) return;
    
    const container = document.getElementById('trimWaveformContainer');
    const width = container.offsetWidth;
    if (!trimWaveformData) return;
    const duration = trimWaveformData.duration;
    
    // Calculate visible time range
    const visibleDuration = duration / trimZoomLevel;
    const startTime = trimScrollOffset;
    const endTime = Math.min(startTime + visibleDuration, duration);
    
    // Calculate handle positions relative to visible range
    const startPos = ((trimStartTime - startTime) / (endTime - startTime)) * width;
    const endPos = ((trimEndTime - startTime) / (endTime - startTime)) * width;
    
    // Update handle elements
    const startHandle = document.getElementById('trimHandleStart');
    const endHandle = document.getElementById('trimHandleEnd');
    const region = document.getElementById('trimRegion');
    
    startHandle.style.left = `${Math.max(0, Math.min(width, startPos))}px`;
    endHandle.style.left = `${Math.max(0, Math.min(width, endPos))}px`;
    
    region.style.left = `${Math.max(0, startPos)}px`;
    region.style.width = `${Math.max(0, endPos - startPos)}px`;
}

// Setup trim drag handlers
function setupTrimHandlers() {
    const container = document.getElementById('trimWaveformContainer');
    const startHandle = document.getElementById('trimHandleStart');
    const endHandle = document.getElementById('trimHandleEnd');
    
    // Handle dragging
    startHandle.onmousedown = (e) => {
        e.stopPropagation();
        isDraggingTrimHandle = 'start';
    };
    
    endHandle.onmousedown = (e) => {
        e.stopPropagation();
        isDraggingTrimHandle = 'end';
    };
    
    // Panning
    container.onmousedown = (e) => {
        if (isDraggingTrimHandle) return;
        isPanningWaveform = true;
        panStartX = e.clientX;
        panStartOffset = trimScrollOffset;
    };
    
    document.onmousemove = (e) => {
        if (isDraggingTrimHandle) {
            const container = document.getElementById('trimWaveformContainer');
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            if (!trimWaveformData) return;
            const duration = trimWaveformData.duration;
            
            // Calculate time from position
            const visibleDuration = duration / trimZoomLevel;
            const startTime = trimScrollOffset;
            const endTime = Math.min(startTime + visibleDuration, duration);
            const time = startTime + (x / width) * (endTime - startTime);
            
            if (isDraggingTrimHandle === 'start') {
                trimStartTime = Math.max(0, Math.min(time, trimEndTime - 0.01));
            } else if (isDraggingTrimHandle === 'end') {
                trimEndTime = Math.max(trimStartTime + 0.01, Math.min(time, duration));
            }
            
            updateTrimDisplay();
            updateTrimHandlePositions();
        } else if (isPanningWaveform) {
            const container = document.getElementById('trimWaveformContainer');
            const rect = container.getBoundingClientRect();
            const deltaX = e.clientX - panStartX;
            if (!trimWaveformData) return;
            const duration = trimWaveformData.duration;
            const visibleDuration = duration / trimZoomLevel;
            
            // Convert pixel delta to time delta
            const timeDelta = (deltaX / rect.width) * visibleDuration;
            trimScrollOffset = Math.max(0, Math.min(panStartOffset - timeDelta, duration - visibleDuration));
            
            drawTrimWaveform();
        }
    };
    
    document.onmouseup = () => {
        isDraggingTrimHandle = null;
        isPanningWaveform = false;
    };
}

// Adjust trim zoom
function adjustTrimZoom(delta) {
    if (!trimWaveformData) return;
    trimZoomLevel = Math.max(1, Math.min(40, trimZoomLevel + delta));
    
    // Adjust scroll offset to keep centered
    const duration = trimWaveformData.duration;
    const visibleDuration = duration / trimZoomLevel;
    trimScrollOffset = Math.max(0, Math.min(trimScrollOffset, duration - visibleDuration));
    
    drawTrimWaveform();
}

// Reset trim zoom
function resetTrimZoom() {
    trimZoomLevel = 1;
    trimScrollOffset = 0;
    drawTrimWaveform();
}

// Update trim display
function updateTrimDisplay() {
    document.getElementById('trimStartTime').textContent = formatTimeWithMs(trimStartTime);
    document.getElementById('trimEndTime').textContent = formatTimeWithMs(trimEndTime);
    document.getElementById('trimDuration').textContent = formatTimeWithMs(trimEndTime - trimStartTime);
}

// Format time with milliseconds
function formatTimeWithMs(seconds) {
    if (isNaN(seconds)) return '0:00.00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 100);
    return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
}

// Save trim settings
async function saveTrimSettings() {
    if (!currentlyPlayingFile) return;
    
    if (currentlyPlayingFile) {
        markAsNotDuped(currentlyPlayingFile.name);
    }
    // Update configuration
    updateSongConfig(currentlyPlayingFile.name, {
        trimStart: trimStartTime,
        trimEnd: trimEndTime
    });
    
    // Save configuration file
    await saveConfig();
    
    console.log('Trim saved for:', trimCurrentFile.name, {
        start: trimStartTime,
        end: trimEndTime
    });
    
    closeTrimWindow();
    
    // If this is the currently playing song, apply trim immediately
     if (isPlaying) {
        applyTrimToCurrentSong();
    }
}

// Apply trim to currently playing song
function applyTrimToCurrentSong() {
    if (audioFiles.length === 0 || currentIndex < 0) return;
    
    const file = audioFiles[currentIndex];
    const config = getSongConfig(file.name);
    
    if (config.trimStart !== null && config.trimStart !== undefined) {
        audioPlayer.currentTime = config.trimStart;
    }
}

// Open trim window
async function openTrimWindow() {
    if (!currentlyPlayingFile) {
        alert('Please select a song first');
        return;
    }
    
    trimCurrentFile = currentlyPlayingFile;
    const config = getSongConfig(trimCurrentFile.name);
    
    // Load existing trim points or use defaults
    trimStartTime = config.trimStart || 0;
    trimEndTime = config.trimEnd || audioPlayer.duration || 0;
    
    // If no trim end is set, use the audio duration
    if (trimEndTime === 0 && audioPlayer.duration) {
        trimEndTime = audioPlayer.duration;
    }
    
    // Reset zoom and scroll
    trimZoomLevel = 1;
    trimScrollOffset = 0;
    
    // Show overlay
    document.getElementById('trimOverlay').classList.add('active');
    document.getElementById('trimHeader').textContent = `Trim: ${trimCurrentFile.name}`;
    
    // Load waveform data
    await loadTrimWaveform();
    
    // Setup drag handlers
    setupTrimHandlers();
    
    // Initial draw
    drawTrimWaveform();
    updateTrimDisplay();
}

// Parse trim times from comments
function parseTrimFromComments(comments) {
    const startMatch = comments.match(/ST:\s*([\d.]+)/);
    const endMatch = comments.match(/ET:\s*([\d.]+)/);
    
    return {
        trimStart: startMatch ? parseFloat(startMatch[1]) : undefined,
        trimEnd: endMatch ? parseFloat(endMatch[1]) : undefined
    };
}

// Detect silence at beginning and end of audio file
async function detectSilence(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        await audioContext.close();
        
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;
        const duration = audioBuffer.duration;
        
        // -40dB threshold = 0.01 amplitude (10^(-40/20))
        const silenceThreshold = 0.01;
        
        // Find start of audio (first non-silent sample)
        let startSample = 0;
        for (let i = 0; i < channelData.length; i++) {
            if (Math.abs(channelData[i]) > silenceThreshold) {
                startSample = i;
                break;
            }
        }
        
        // Find end of audio (last non-silent sample, searching backwards)
        let endSample = channelData.length - 1;
        for (let i = channelData.length - 1; i >= 0; i--) {
            if (Math.abs(channelData[i]) > silenceThreshold) {
                endSample = i;
                break;
            }
        }
        
        // Convert samples to time
        const startTime = startSample / sampleRate;
        const endTime = endSample / sampleRate;
        
        // Calculate how much silence to leave
        const maxLeadingSilence = 0.1; // 0.1 seconds at start
        const maxTrailingSilence = 2.0; // 2 seconds at end
        
        // Calculate trim points (leave specified amount of silence)
        const trimStart = Math.max(0, startTime - maxLeadingSilence);
        const trimEnd = Math.min(duration, endTime + maxTrailingSilence);
        
        return {
            trimStart: trimStart,
            trimEnd: trimEnd,
            originalStart: startTime,
            originalEnd: endTime,
            hadSilence: (startTime > 0.2 || (duration - endTime) > 2.5)
        };
        
    } catch (error) {
        console.error('Error detecting silence for', file.name, error);
        return null;
    }
}

// Auto-trim silence from all songs
async function autoTrimSilence() {
    if (!originalOrder || originalOrder.length === 0) {
        alert('Please select a music folder first');
        return;
    }
    
    const autoTrimBtn = document.getElementById('autoTrimBtn');
    const statusEl = document.getElementById('autoTrimStatus');
    
    // Get songs that don't have trim settings
    const songsToProcess = originalOrder.filter(file => {
        const config = getSongConfig(file.name);
        return config.trimStart === null || config.trimEnd === null;
    });
    
    if (songsToProcess.length === 0) {
        alert('All songs already have trim settings. No songs need auto-trimming.');
        statusEl.textContent = 'All songs already trimmed';
        statusEl.style.color = '#4CAF50';
        return;
    }
    
    const confirmed = confirm(`This will analyze and auto-trim ${songsToProcess.length} song(s). This may take a while. Continue?`);
    if (!confirmed) return;
    
    // Disable button
    autoTrimBtn.disabled = true;
    autoTrimBtn.textContent = 'Processing...';
    
    let processed = 0;
    let trimmed = 0;
    let skipped = 0;
    
    try {
        for (const file of songsToProcess) {
            statusEl.textContent = `Analyzing ${processed + 1}/${songsToProcess.length}: ${file.name}`;
            
            // Detect silence
            const silenceData = await detectSilence(file);
            
            if (silenceData && silenceData.hadSilence) {
                // Only update if significant silence was detected
                updateSongConfig(file.name, {
                    trimStart: silenceData.trimStart,
                    trimEnd: silenceData.trimEnd
                });
                trimmed++;
                console.log(`Trimmed: ${file.name} - Start: ${silenceData.trimStart.toFixed(2)}s, End: ${silenceData.trimEnd.toFixed(2)}s`);
            } else if (silenceData) {
                // No significant silence found, skip
                skipped++;
                console.log(`Skipped (no significant silence): ${file.name}`);
            } else {
                // Error processing file
                skipped++;
                console.log(`Skipped (error): ${file.name}`);
            }
            
            processed++;
            
            // Save every 10 songs to avoid data loss
            if (processed % 10 === 0) {
                await saveConfig();
            }
        }
        
        // Final save
        await saveConfig();
        
        statusEl.textContent = `âœ“ Complete: ${trimmed} trimmed, ${skipped} skipped`;
        statusEl.style.color = '#4CAF50';
        
        alert(`Auto-trim complete!\n\n${trimmed} songs were trimmed\n${skipped} songs were skipped (no significant silence or errors)`);
        
    } catch (error) {
        console.error('Error during auto-trim:', error);
        statusEl.textContent = 'âœ— Error occurred';
        statusEl.style.color = '#ff3333';
        alert('An error occurred during auto-trimming. Check console for details.');
    } finally {
        autoTrimBtn.disabled = false;
        autoTrimBtn.textContent = 'Run';
    }
}

window.addEventListener('load', async () => {
    normalizeBtn.classList.add('active');
    normalizeBtn.style.background = currentAccentGradient;
    normalizeBtn.style.color = '#1a1a1a';
    normalizeBtn.style.borderImage = 'none';
    
    // Initialize accent colors
    updateAccentColors(accentColor1, accentColor2);
    document.getElementById('songColorPickerWrapper').style.display = playerExpanded ? 'flex' : 'none';
    updateFavicon(accentColor1, accentColor2);
});

// Add these event listeners for the search inputs
document.getElementById('filterTagSearch').addEventListener('input', (e) => {
    handleTagSearch(e.target.value);
});

document.getElementById('songTagSearch').addEventListener('input', (e) => {
    handleTagSearch(e.target.value);
});

// Clear search on click
document.getElementById('filterTagSearch').addEventListener('click', (e) => {
    if (e.target.value) {
        clearTagSearch();
    }
});

document.getElementById('songTagSearch').addEventListener('click', (e) => {
    if (e.target.value) {
        clearTagSearch();
    }
});
// Optional: Clear search on Escape key
document.getElementById('filterTagSearch').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        clearTagSearch();
    }
});

document.getElementById('songTagSearch').addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        clearTagSearch();
    }
});

// Calculate perceptual brightness of a color
function getPerceptualBrightness(hexColor) {
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    return (0.299 * r) + (0.587 * g) + (0.114 * b);
}

function getBrighterColor(color1, color2) {
    const brightness1 = getPerceptualBrightness(color1);
    const brightness2 = getPerceptualBrightness(color2);
    return brightness1 > brightness2 ? color1 : color2;
}

// Mix multiple colors together with weights
function mixColors(colorWeightPairs) {
    if (colorWeightPairs.length === 0) return '#ff6b35';
    
    let totalR = 0, totalG = 0, totalB = 0, totalWeight = 0;
    
    colorWeightPairs.forEach(({ color, weight }) => {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        totalR += r * weight;
        totalG += g * weight;
        totalB += b * weight;
        totalWeight += weight;
    });
    
    const avgR = Math.round(totalR / totalWeight);
    const avgG = Math.round(totalG / totalWeight);
    const avgB = Math.round(totalB / totalWeight);
    
    return `#${avgR.toString(16).padStart(2, '0')}${avgG.toString(16).padStart(2, '0')}${avgB.toString(16).padStart(2, '0')}`;
}

// Get accent colors from song tags
function getAccentColorsFromTags(tags, filename = null) {
    // If we have a filename and cached colors exist, return them
    if (filename) {
        const config = getSongConfig(filename);
        if (config.cachedTagColor1 && config.cachedTagColor2) {
            return { 
                color1: config.cachedTagColor1, 
                color2: config.cachedTagColor2 
            };
        }
    }
    
    // No tags? Return default colors
    if (!tags || tags.length === 0) {
        return { color1: savedAccentColor1, color2: savedAccentColor2 };
    }
    
    // Collect tag colors and weights
    const tagColorData = tags
        .map(tag => {
            const tagInfo = masterTags[tag];
            if (!tagInfo) return null;
            
            const color = tagInfo.color || savedAccentColor1;
            const weight = tagInfo.weight || 5;
            
            return { color, weight };
        })
        .filter(item => item !== null);
    
    // No valid tag colors? Return default
    if (tagColorData.length === 0) {
        return { color1: savedAccentColor1, color2: savedAccentColor2 };
    }
    
    // Sort by brightness to separate into dark and light groups
    const brightnessArray = tagColorData.map(item => {
        const r = parseInt(item.color.slice(1, 3), 16);
        const g = parseInt(item.color.slice(3, 5), 16);
        const b = parseInt(item.color.slice(5, 7), 16);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return { ...item, brightness };
    });
    
    // Calculate median brightness
    const sortedByBrightness = [...brightnessArray].sort((a, b) => a.brightness - b.brightness);
    const midBrightness = sortedByBrightness[Math.floor(sortedByBrightness.length / 2)].brightness;
    
    // Split into darker and lighter colors
    const darkerColors = [];
    const lighterColors = [];
    
    tagColorData.forEach(item => {
        const r = parseInt(item.color.slice(1, 3), 16);
        const g = parseInt(item.color.slice(3, 5), 16);
        const b = parseInt(item.color.slice(5, 7), 16);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        
        if (brightness <= midBrightness) {
            darkerColors.push({ color: item.color, weight: item.weight });
        } else {
            lighterColors.push({ color: item.color, weight: item.weight });
        }
    });
    
    // Mix colors in each group
    const color1 = darkerColors.length > 0 ? mixColors(darkerColors) : savedAccentColor1;
    const color2 = lighterColors.length > 0 ? mixColors(lighterColors) : savedAccentColor2;
    
    // Cache the results if we have a filename
    if (filename) {
        const config = getSongConfig(filename);
        config.cachedTagColor1 = color1;
        config.cachedTagColor2 = color2;
        songConfig[filename] = config;
    }
    
    return { color1, color2 };
}
// Interpolate between two colors
function interpolateColor(color1, color2, factor) {
    const r1 = parseInt(color1.slice(1, 3), 16);
    const g1 = parseInt(color1.slice(3, 5), 16);
    const b1 = parseInt(color1.slice(5, 7), 16);
    const r2 = parseInt(color2.slice(1, 3), 16);
    const g2 = parseInt(color2.slice(3, 5), 16);
    const b2 = parseInt(color2.slice(5, 7), 16);
    
    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);
    
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Smooth color transition
async function transitionToColors(targetColor1, targetColor2) {
    if (isTransitioningColors) return;
    isTransitioningColors = true;
    
    const startColor1 = accentColor1;
    const startColor2 = accentColor2;
    const steps = 3;
    const stepDuration = 50; // 0.1 seconds
    
    for (let i = 1; i <= steps; i++) {
        const factor = i / steps;
        const newColor1 = interpolateColor(startColor1, targetColor1, factor);
        const newColor2 = interpolateColor(startColor2, targetColor2, factor);
        
        updateAccentColors(newColor1, newColor2);
        
        if (i < steps) {
            await new Promise(resolve => setTimeout(resolve, stepDuration));
        }
    }
    
    isTransitioningColors = false;
}

// Update colors based on current song tags
async function updateColorsFromCurrentSong() {
    if (!currentlyPlayingFile) return;
    
    const config = getSongConfig(currentlyPlayingFile.name);
    
    // If tag colors is OFF, always use global colors
    if (!useTagColors) {
        await transitionToColors(savedAccentColor1, savedAccentColor2);
        
        // Update the color picker dots to show current colors
        isUpdatingColorPickers = true;
        document.getElementById('songColor1Picker').value = savedAccentColor1;
        document.getElementById('songColor2Picker').value = savedAccentColor2;
        isUpdatingColorPickers = false;
        return;
    }
    
    // Tag colors is ON - check for custom colors first
    const hasCustomColor1 = config.customColor1;
    const hasCustomColor2 = config.customColor2;
    
    let color1, color2;
    
    if (hasCustomColor1 || hasCustomColor2) {
        // Priority 1: Use custom colors (with tag colors as fallback)
        const tags = config.tags || [];
        const tagColors = getAccentColorsFromTags(tags, currentlyPlayingFile.name);
        
        // Use custom color if available, otherwise use tag color
        color1 = hasCustomColor1 ? config.customColor1 : tagColors.color1;
        color2 = hasCustomColor2 ? config.customColor2 : tagColors.color2;
        
        await transitionToColors(color1, color2);
        
        // Update the color picker dots to show current colors
        isUpdatingColorPickers = true;
        document.getElementById('songColor1Picker').value = color1;
        document.getElementById('songColor2Picker').value = color2;
        isUpdatingColorPickers = false;
        return;
    }
    
    // Priority 2: Tag-based colors (no custom colors set)
    const tags = config.tags || [];
    const { color1: tagColor1, color2: tagColor2 } = getAccentColorsFromTags(tags, currentlyPlayingFile.name);
    await transitionToColors(tagColor1, tagColor2);
    
    // Update the color picker dots to show current colors
    isUpdatingColorPickers = true;
    document.getElementById('songColor1Picker').value = tagColor1;
    document.getElementById('songColor2Picker').value = tagColor2;
    isUpdatingColorPickers = false;
}

// Open tag colors modal
function openTagColorsModal() {
    document.getElementById('tagColorsOverlay').style.display = 'flex';
    renderTagColorsList();
}

// Close tag colors modal
function closeTagColorsModal() {
    document.getElementById('tagColorsOverlay').style.display = 'none';
}

// Render the tag colors list
function renderTagColorsList(searchQuery = '') {
    const container = document.getElementById('tagColorsList');
    container.innerHTML = '';
    
    const tags = Object.keys(masterTags).filter(tag => {
        if (!searchQuery) return true;
        return tag.toLowerCase().includes(searchQuery.toLowerCase());
    });
    
    tags.sort();
    
    tags.forEach(tagName => {
        const tagData = masterTags[tagName];
        const currentColor = tagData.color || '#ff6b35';
        const currentWeight = tagData.weight || 5;
        
        const item = document.createElement('div');
        item.className = 'tag-color-item';
        
        item.innerHTML = `
            <div class="tag-color-name">${tagName} (${tagData.songCount})</div>
            <div class="tag-color-picker-wrapper">
                <input type="color" value="${currentColor}" data-tag="${tagName}" class="tag-color-input">
            </div>
            <div class="tag-weight-container">
                <span class="tag-weight-label">Weight: <span class="weight-value">${currentWeight}</span></span>
                <input type="range" min="1" max="10" value="${currentWeight}" 
                       class="tag-weight-slider" data-tag="${tagName}">
            </div>
        `;
        
        container.appendChild(item);
    });
    
    // Add event listeners for color pickers
    document.querySelectorAll('.tag-color-input').forEach(input => {
        input.addEventListener('change', async (e) => {
            const tagName = e.target.dataset.tag;
            const color = e.target.value;
            
            if (!masterTags[tagName]) masterTags[tagName] = { songCount: 0 };
            masterTags[tagName].color = color;
            if (!masterTags[tagName].weight) masterTags[tagName].weight = 5;
            
            // Invalidate cache for all songs with this tag
            invalidateTagColorCacheForTag(tagName);
            
            await saveConfig();
            
            // Update colors if using tag colors
            if (useTagColors) {
                updateColorsFromCurrentSong();
            }
        });
    });
    
    // Add event listeners for weight sliders
    document.querySelectorAll('.tag-weight-slider').forEach(slider => {
        slider.addEventListener('input', (e) => {
            const value = e.target.value;
            e.target.parentElement.querySelector('.weight-value').textContent = value;
        });
        
        slider.addEventListener('change', async (e) => {
            const tagName = e.target.dataset.tag;
            const weight = parseInt(e.target.value);
            
            if (!masterTags[tagName]) masterTags[tagName] = { songCount: 0 };
            masterTags[tagName].weight = weight;
            if (!masterTags[tagName].color) masterTags[tagName].color = '#ff6b35';
            
            // Invalidate cache for all songs with this tag
            invalidateTagColorCacheForTag(tagName);
            
            await saveConfig();
            
            // Update colors if using tag colors
            if (useTagColors) {
                updateColorsFromCurrentSong();
            }
        });
    });
}

async function refreshMetadataCache() {
    if (!configDirHandle || !originalOrder || originalOrder.length === 0) {
        alert('Please select a music folder first');
        return;
    }
    
    const refreshBtn = document.getElementById('refreshMetadataBtn');
    const statusEl = document.getElementById('metadataCacheStatus');
    
    if (!confirm(`This will re-scan metadata for all ${originalOrder.length} songs and update the config. Continue?`)) {
        return;
    }
    
    refreshBtn.disabled = true;
    refreshBtn.textContent = 'Scanning...';
    statusEl.textContent = 'Scanning...';
    
    // Re-scan all songs
    let loaded = 0;
    for (const file of originalOrder) {
        await readSongMetadata(file);
        loaded++;
        
        if (loaded % 10 === 0) {
            statusEl.textContent = `Scanning ${loaded}/${originalOrder.length}...`;
        }
    }
    
    // Save updated config
    await saveConfig();
    
    refreshBtn.disabled = false;
    refreshBtn.textContent = 'Refresh Metadata';
    statusEl.textContent = `âœ“ Refreshed ${originalOrder.length} songs`;
    statusEl.style.color = '#4CAF50';
    
    // Re-sort if currently sorted by album
    if (sortBy === 'album') {
        updateAudioFilesList();
    }
}
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('ServiceWorker registered:', registration.scope);
            })
            .catch(err => {
                console.log('ServiceWorker registration failed:', err);
            });
    });
}

    </script>
</body>
</html>