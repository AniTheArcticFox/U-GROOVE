<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="U-Groove">
    <link rel="icon" type="image/svg+xml" href="" id="dynamicFavicon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>
    <title>U-Groove</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e0e0e0;
        }

        .container {
            background: #1a1a1a;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            max-width: 1200px;
            width: 100%;
            padding: 30px;
            border: 1px solid #ff6b35;
            padding-bottom: 400px;
        }

        h1 {
            text-align: center;
            color: #ff6b35;
            font-size: 28px;
        }
        h3 {
            text-align: center;
            color: #ff6b35;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .color-picker-container {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-picker-label {
            color: #e0e0e0;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .color-picker-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .color-picker-wrapper input[type="color"] {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 50px;
            height: 50px;
            border: none;
            cursor: pointer;
        }

        .folder-section {
            margin-bottom: 25px;
        }

        .main-content {
            display: flex;
            gap: 30px;
            margin-bottom: 25px;
        }

        .visualizer-section {
            flex: 0 0 300px;
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .duration-control {
            margin-bottom: 15px;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff6b35;
        }

        .duration-control label {
            display: block;
            color: #ffffff;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .duration-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #3a3a3a;
            outline: none;
            -webkit-appearance: none;
        }

        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff6b35;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        .duration-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff6b35;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        .visualizer-canvas {
            background: #0f0f0f;
            border-radius: 10px;
            border: 1px solid #ff6b35;
            width: 100%;
            height: 400px;
        }

        .playlist-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .folder-btn {
            width: 100%;
            padding: 15px;
            background: #2a2a2a;
            color: #ff6b35;
            border: 2px solid #ff6b35;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .folder-btn:hover {
            background: #ff6b35;
            color: #1a1a1a;
        }
        .help{
            background: #2a2a2a;
            color: #ff6b35;
            font-size: 2rem;
            transition: all 0.3s;
        }

        .help:hover {
            background: #ff6b35;
            color: #2a2a2a;
            
        }

        .playlist {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ff6b35;
            border-radius: 10px;
            background: #0f0f0f;
            margin-bottom: 15px;
        }

        .playlist-item {
            padding: 12px 15px;
            border-bottom: 1px solid #2a2a2a;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            color: #e0e0e0;
        }

        .playlist-item:last-child {
            border-bottom: none;
        }

        .playlist-item:hover {
            background: #2a2a2a;
        }

        .playlist-item.active {
            background: #ff6b35;
            color: #1a1a1a;
            font-weight: bold;
        }

        .playlist-item.playing::before {
            content: "‚ô™ ";
            margin-right: 8px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

.player-section {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 85%;
    max-width: 800px;
    background: rgba(26, 26, 26, 0.98);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid #ff6b35;
    box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.8);
    z-index: 1000;
}

.now-playing {
    text-align: center;
    margin-bottom: 10px;
    color: #ff6b35;
    font-size: 14px;
    font-weight: 500;
}

.controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}

.secondary-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
}

        .control-btn {
            background: #3a3a3a;
            color: #ff6b35;
            border: 2px solid #ff6b35;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: #ff6b35;
            color: #1a1a1a;
            transform: scale(1.1);
        }

        .control-btn.play-pause {
            width: 45px;
            height: 45px;
            font-size: 24px;
        }

        .control-btn.active {
            background: #ff6b35;
            color: #1a1a1a;
        }

        .progress-container {
            width: 100%;
            background: #3a3a3a;
            height: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: #ff6b35;
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #999;
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }

        .section-label {
            display: block;
            color: #ff6b35;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        .filter-section {
            margin-bottom: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 10px;
            border: 1px solid #ff6b35;
        }

                .search-section {
            margin-bottom: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 10px;
            border: 1px solid #ff6b35;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            background: #1a1a1a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: #ff6b35;
        }

        .search-input::placeholder {
            color: #666;
        }

        .tagging-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ff6b35;
            margin-bottom: 25px;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            overflow-y: scroll;
            max-height: 200px;
        }

        .tag-pill {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid #ff6b35;
            background: transparent;
            color: #ff6b35;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-pill:hover {
            background: #ff6b3540;
        }

        .tag-pill.active {
            background: #ff6b35;
            color: #1a1a1a;
            font-weight: 600;
        }

        .tag-pill.active::before {
            content: "‚úì ";
        }

        .add-tag-btn {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px dashed #ff6b35;
            background: transparent;
            color: #ff6b35;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-tag-btn:hover {
            background: #ff6b3520;
        }

        .tag-input {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid #ff6b35;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 13px;
            outline: none;
            min-width: 120px;
        }

        .save-tags-btn {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #ff6b35;
            background: #ff6b35;
            color: #1a1a1a;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-tags-btn:hover {
            background: #ff8c42;
            border-color: #ff8c42;
        }

        .save-tags-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #999;
            font-size: 14px;
            font-style: italic;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #3a3a3a;
            border-top-color: #ff6b35;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .playlist-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .playlist {
            flex: 1;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ff6b35;
            border-radius: 10px;
            background: #0f0f0f;
        }

        .playback-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #3a3a3a;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: #ff6b35;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .playback-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #3a3a3a;
            outline: none;
            -webkit-appearance: none;
        }

        .playback-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff6b35;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        .playback-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff6b35;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
        }

        audio {
            display: none;
        }

        .collapsible-section {
    position: relative;
}

.collapse-handle {
    background: transparent;
    border: none;
    color: #ff6b35;
    cursor: pointer;
    font-size: 18px;
    padding: 0;
    margin-left: 10px;
    transition: transform 0.3s;
    display: inline-block;
    vertical-align: middle;
}

.collapse-handle:hover {
    opacity: 0.7;
}

.collapse-handle.collapsed {
    transform: rotate(-90deg);
}

.collapsible-content {
    max-height: 500px;
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
    opacity: 1;
}

.collapsible-content.collapsed {
    max-height: 0;
    opacity: 0;
    margin: 0 !important;
}

.player-section.collapsed {
    padding: 15px 20px;
}

.player-section.collapsed .controls {
    margin-bottom: 0;
}
.player-section.collapsed .trim-btn {
    display: none;
}

.player-compact {
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 20px;
}

.player-section.collapsed .player-compact {
    display: flex;
}

.player-compact-left {
    flex: 1;
    min-width: 0;
    text-align: left;
}

.player-compact-center {
    display: flex;
    gap: 15px;
    align-items: center;
}

.player-compact-right {
    flex: 1;
    min-width: 0;
    text-align: right;
}

.player-compact-title {
    color: #ff6b35;
    font-size: 14px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-compact-time {
    color: #999;
    font-size: 12px;
    white-space: nowrap;
}

.player-section.collapsed .controls,
.player-section.collapsed .now-playing,
.player-section.collapsed .progress-container,
.player-section.collapsed .time-display,
.player-section.collapsed .secondary-controls,
.player-section.collapsed .playback-controls {
    display: none;
}

.section-header {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
}

.speed-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.speed-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
}

.fade-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.fade-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
}

.fade-save-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.save-fades-btn {
    padding: 4px 10px;
    border-radius: 5px;
    border: 1px solid #ff6b35;
    background: transparent;
    color: #ff6b35;
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s;
    white-space: nowrap;
}

.save-fades-btn:hover {
    background: #ff6b3540;
}

.speed-save-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.save-speed-btn {
    padding: 4px 10px;
    border-radius: 5px;
    border: 1px solid #ff6b35;
    background: transparent;
    color: #ff6b35;
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s;
    white-space: nowrap;
}

.save-speed-btn:hover {
    background: #ff6b3540;
}

.checkbox-wrapper {
    display: flex;
    align-items: center;
    gap: 5px;
}

.checkbox-wrapper input[type="checkbox"] {
    width: 14px;
    height: 14px;
    cursor: pointer;
    accent-color: #ff6b35;
}

.checkbox-wrapper label {
    font-size: 11px;
    color: #e0e0e0;
    cursor: pointer;
    text-transform: none;
    margin: 0;
}

.speed-value-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}

.speed-arrow-btn {
    background: #3a3a3a;
    color: #ff6b35;
    border: 1px solid #ff6b35;
    border-radius: 5px;
    width: 24px;
    height: 24px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
}

.speed-arrow-btn:hover {
    background: #ff6b3540;
}

.toggle-switch-container {
    display: flex;
    gap: 15px;
    margin-bottom: 12px;
    align-items: center;
}

.toggle-switch {
    display: flex;
    border: 2px solid;
    border-radius: 20px;
    overflow: hidden;
    background: #1a1a1a;
}

.toggle-option {
    padding: 6px 16px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    transition: all 0.2s;
    border: none;
    background: transparent;
}

.toggle-option.active {
    color: #1a1a1a;
}

.visualizer-controls-section {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 15px;
}

.visualizer-control-group {
    margin-bottom: 12px;
}

.visualizer-control-group:last-child {
    margin-bottom: 0;
}

.visualizer-control-group label {
    display: block;
    color: #e0e0e0;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 6px;
    text-transform: uppercase;
}

.visualizer-control-slider {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: #3a3a3a;
    outline: none;
    -webkit-appearance: none;
}

.visualizer-control-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
}

.visualizer-control-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.visualizer-toggle-btn {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    border: 2px solid;
    background: transparent;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    margin-bottom: 12px;
}

.visualizer-toggle-btn:hover {
    opacity: 0.8;
}

#bubbleCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.sort-select:focus {
    border-color: #ff6b35;
}

.sort-order-btn:hover,
.scroll-to-song-btn:hover {
    background: #3a3a3a;
    border-color: #ff6b35;
}

.sort-select option {
    background: #2a2a2a;
    color: #e0e0e0;
}
.song-counter {
    text-align: center;
    padding: 10px;
    color: #888;
    font-size: 13px;
    font-weight: 500;
    background: #0f0f0f;
    border: 1px solid #ff6b35;
    border-radius: 10px;
    margin-top: -1px;
    margin-bottom: 15px;
}

.trim-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.trim-overlay.active {
    display: flex;
}

.trim-window {
    background: #1a1a1a;
    border: 2px solid #ff6b35;
    border-radius: 15px;
    padding: 20px;
    width: 90%;
    max-width: 1000px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
}

.trim-header {
    text-align: center;
    color: #ff6b35;
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}

.trim-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
}

.trim-zoom-btn {
    padding: 8px 15px;
    background: #2a2a2a;
    border: 2px solid #ff6b35;
    border-radius: 8px;
    color: #ff6b35;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

.trim-zoom-btn:hover {
    background: #ff6b35;
    color: #1a1a1a;
}

.trim-time-display {
    flex: 1;
    display: flex;
    justify-content: space-around;
    color: #e0e0e0;
    font-size: 13px;
}

.trim-waveform-container {
    position: relative;
    background: #0f0f0f;
    border: 1px solid #ff6b35;
    border-radius: 10px;
    height: 300px;
    margin-bottom: 15px;
    overflow: hidden;
    cursor: grab;
}

.trim-waveform-container:active {
    cursor: grabbing;
}

.trim-waveform-canvas {
    width: 100%;
    height: 100%;
}

.trim-handle {
    position: absolute;
    top: 0;
    width: 3px;
    height: 100%;
    background: #ff6b35;
    cursor: ew-resize;
    z-index: 10;
}

.trim-handle::before {
    content: '';
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 60px;
    background: #353535;
    border: solid 2px white;
    border-radius: 10px;
    margin-left: -8.5px;
}

.trim-handle.start {
    left: 0;
}

.trim-handle.end {
    right: 0;
}

.trim-region {
    position: absolute;
    top: 0;
    height: 100%;
    background: rgba(255, 107, 53, 0.1);
    border-left: 3px solid #ff6b35;
    border-right: 3px solid #ff6b35;
    pointer-events: none;
}

.trim-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.trim-action-btn {
    padding: 12px 30px;
    border-radius: 8px;
    border: 2px solid #ff6b35;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.trim-cancel-btn {
    background: transparent;
    color: #ff6b35;
}

.trim-cancel-btn:hover {
    background: #ff6b3540;
}

.trim-save-btn {
    background: #ff6b35;
    color: #1a1a1a;
}

.trim-save-btn:hover {
    background: #ff8c42;
    border-color: #ff8c42;
}

.trim-btn {
    padding: 10px 20px;
    background: #2a2a2a;
    border: 2px solid #ff6b35;
    border-radius: 8px;
    color: #ff6b35;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
    margin-bottom: 10px;
}

.trim-btn:hover {
    background: #ff6b35;
    color: #1a1a1a;
}

.tag-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
    align-items: center;
}

.tag-category-select,
.tag-sort-select {
    padding: 8px 12px;
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 12px;
    outline: none;
    cursor: pointer;
    flex: 1;
}

.tag-category-select:focus,
.tag-sort-select:focus {
    border-color: #ff6b35;
}

.tag-sort-order-btn {
    padding: 8px 12px;
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 12px;
    cursor: pointer;
    min-width: 40px;
}

.tag-sort-order-btn:hover {
    background: #3a3a3a;
    border-color: #ff6b35;
}

.collapsible-section.collapsed .tag-controls {
    display: none;
}

.multi-select-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
    align-items: center;
}

.multi-select-btn,
.select-all-btn {
    padding: 8px 15px;
    background: #2a2a2a;
    border: 2px solid #3a3a3a;
    border-radius: 8px;
    color: #e0e0e0;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 600;
}

.multi-select-btn.active {
    border-color: #ff6b35;
    background: #ff6b35;
    color: #1a1a1a;
}

.multi-select-btn:hover,
.select-all-btn:hover {
    background: #3a3a3a;
    border-color: #ff6b35;
}

.playlist-item-checkbox {
    width: 18px;
    height: 18px;
    margin-right: 10px;
    cursor: pointer;
    accent-color: #ff6b35;
    flex-shrink: 0;
}

.playlist-item.has-checkbox {
    display: flex;
    align-items: center;
}

.playlist-item-text {
    flex: 1;
    cursor: pointer;
}

.collapsible-section.collapsed .multi-select-controls {
    display: none;
}

.settings-section {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 10px;
    border: 1px solid #ff6b35;
    margin-bottom: 15px;
}

.setting-item {
    padding: 12px;
    border: 1px solid #3a3a3a;
    border-radius: 8px;
    background: #1a1a1a;
    margin-bottom: 10px;
}

.setting-item:last-child {
    margin-bottom: 0;
}

.setting-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
}

.setting-title {
    color: #e0e0e0;
    font-size: 14px;
    font-weight: 600;
    margin: 0;
}

.setting-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #ff6b35;
}

.setting-subtitle {
    color: #999;
    font-size: 12px;
    line-height: 1.5;
    margin: 0;
}
.merge-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 12px;
}

.merge-buttons-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
}

.json-select-btn {
    padding: 10px 20px;
    border-radius: 8px;
    border: 2px solid #ff6b35;
    background: transparent;
    color: #ff6b35;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    transition: all 0.2s;
    min-width: 100px;
}

.json-select-btn:hover {
    background: #ff6b3540;
}

.json-select-btn.selected {
    background: linear-gradient(135deg, #ff6b35, #ff8c42);
    color: #1a1a1a;
    border-color: #ff6b35;
}

.merge-arrow {
    color: #ff6b35;
    font-size: 20px;
    font-weight: bold;
}

.merge-action-btn {
    padding: 12px 30px;
    border-radius: 8px;
    border: 2px solid #ff6b35;
    background: #ff6b35;
    color: #1a1a1a;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
    align-self: center;
}

.merge-action-btn:hover:not(:disabled) {
    background: #ff8c42;
    border-color: #ff8c42;
}

.merge-action-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: transparent;
    color: #ff6b35;
}

.json-file-info {
    color: #999;
    font-size: 11px;
    text-align: center;
    font-style: italic;
}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="color-picker-container">
            <span class="color-picker-label">Accent</span>
            <div class="color-picker-wrapper">
                <input type="color" id="accentColorPicker1" value="#ff6b35">
            </div>
            <div class="color-picker-wrapper">
                <input type="color" id="accentColorPicker2" value="#ff8c42">
            </div>
        </div>
        <div style="display: flex; justify-content: space-between;">
                <svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 197.09 197.09' style="width: 60px; height: 60px;" id="headerLogo">
                    <defs>
                        <linearGradient id='lg1' x1='18.3' y1='51.83' x2='178.93' y2='144.58' gradientUnits='userSpaceOnUse'>
                            <stop offset='0' stop-color="#ff6b35"/>
                            <stop offset='1' stop-color="#ff8c42"/>
                        </linearGradient>
                        <linearGradient id='lg2' x1='96.76' y1='67.87' x2='124.81' y2='84.06' xlink:href='#lg1'/>
                        <linearGradient id='lg3' x1='96.76' y1='126.45' x2='124.81' y2='142.64' gradientTransform='translate(221.95 .32) rotate(79.1)' xlink:href='#lg1'/>
                        <linearGradient id='lg4' x1='47.35' y1='68.57' x2='161.33' y2='134.37' xlink:href='#lg1'/>
                    </defs>
                    <circle fill='#231f20' cx='98.55' cy='98.55' r='98.55'/>
                    <circle fill='url(#lg1)' cx='98.61' cy='98.2' r='92.73'/>
                    <circle fill='#231f20' cx='99.87' cy='98.47' r='87.1'/>
                    <circle fill='url(#lg2)' cx='110.78' cy='75.97' r='16.19'/>
                    <circle fill='url(#lg3)' cx='110.78' cy='134.55' r='16.19' transform='translate(-42.28 217.89) rotate(-79.1)'/>
                    <path fill='url(#lg4)' d='M51.64,144.55c.05,1.91.18,5.43,2.5,7.95,1.12,1.22,3.58,3.14,6.82,4.09,1.33.39,10.31,3.02,15.91-2.73,3.01-3.09,3.47-7.24,3.64-9.32,2.12-25.98,2.03-72.69,2.05-76.36,0-.26,0-.67.05-1.22.76-9.69,10.47-15.74,11.05-16.09,3.91-2.36,7.38-2.91,11.22-3.52,4.04-.64,9.8-.55,15,.65,2.09.48,8.28,4.04,9.78,6.65.38.67,4.02,5.14,4.43,11.61.08,1.23.02,2.17,0,2.48-.86,14.19,1.91,73.11,1.04,79.43-.03.19-.13.9,0,1.83.37,2.54,2.22,4.23,2.61,4.57,3.37,2.93,9.58,2.44,12.13-.52,1-1.17,1.24-2.49,1.3-2.87,2.05-12.34-1.11-68.62-.78-83.35,0-.41.03-1,0-1.83-.29-9.3-5.01-18.76-11.74-24.65-6.05-5.3-12.08-7.35-22.57-8.22-14.15-1.18-26.53-.25-34.83,1.57-9.16,2-12.33,4.76-14.45,6.29-5.77,4.19-8.82,8.82-10.99,13.01-1.5,2.89-4.57,8.97-4.83,17.09-.03,1.09,0,1.9,0,2.22.21,7.42.12,50.09.64,71.24Z'/>
                </svg>
            <div>
                        <h1>U-GROOVE</h1>
                        <h3>Fine Tune Your Vibe</h3>
            </div>
            <button class="help" style="border: solid #ff6b35 2px; border-radius: 100px; height: 55px; width: 55px; display: flex; align-items: center; justify-content: center;">
                ?
            </button>
        </div>

        
        <div class="folder-section">
            <button class="folder-btn" onclick="selectFolder()">Select Music Folder</button>
        </div>

        <div class="main-content">
            <div style="max-width: 35%;">
            <div class="visualizer-section">
                <div class="visualizer-controls-section collapsible-section">
                    <div class="section-header">
                        <label class="section-label" style="margin-bottom: 0;">Visualizer Controls</label>
                        <button class="collapse-handle" onclick="toggleCollapse('visualizer')" id="visualizerCollapseBtn">‚ñº</button>
                    </div>
                    <div class="collapsible-content" id="visualizerContent">
                        <button class="visualizer-toggle-btn" id="visualizerToggleBtn" onclick="toggleVisualizer()">Visualizer: ON</button>
                        
                        <div class="toggle-switch-container">
                            <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Mode:</label>
                            <div class="toggle-switch" id="visualizerModeSwitch">
                                <button class="toggle-option active" onclick="setVisualizerMode('frequency')">Frequency</button>
                                <button class="toggle-option" onclick="setVisualizerMode('waveform')">Waveform</button>
                                <button class="toggle-option" onclick="setVisualizerMode('bubble')">Bubble</button>
                            </div>
                        </div>

                        <div id="frequencyControls">
                            <div class="visualizer-control-group">
                                <label for="minFreqSlider">Min Frequency: <span id="minFreqValue">20</span> Hz</label>
                                <input type="range" id="minFreqSlider" class="visualizer-control-slider" min="20" max="2000" value="20">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="maxFreqSlider">Max Frequency: <span id="maxFreqValue">20000</span> Hz</label>
                                <input type="range" id="maxFreqSlider" class="visualizer-control-slider" min="1000" max="20000" value="20000">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="minHeightSlider">Min Bar Height: <span id="minHeightValue">0</span>%</label>
                                <input type="range" id="minHeightSlider" class="visualizer-control-slider" min="0" max="50" value="0">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="maxHeightSlider">Max Bar Height: <span id="maxHeightValue">100</span>%</label>
                                <input type="range" id="maxHeightSlider" class="visualizer-control-slider" min="50" max="100" value="100">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="durationSlider">Response Time: <span id="durationValue">50</span>ms</label>
                                <input type="range" id="durationSlider" class="duration-slider" min="10" max="1000" value="50">
                            </div>
                        </div>

                        <div id="waveformControls" style="display: none;">
                            <div class="visualizer-control-group">
                                <label for="waveformSensitivitySlider">Waveform Zoom: <span id="waveformSensitivityValue">5.0</span>x</label>
                                <input type="range" id="waveformSensitivitySlider" class="duration-slider" min="0.5" max="20.0" step="0.1" value="5.0">
<span id="waveformSensitivityValue">5.0x</span>
                            </div>
                        </div>
                        <div id="bubbleControls" style="display: none;">
                            <div class="visualizer-control-group">
                                <label for="bubbleMinFreqSlider">Min Frequency: <span id="bubbleMinFreqValue">20</span> Hz</label>
                                <input type="range" id="bubbleMinFreqSlider" class="visualizer-control-slider" min="20" max="2000" value="20">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="bubbleMaxFreqSlider">Max Frequency: <span id="bubbleMaxFreqValue">20000</span> Hz</label>
                                <input type="range" id="bubbleMaxFreqSlider" class="visualizer-control-slider" min="1000" max="20000" value="20000">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="bubbleComplexitySlider">Complexity: <span id="bubbleComplexityValue">2</span></label>
                                <input type="range" id="bubbleComplexitySlider" class="visualizer-control-slider" min="1" max="5" value="2" step="0.1">
                            </div>
                            <div class="visualizer-control-group">
                                <label for="bubbleFluiditySlider">Fluidity: <span id="bubbleFluidityValue">0.5</span></label>
                                <input type="range" id="bubbleFluiditySlider" class="visualizer-control-slider" min="0.01" max="1" value="0.5" step="0.01">
                            </div>
                        </div>
                    </div>
                </div>
                <canvas id="visualizer" class="visualizer-canvas"></canvas>
            </div>

            <div class="settings-section">
                <label class="section-label">Advanced Controls</label>
                
                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Prioritize New Songs</h4>
                        <input type="checkbox" id="prioritizeNewSongsCheckbox" class="setting-checkbox" onchange="togglePrioritizeNewSongs()">
                    </div>
                    <p class="setting-subtitle">This will skip over any songs you have previously heard on the app, as long as there are unheard songs in your current list. If every song in your folder has been played at least once, it will treat every song like new again.</p>
                </div>

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Merge JSON Configs</h4>
                    </div>
                    <p class="setting-subtitle">If you use this app with two separate song folders, merge them together here. Select whichever JSON file is OLDER with the JSON 1 button, then select whichever JSON file is NEWER with the JSON 2 button, then click merge.</p>
                    
                    <div class="merge-controls">
                        <div class="merge-buttons-row">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                                <button class="json-select-btn" id="json1Btn" onclick="selectJsonFile(1)">JSON 1</button>
                                <span class="json-file-info" id="json1Info">No file selected</span>
                            </div>
                            <span class="merge-arrow">‚Üê</span>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                                <button class="json-select-btn" id="json2Btn" onclick="selectJsonFile(2)">JSON 2</button>
                                <span class="json-file-info" id="json2Info">No file selected</span>
                            </div>
                        </div>
                        <button class="merge-action-btn" id="mergeBtn" onclick="mergeJsonFiles()" disabled>Merge</button>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Calculate Setlist Lengths</h4>
                    </div>
                    <p class="setting-subtitle">If you want to see how long it would take to play all the songs in the songs list, this will calculate the length of all the songs in your selected folder and display the cumulative length based on the songs available. Note that there may be some latency while this function runs depending on how many songs you have.</p>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="calculateDurationsBtn" onclick="calculateAllDurations()" style="width: auto; min-width: 120px;">Run</button>
                        <p class="json-file-info" id="durationStatus" style="margin-top: 8px;">Not yet calculated</p>
                    </div>
                </div>

                <!-- <div class="setting-item">
                    <div class="setting-header">
                        <h4 class="setting-title">Write Song Edits to Copies</h4>
                    </div>
                    <p class="setting-subtitle">If you would like to apply the speed, trim, and fading changes you've made to all of your songs, this option will create a duplicate file with the changes made directly to the audio file, save the same tags as the original song to this new copy, and replace the tags of the old song with a single tag, 'Original from duped', that will be excluded by default. These duped songs will be moved to a separate folder in your songs folder.</p>
                    
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="merge-action-btn" id="writeSongEditsBtn" onclick="writeSongEdits()" style="width: auto; min-width: 120px;">Write Edits</button>
                        <p class="json-file-info" id="writeEditsStatus" style="margin-top: 8px;">Calculating...</p>
                    </div>
                </div> -->
            </div>
        </div>
            <div class="playlist-wrapper" style="width: 50%;">
<div class="filter-section collapsible-section">
    <div class="section-header">
        <label class="section-label" style="margin-bottom: 0;">Filter by Tags</label>
        <button class="collapse-handle" onclick="toggleCollapse('filter')" id="filterCollapseBtn">‚ñº</button>
    </div>
    <div class="collapsible-content" id="filterContent">
        <div class="tag-controls">
            <select id="filterCategorySelect" class="tag-category-select" onchange="changeTagCategory(this.value)">
                <option value="All">All Categories</option>
                <option value="Artist">Artists</option>
                <option value="Genre">Genres</option>
                <option value="Vibe">Vibes</option>
                <option value="Instrument">Instruments</option>
                <option value="Album">Albums</option>
                <option value="Utility">Utility</option>
            </select>
            <select id="filterSortSelect" class="tag-sort-select" onchange="changeTagSort(this.value)">
                <option value="alphabetical">A-Z</option>
                <option value="songCount">Song Count</option>
            </select>
            <button class="tag-sort-order-btn" id="filterSortOrderBtn" onclick="toggleTagSortOrder()">‚Üì</button>
        </div>
        <div class="toggle-switch-container" style="flex-wrap: wrap;">
            <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Select:</label>
            <div class="toggle-switch" id="tagSelectSwitch">
                <button class="toggle-option active" onclick="setTagSelectMode('single')">Single</button>
                <button class="toggle-option" onclick="setTagSelectMode('multi')">Multi</button>
            </div>
            <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Match:</label>
            <div class="toggle-switch" id="tagMatchSwitch">
                <button class="toggle-option active" onclick="setTagMatchMode('and')">AND</button>
                <button class="toggle-option" onclick="setTagMatchMode('or')">OR</button>
            </div>
                <label style="color: #e0e0e0; font-size: 11px; font-weight: 600;">Mode:</label>
                <div class="toggle-switch" id="tagFilterModeSwitch">
                    <button class="toggle-option active" onclick="setTagFilterMode('include')">Include</button>
                    <button class="toggle-option" onclick="setTagFilterMode('exclude')">Exclude</button>
                </div>
        </div>
        <div class="tag-list" id="filterTags">
            <button class="tag-pill active" onclick="selectFilterTag('all')">All</button>
        </div>
    </div>
</div>
                <div class="search-section">
                    <input type="text" class="search-input" id="searchInput" placeholder="Search songs...">
                </div>

                <div class="sort-section" style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <div style="flex: 1; display: flex; gap: 8px;">
                        <select id="sortSelect" class="sort-select" style="flex: 1; padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; outline: none; cursor: pointer;">
                            <option value="name">Sort by Name</option>
                            <option value="modified">Sort by Date Modified</option>
                            <option value="size">Sort by File Size</option>
                        </select>
                        <button class="sort-order-btn" id="sortOrderBtn" onclick="toggleSortOrder()" style="padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; min-width: 45px;">‚Üì</button>
                    </div>
                    <button class="scroll-to-song-btn" onclick="scrollToCurrentSong()" style="padding: 10px 15px; background: #2a2a2a; border: 2px solid #3a3a3a; border-radius: 8px; color: #e0e0e0; font-size: 14px; cursor: pointer; white-space: nowrap;">üìç Scroll to Song</button>
                </div>
       <div class="song-counter" id="songCounter">
            0 songs
        </div>
    <div class="playlist" id="playlist">
        </div>
 

        <div class="tagging-section collapsible-section">
    <div class="section-header">
        <label class="section-label" style="margin-bottom: 0;">
            Add tags to song 
        </label>
        <button class="collapse-handle" onclick="toggleCollapse('tagging')" id="taggingCollapseBtn">‚ñº</button>
    </div>
<div class="collapsible-content" id="taggingContent">
    <div class="multi-select-controls">
        <button class="multi-select-btn" id="multiSelectBtn" onclick="toggleMultiSelect()">Multi-Select</button>
        <button class="select-all-btn" id="selectAllBtn" onclick="toggleSelectAll()" style="display: none;">Select All</button>
    </div>
            <div class="tag-controls">
            <select id="songCategorySelect" class="tag-category-select" onchange="changeTagCategory(this.value)">
                <option value="All">All Categories</option>
                <option value="Artist">Artists</option>
                <option value="Genre">Genres</option>
                <option value="Vibe">Vibes</option>
                <option value="Instrument">Instruments</option>
                <option value="Album">Albums</option>
                <option value="Utility">Utility</option>
            </select>
            <select id="songSortSelect" class="tag-sort-select" onchange="changeTagSort(this.value)">
                <option value="alphabetical">A-Z</option>
                <option value="songCount">Song Count</option>
            </select>
            <button class="tag-sort-order-btn" id="songSortOrderBtn" onclick="toggleTagSortOrder()">‚Üì</button>
        </div>
        <div class="tag-list" id="songTags">
            <button class="add-tag-btn" onclick="showTagInput()">+ Add Tag</button>
        </div>
    </div>
</div>

<div class="player-section" id="playerSection">
    <button class="collapse-handle" onclick="toggleCollapse('player')" id="playerCollapseBtn" style="position: absolute; top: 15px; right: 15px; z-index: 10;">‚ñº</button>
    
    <!-- Compact view (shown when collapsed) -->
    <div class="player-compact">
        <div class="player-compact-left">
            <div class="player-compact-title" id="compactTitle">No track playing</div>
        </div>
        <div class="player-compact-center">
            <button class="control-btn" onclick="previousTrack()" title="Previous">‚Æú</button>
            <button class="control-btn play-pause" onclick="togglePlay()" id="playBtnCompact" title="Play/Pause">‚ñ∂</button>
            <button class="control-btn" onclick="nextTrack()" title="Next">‚Æû</button>
        </div>
        <div class="player-compact-right">
            <div class="player-compact-time" id="compactTime">0:00 / 0:00</div>
        </div>
    </div>

    <!-- Full view (shown when expanded) -->
    <!-- Primary controls (back, play, skip) -->
    <div class="controls">
        <button class="control-btn" onclick="previousTrack()" title="Previous">‚Æú</button>
        <button class="control-btn play-pause" onclick="togglePlay()" id="playBtn" title="Play/Pause">‚ñ∂</button>
        <button class="control-btn" onclick="nextTrack()" title="Next">‚Æû</button>
    </div>

    <!-- Now playing and progress -->
    <div class="now-playing" id="nowPlaying">No track playing</div>
    
    <div class="progress-container" onclick="seekAudio(event)">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <div class="time-display">
        <span id="currentTime">0:00</span>
        <span id="duration">0:00</span>
    </div>
    <!-- Secondary controls (shuffle, loop, normalize) -->
    <div class="secondary-controls">
        <button class="control-btn" onclick="toggleShuffle()" id="shuffleBtn" title="Shuffle">üîÄ</button>
        <button class="control-btn" onclick="toggleLoop()" id="loopBtn" title="Loop">üîÅ</button>
        <button class="control-btn" onclick="toggleNormalization()" id="normalizeBtn" title="Audio Normalization">üîä</button>
    </div>
<div style="text-align: center; margin: 15px 0;">
            <button class="trim-btn" onclick="openTrimWindow()">‚úÇÔ∏è Trim Song</button>
        </div>
    <div class="playback-controls">
    <div class="control-group">
        <label for="volumeSlider">Volume: <span id="volumeValue">100</span>%</label>
        <input type="range" id="volumeSlider" class="playback-slider" min="0" max="100" value="100">
    </div>
    <div class="control-group">
        <div class="speed-controls">
            <div class="speed-header">
                <div class="speed-value-controls">
                    <button class="speed-arrow-btn" onclick="adjustSpeed(-1)" title="Decrease 1%">‚óÄ</button>
                    <label for="speedSlider" style="margin: 0;">Speed: <span id="speedValue">100</span>%</label>
                    <button class="speed-arrow-btn" onclick="adjustSpeed(1)" title="Increase 1%">‚ñ∂</button>
                    <button class="speed-arrow-btn" onclick="resetSpeed()" title="Reset to 100%" style="min-width: 32px;">‚Ü∫</button>
                </div>
                <div class="speed-save-controls">
                    <button class="save-speed-btn" onclick="saveSpeed()">Save Speed</button>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="useSavedSpeedCheckbox" onchange="toggleUseSavedSpeed()">
                        <label for="useSavedSpeedCheckbox">Use Saved</label>
                    </div>
                </div>
            </div>
            <input type="range" id="speedSlider" class="playback-slider" min="25" max="200" value="100" step="1">
        </div>
    </div>
    <div class="control-group">
        <div class="fade-controls">
            <div class="fade-header">
                <label for="fadeInSlider" style="margin: 0;">Fade In: <span id="fadeInValue">0</span>s</label>
                <div class="fade-save-controls">
                    <button class="save-fades-btn" onclick="saveFades()">Save Fades</button>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="useSavedFadesCheckbox" onchange="toggleUseSavedFades()">
                        <label for="useSavedFadesCheckbox">Use Saved</label>
                    </div>
                </div>
            </div>
            <input type="range" id="fadeInSlider" class="playback-slider" min="0" max="8" value="0" step="1">
        </div>
    </div>
    <div class="control-group">
        <label for="fadeOutSlider">Fade Out: <span id="fadeOutValue">0</span>s</label>
        <input type="range" id="fadeOutSlider" class="playback-slider" min="0" max="8" value="0" step="1">
    </div>
</div>
</div>

        <div class="trim-overlay" id="trimOverlay">
            <div class="trim-window">
                <div class="trim-header" id="trimHeader">Trim: [Song Name]</div>
                
                <div class="trim-controls">
                    <button class="trim-zoom-btn" onclick="adjustTrimZoom(-0.5)">Zoom Out</button>
                    <button class="trim-zoom-btn" onclick="adjustTrimZoom(0.5)">Zoom In</button>
                    <button class="trim-zoom-btn" onclick="resetTrimZoom()">Reset Zoom</button>
                    
                    <div class="trim-time-display">
                        <span>Start: <strong id="trimStartTime">0:00.00</strong></span>
                        <span>End: <strong id="trimEndTime">0:00.00</strong></span>
                        <span>Duration: <strong id="trimDuration">0:00.00</strong></span>
                    </div>
                </div>
                
                <div class="trim-waveform-container" id="trimWaveformContainer">
                    <canvas class="trim-waveform-canvas" id="trimWaveformCanvas"></canvas>
                    <div class="trim-region" id="trimRegion"></div>
                    <div class="trim-handle start" id="trimHandleStart"></div>
                    <div class="trim-handle end" id="trimHandleEnd"></div>
                </div>
                
                <div class="trim-actions">
                    <button class="trim-action-btn trim-cancel-btn" onclick="closeTrimWindow()">Cancel</button>
                    <button class="trim-action-btn trim-save-btn" onclick="saveTrimSettings()">Save Trim</button>
                </div>
            </div>
        </div>
        <!-- <div class="help-overlay">
            <div class="help-container">
                <div class="help-header">
                    <h2>Help / FAQ</h2>
                    <button class="help-close-btn" onclick="toggleHelp()">‚úñ</button>
                </div>
                <div class="help-listings">
                    <div class="help-listing">
                        <h2>How to Select a Music Folder</h2>
                        <p>Click the "Select Music Folder" button to choose the folder containing your music files. U-GROOVE will load all supported audio files from this folder and any sub-folders.</p>
                    </div>
                    <div class="help-listing">
                        <h2>How to filter my song list</h2>
                        <p>Click the "Select Music Folder" button to choose the folder containing your music files. U-GROOVE will load all supported audio files from this folder and any sub-folders.</p>
                    </div>
                </div>
            </div>
        </div> -->

        <audio id="audioPlayer"></audio>
    </div>

    <script>
        let configFileHandle = null;
        let songConfig = {}; // Structure: { songs: { "filename": { tags: [], speed: 100, trimStart: 0, trimEnd: 0 } }, appSettings: { accentColor1, accentColor2, useSavedSpeed, volume, isShuffled, isLooping } }
        let configDirHandle = null;
        let sortBy = 'name'; // 'name', 'modified', 'size'
        let sortAscending = true;
        let audioFiles = [];
        let currentIndex = 0;
        let currentlyPlayingFile = null; // Track the actual playing song, independent of filtered list
        let isPlaying = false;
        let isShuffled = false;
        let isLooping = false;
        let originalOrder = [];
        let isNormalized = true; // Normalization on by default
        // Waveform scrolling variables
        let waveformBuffer = [];
        let waveformBufferSize = 4096; // Adjustable buffer size
        let waveformScrollSpeed = 1; // Pixels per frame
        
        // Web Audio API setup for normalization
        let audioContext;
        let sourceNode;
        let gainNode;
        let analyserNode;
        let compressorNode;
        let isAudioContextSetup = false;
        
        // Tagging system
// Tagging system with categories
let masterTags = {}; // Structure: { "tagName": { category: "Artist", songCount: 5 } }
let selectedSongTags = new Set(); // Currently selected tags for active song
let selectedFilterTags = new Set(['all']); // Tags selected for filtering
let currentTagCategory = 'All'; // Current category filter: 'All', 'Artist', 'Genre', 'Vibe', 'Instrument', 'Album', 'Utility'
let tagSortBy = 'alphabetical'; // 'alphabetical' or 'songCount'
let tagSortAscending = true;
let tagFilterMode = 'include'; // 'include' or 'exclude'
let excludedFilterTags = new Set(); // Tags selected for exclusion
let multiSelectMode = false; // Whether multi-select is enabled
let selectedSongs = new Set(); // Set of selected song filenames
let prioritizeNewSongs = false;
let hasMarkedAsHeard = false; // Track if we've marked current song as heard

let json1Data = null;
let json2Data = null;
let json1FileName = '';
let json2FileName = '';
let songDurations = {}; // Store durations: filename -> duration in seconds
// Predefined master tag list with categories
const PREDEFINED_TAGS = {
    'Original from duped': 'Utility'
};
        let searchQuery = ''; 
        let fileHandles = new Map(); // filename -> file handle for writing back
        let isLoadingMetadata = false; // Track if metadata is still loading
        const SERVER_URL = 'http://localhost:3001'; // Node.js server
        
        // Visualizer setup
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        let animationId;
        let barFallSpeeds = [];
        let barHeights = [];
        let responseDuration = 50; // milliseconds - how fast bars respond
        
        const audioPlayer = document.getElementById('audioPlayer');
        const playBtn = document.getElementById('playBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const loopBtn = document.getElementById('loopBtn');
        const normalizeBtn = document.getElementById('normalizeBtn');
        const progressBar = document.getElementById('progressBar');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const nowPlaying = document.getElementById('nowPlaying');
        const playlist = document.getElementById('playlist');
        const durationSlider = document.getElementById('durationSlider');
        const durationValue = document.getElementById('durationValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        let useSavedSpeed = false;
        let pendingTrimUpdates = new Map(); // filename -> {trimStart, trimEnd}
        let isSaving = false; // Add this lock
        let saveQueue = []; // Add this queue

        let useSavedFades = false;
        let currentFadeInDuration = 0;
        let currentFadeOutDuration = 0;
        let fadeInInterval = null;
        let fadeOutInterval = null;
        let originalVolume = 1.0;
        let isFadingIn = false;
        let isFadingOut = false;

        // Gradient color system
        let accentColor1 = '#ff6b35';
        let accentColor2 = '#ff8c42';
        let currentAccentGradient = `linear-gradient(135deg, ${accentColor1}, ${accentColor2})`;

        // Visualizer settings
        let visualizerEnabled = true;
        let visualizerMode = 'frequency'; // 'frequency' or 'waveform'
        let minFrequency = 20;
        let maxFrequency = 20000;
        let minBarHeight = 0;
        let maxBarHeight = 100;
        let waveformSensitivity = 5.0;
        let isTabVisible = true;

        // Tag filter modes
        let tagMatchMode = 'and'; // 'and' or 'or'
        let tagSelectMode = 'single'; // 'single' or 'multi'

// Add near the top of your script, after audioContext is declared
let wakeLock = null;

// Handle visibility changes and audio context suspension
document.addEventListener('visibilitychange', async () => {
    if (document.hidden) {
        console.log('Page hidden, preparing audio for background...');
        // Don't do anything - let it continue
    } else {
        console.log('Page visible, resuming audio context...');
        if (audioContext && audioContext.state === 'suspended') {
            await audioContext.resume();
            console.log('Audio context resumed');
        }
    }
});

// Listen for audio context state changes
if (audioContext) {
    audioContext.onstatechange = () => {
        console.log('Audio context state:', audioContext.state);
        if (audioContext.state === 'suspended' && isPlaying) {
            console.log('Context suspended while playing, attempting resume...');
            audioContext.resume();
        }
    };
}

// Handle page becoming active/inactive
window.addEventListener('focus', async () => {
    if (audioContext && audioContext.state === 'suspended' && isPlaying) {
        await audioContext.resume();
        console.log('Window focused, audio context resumed');
    }
});

window.addEventListener('blur', () => {
    console.log('Window blurred');
    // Keep audio context alive by not suspending
    if (audioContext && audioContext.state === 'running' && isPlaying) {
        // Force a keep-alive
        if (sourceNode) {
            sourceNode.connect(gainNode);
        }
    }
});


        // Load or create configuration file
async function loadOrCreateConfig(dirHandle) {
    configDirHandle = dirHandle;
    
    try {
        // Try to get existing config file
        configFileHandle = await dirHandle.getFileHandle('u-groove-config.json', { create: true });
        const file = await configFileHandle.getFile();
        const text = await file.text();
        
        if (text.trim()) {
            const loadedConfig = JSON.parse(text);
            
            // Handle old format (flat structure) or new format (with songs/appSettings)
            if (loadedConfig.songs) {
                songConfig = loadedConfig.songs;
            } else {
                // Old format - everything is song configs
                songConfig = loadedConfig;
            }
            
            // Load song durations if they exist
            if (loadedConfig.songDurations) {
                songDurations = loadedConfig.songDurations;
                console.log('Loaded', Object.keys(songDurations).length, 'song durations from config');
            }
            
            // Load app settings if they exist
            if (loadedConfig.appSettings) {
                const settings = loadedConfig.appSettings;
                
                // Apply accent colors
                if (settings.accentColor1 && settings.accentColor2) {
                    updateAccentColors(settings.accentColor1, settings.accentColor2);
                    document.getElementById('accentColorPicker1').value = settings.accentColor1;
                    document.getElementById('accentColorPicker2').value = settings.accentColor2;
                }
                
                // Apply volume
                if (settings.volume !== null && settings.volume !== undefined) {
                    volumeSlider.value = settings.volume;
                    volumeValue.textContent = settings.volume;
                    audioPlayer.volume = settings.volume / 100;
                }
                
                // Apply useSavedSpeed
                if (settings.useSavedSpeed !== null && settings.useSavedSpeed !== undefined) {
                    useSavedSpeed = settings.useSavedSpeed;
                    const checkbox = document.getElementById('useSavedSpeedCheckbox');
                    if (checkbox) checkbox.checked = useSavedSpeed;
                }
                
                // Apply useSavedFades
                if (settings.useSavedFades !== null && settings.useSavedFades !== undefined) {
                    useSavedFades = settings.useSavedFades;
                    const checkbox = document.getElementById('useSavedFadesCheckbox');
                    if (checkbox) checkbox.checked = useSavedFades;
                }
                
// Apply prioritizeNewSongs
                if (settings.prioritizeNewSongs !== null && settings.prioritizeNewSongs !== undefined) {
                    prioritizeNewSongs = settings.prioritizeNewSongs;
                    const checkbox = document.getElementById('prioritizeNewSongsCheckbox');
                    if (checkbox) checkbox.checked = prioritizeNewSongs;
                }
                
                // Apply saved filter tags
                if (settings.selectedFilterTags && Array.isArray(settings.selectedFilterTags)) {
                    selectedFilterTags = new Set(settings.selectedFilterTags);
                    console.log('Loaded selected filter tags:', Array.from(selectedFilterTags));
                }
                
                if (settings.excludedFilterTags && Array.isArray(settings.excludedFilterTags)) {
                    excludedFilterTags = new Set(settings.excludedFilterTags);
                    console.log('Loaded excluded filter tags:', Array.from(excludedFilterTags));
                }
                
                if (settings.tagFilterMode) {
                    tagFilterMode = settings.tagFilterMode;
                    console.log('Loaded tag filter mode:', tagFilterMode);
                }
                
                if (settings.tagSelectMode) {
                    tagSelectMode = settings.tagSelectMode;
                    console.log('Loaded tag select mode:', tagSelectMode);
                }
                
                if (settings.tagMatchMode) {
                    tagMatchMode = settings.tagMatchMode;
                    console.log('Loaded tag match mode:', tagMatchMode);
                }
                
                // Apply shuffle state
                if (settings.isShuffled !== null && settings.isShuffled !== undefined) {
                    isShuffled = settings.isShuffled;
                    if (isShuffled) {
                        shuffleBtn.classList.add('active');
                        shuffleBtn.style.background = currentAccentGradient;
                        shuffleBtn.style.color = '#1a1a1a';
                        shuffleBtn.style.borderColor = accentColor1;
                    }
                }
                
                // Apply loop state
                if (settings.isLooping !== null && settings.isLooping !== undefined) {
                    isLooping = settings.isLooping;
                    audioPlayer.loop = isLooping;
                    if (isLooping) {
                        loopBtn.classList.add('active');
                        loopBtn.style.background = currentAccentGradient;
                        loopBtn.style.color = '#1a1a1a';
                        loopBtn.style.borderColor = accentColor1;
                    }
                }
            }
            
            console.log('Loaded configuration:', Object.keys(songConfig).length, 'songs');

            // Load master tags if they exist
            if (loadedConfig.masterTags) {
                // Merge with predefined tags
                Object.keys(PREDEFINED_TAGS).forEach(tagName => {
                    if (!loadedConfig.masterTags[tagName]) {
                        loadedConfig.masterTags[tagName] = {
                            category: PREDEFINED_TAGS[tagName],
                            songCount: 0
                        };
                    }
                });
                masterTags = loadedConfig.masterTags;
            } else {
                // Build from scratch
                buildMasterTagsFromConfig();
            }
        } else {
            songConfig = {};
            console.log('Created new configuration file');
        }
    } catch (error) {
        console.error('Error loading config:', error);
        songConfig = {};
    }
}

function toggleHelp() {
    const helpOverlay = document.querySelector('.help-overlay');
    if (helpOverlay.style.display === 'flex') {
        helpOverlay.style.display = 'none';
    } else {
        helpOverlay.style.display = 'flex';
    }
}

// Update saveConfig to handle mobile mode
async function saveConfig() {
    // Try file-based save first (desktop only)
    if (configFileHandle) {
        try {
            const configData = {
                songs: songConfig,
                masterTags: masterTags,
                songDurations: songDurations,
                appSettings: {
                    accentColor1: accentColor1,
                    accentColor2: accentColor2,
                    useSavedSpeed: useSavedSpeed,
                    useSavedFades: useSavedFades,
                    prioritizeNewSongs: prioritizeNewSongs,
                    volume: parseInt(volumeSlider.value),
                    selectedFilterTags: Array.from(selectedFilterTags),
                    excludedFilterTags: Array.from(excludedFilterTags),
                    tagFilterMode: tagFilterMode,
                    tagSelectMode: tagSelectMode,
                    tagMatchMode: tagMatchMode
                }
            };
            
            const writable = await configFileHandle.createWritable();
            await writable.write(JSON.stringify(configData, null, 2));
            await writable.close();
            console.log('Configuration saved to file');
        } catch (error) {
            console.error('Error saving config to file:', error);
        }
    } else {
        // Mobile mode - only save certain settings to localStorage
        try {
            const configData = {
                appSettings: {
                    accentColor1: accentColor1,
                    accentColor2: accentColor2,
                    volume: parseInt(volumeSlider.value),
                    selectedFilterTags: Array.from(selectedFilterTags),
                    excludedFilterTags: Array.from(excludedFilterTags),
                    tagFilterMode: tagFilterMode,
                    tagSelectMode: tagSelectMode,
                    tagMatchMode: tagMatchMode,
                    prioritizeNewSongs: prioritizeNewSongs
                }
            };
            localStorage.setItem('u-groove-mobile-settings', JSON.stringify(configData));
            console.log('Mobile settings saved to localStorage');
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }
}

// Get song configuration
function getSongConfig(filename) {
    return songConfig[filename] || {
        tags: [],
        speed: null,
        trimStart: null,
        trimEnd: null,
        FI: 0,
        FO: 0,
        heardb4: false,
        duped: false
    };
}

function markAsNotDuped(filename) {
    const config = getSongConfig(filename);
    if (config.duped === true) {
        updateSongConfig(filename, { duped: false });
        console.log(`Marked ${filename} as not duped due to property change`);
    }
}

// Update song configuration
function updateSongConfig(filename, updates) {
    if (!songConfig[filename]) {
        songConfig[filename] = {
            tags: [],
            speed: null,
            trimStart: null,
            trimEnd: null,
            FI: 0,
            FO: 0,
            heardb4: false
        };
    }
    
    Object.assign(songConfig[filename], updates);
}

// Build master tags from configuration
function buildMasterTagsFromConfig() {
    // Start fresh but preserve existing custom tags
    const existingCustomTags = {};
    
    // Save any tags that aren't in PREDEFINED_TAGS (custom tags)
    Object.keys(masterTags).forEach(tagName => {
        if (!PREDEFINED_TAGS[tagName]) {
            existingCustomTags[tagName] = {
                category: masterTags[tagName].category,
                songCount: 0
            };
        }
    });
    
    // Initialize with predefined tags
    masterTags = {};
    Object.keys(PREDEFINED_TAGS).forEach(tagName => {
        masterTags[tagName] = {
            category: PREDEFINED_TAGS[tagName],
            songCount: 0
        };
    });
    
    // Re-add custom tags
    Object.keys(existingCustomTags).forEach(tagName => {
        masterTags[tagName] = existingCustomTags[tagName];
    });
    
    // Count songs for each tag
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        if (config.tags && Array.isArray(config.tags)) {
            config.tags.forEach(tag => {
                // If tag exists in master list, increment count
                if (masterTags[tag]) {
                    masterTags[tag].songCount++;
                } else {
                    // Tag not in master list at all - this shouldn't happen now
                    console.warn(`Found tag "${tag}" not in masterTags for ${filename}`);
                    // Add it with a default category
                    masterTags[tag] = {
                        category: 'Vibe',
                        songCount: 1
                    };
                }
            });
        }
    });
    
    // Remove tags with 0 songs
    Object.keys(masterTags).forEach(tagName => {
        if (masterTags[tagName].songCount === 0) {
            delete masterTags[tagName];
        }
    });
    
    console.log('Master tags rebuilt. Total tags:', Object.keys(masterTags).length);
}

// Get filtered tags based on current category
function getFilteredTags() {
    const tags = Object.keys(masterTags);
    
    // Filter by category
    let filtered = tags;
    if (currentTagCategory !== 'All') {
        filtered = tags.filter(tag => masterTags[tag].category === currentTagCategory);
    }
    
    // Sort tags
    filtered.sort((a, b) => {
        let comparison = 0;
        
        if (tagSortBy === 'alphabetical') {
            comparison = a.localeCompare(b);
        } else if (tagSortBy === 'songCount') {
            comparison = masterTags[b].songCount - masterTags[a].songCount;
        }
        
        return tagSortAscending ? comparison : -comparison;
    });
    
    return filtered;
}

// Change tag category
function changeTagCategory(category) {
    currentTagCategory = category;
    
    // Sync both dropdowns
    document.getElementById('filterCategorySelect').value = category;
    document.getElementById('songCategorySelect').value = category;
    
    // Re-render both tag sections
    renderFilterTags();
    renderSongTags();
}

// Change tag sort
function changeTagSort(sortBy) {
    tagSortBy = sortBy;
    
    // Sync both dropdowns
    document.getElementById('filterSortSelect').value = sortBy;
    document.getElementById('songSortSelect').value = sortBy;
    
    // Re-render both tag sections
    renderFilterTags();
    renderSongTags();
}

// Toggle tag sort order
function toggleTagSortOrder() {
    tagSortAscending = !tagSortAscending;
    
    const arrow = tagSortAscending ? '‚Üì' : '‚Üë';
    document.getElementById('filterSortOrderBtn').textContent = arrow;
    document.getElementById('songSortOrderBtn').textContent = arrow;
    
    // Re-render both tag sections
    renderFilterTags();
    renderSongTags();
}


        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Duration slider control
        durationSlider.addEventListener('input', (e) => {
            responseDuration = parseInt(e.target.value);
            durationValue.textContent = responseDuration;
        });

// Volume slider control (iOS compatible)
volumeSlider.addEventListener('input', (e) => {
    const volume = parseInt(e.target.value);
    volumeValue.textContent = volume;
    
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (isIOS) {
        // On iOS, we have to use the HTML5 audio element volume
        // (it only works for some audio sources, not all)
        audioPlayer.volume = volume / 100;
        originalVolume = volume / 100;
    } else if (gainNode && audioContext) {
        // Desktop: use Web Audio API
        const gainValue = volume / 100;
        gainNode.gain.setValueAtTime(gainValue, audioContext.currentTime);
        originalVolume = gainValue;
    } else {
        audioPlayer.volume = volume / 100;
        originalVolume = volume / 100;
    }
});

        // Save volume on change end
        volumeSlider.addEventListener('change', () => {
            saveConfig();
        });

        // Fade In slider control
const fadeInSlider = document.getElementById('fadeInSlider');
const fadeInValue = document.getElementById('fadeInValue');

fadeInSlider.addEventListener('input', (e) => {
    const fadeIn = parseInt(e.target.value);
    fadeInValue.textContent = fadeIn;
    currentFadeInDuration = fadeIn;
});

// Fade Out slider control
const fadeOutSlider = document.getElementById('fadeOutSlider');
const fadeOutValue = document.getElementById('fadeOutValue');

fadeOutSlider.addEventListener('input', (e) => {
    const fadeOut = parseInt(e.target.value);
    fadeOutValue.textContent = fadeOut;
    currentFadeOutDuration = fadeOut;
});

        // Speed slider control (with pitch change)
        speedSlider.addEventListener('input', (e) => {
            const speed = parseInt(e.target.value);
            speedValue.textContent = speed;
            audioPlayer.playbackRate = speed / 100;
            // Preserve pitch is false by default, so pitch will change with speed
            audioPlayer.preservesPitch = false;
        });

        // Show loading indicator
        function showLoadingIndicator() {
            isLoadingMetadata = true;
            
            // Show loading in filter section
            const filterContainer = document.getElementById('filterTags');
            filterContainer.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-spinner"></div>
                    <span>Loading metadata...</span>
                </div>
            `;
            
            // Show loading in song tags section
            const songContainer = document.getElementById('songTags');
            songContainer.innerHTML = `
                <div class="loading-indicator">
                    <div class="loading-spinner"></div>
                    <span>Loading metadata...</span>
                </div>
            `;
        }

        // Hide loading indicator and render tags
        function hideLoadingIndicator() {
            isLoadingMetadata = false;
            renderFilterTags();
            renderSongTags();
        }

        // Add a new tag to master list
function addNewTag(tagName) {
    tagName = tagName.trim();
    if (!tagName) return;
    
    // Check if tag already exists
    if (masterTags[tagName]) {
        console.log(`Tag "${tagName}" already exists with category: ${masterTags[tagName].category}`);
        return;
    }
    
    // Get category - must not be "All"
    let category;
    
    // Check if it's in predefined tags
    if (PREDEFINED_TAGS[tagName]) {
        category = PREDEFINED_TAGS[tagName];
        console.log(`Using predefined category for "${tagName}": ${category}`);
    } else {
        category = currentTagCategory;
        console.log(`Using current category for "${tagName}": ${category}`);
    }
    
    // Safety check: never allow "All" as a category
    if (category === 'All') {
        console.error('Cannot add tag without a specific category selected');
        alert('Please select a specific category (Artist, Genre, Vibe, Instrument, Album, or Utility) before adding a new tag.');
        return;
    }
    
    // Add to master tags
    masterTags[tagName] = {
        category: category,
        songCount: 0
    };
    
    console.log(`‚úì Added new tag "${tagName}" with category "${category}"`);
    console.log('Current masterTags entry:', masterTags[tagName]);
    
    renderSongTags();
    renderFilterTags();
}

// Show tag input field
function showTagInput() {
    // Don't allow adding tags if "All" category is selected
    if (currentTagCategory === 'All') {
        alert('Please select a specific category (Artist, Genre, Vibe, Instrument, Album, or Utility) to add a new tag.');
        return;
    }
    
    const songTagsContainer = document.getElementById('songTags');
    const existingInput = songTagsContainer.querySelector('.tag-input');
    if (existingInput) return;

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'tag-input';
    input.placeholder = `New ${currentTagCategory}...`;
    
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const tagName = input.value.trim();
            if (tagName) {
                // Check if tag already exists (case-insensitive)
                const existingTag = Object.keys(masterTags).find(t => t.toLowerCase() === tagName.toLowerCase());
                
                if (existingTag) {
                    // Use existing tag
                    if (multiSelectMode && selectedSongs.size > 0) {
                        // Add to all selected songs
                        selectedSongs.forEach(filename => {
                            const config = getSongConfig(filename);
                            const tags = new Set(config.tags || []);
                            tags.add(existingTag);
                            updateSongConfig(filename, { tags: Array.from(tags) });
                        });
                        selectedSongTags.add(existingTag);
                    } else {
                        // Add to current song only
                        selectedSongTags.add(existingTag);
                    }
                    console.log(`Using existing tag: ${existingTag}`);
                } else {
                    // Add new tag to master list FIRST
                    addNewTag(tagName);
                    // Then add to songs (only if addNewTag succeeded)
                    if (masterTags[tagName]) {
                        if (multiSelectMode && selectedSongs.size > 0) {
                            // Add to all selected songs
                            selectedSongs.forEach(filename => {
                                const config = getSongConfig(filename);
                                const tags = new Set(config.tags || []);
                                tags.add(tagName);
                                updateSongConfig(filename, { tags: Array.from(tags) });
                            });
                            selectedSongTags.add(tagName);
                        } else {
                            // Add to current song only
                            selectedSongTags.add(tagName);
                        }
                        console.log(`Added new tag to ${multiSelectMode && selectedSongs.size > 0 ? selectedSongs.size + ' songs' : 'current song'}: ${tagName}`);
                    }
                }
                
                // Save and re-render
                renderSongTags();
                if (multiSelectMode && selectedSongs.size > 0) {
                    // Save config for all selected songs
                    saveConfig().then(() => {
                        buildMasterTagsFromConfig();
            renderFilterTags();
            // Update displays if current song is in selection
            if (currentlyPlayingFile && selectedSongs.has(currentlyPlayingFile.name)) {
                updateNowPlayingDisplay();
                if (collapsedSections.player) {
                    updateCompactPlayer();
                }
            }
            console.log(`Batch ${adding ? 'added' : 'removed'} tag "${tagName}" ${adding ? 'to' : 'from'} ${selectedSongs.size} songs`);
                    });
                } else {
                    // Save tags for current song
                    saveTags();
                }
            }
            input.remove();
        } else if (e.key === 'Escape') {
            input.remove();
        }
    });

    input.addEventListener('blur', () => {
        setTimeout(() => input.remove(), 200);
    });

    songTagsContainer.insertBefore(input, songTagsContainer.firstChild);
    input.focus();
}

// Toggle tag selection for current song
function toggleSongTag(tagName) {
    if (multiSelectMode && selectedSongs.size > 0) {
        // Multi-select mode: toggle tag for all selected songs
        const adding = !selectedSongTags.has(tagName);
        
        selectedSongs.forEach(filename => {
            const config = getSongConfig(filename);
            const tags = new Set(config.tags || []);
            
            if (adding) {
                tags.add(tagName);
            } else {
                tags.delete(tagName);
            }
            
            updateSongConfig(filename, { tags: Array.from(tags) });
        });
        
        // Update selected song tags display
        if (adding) {
            selectedSongTags.add(tagName);
        } else {
            selectedSongTags.delete(tagName);
        }
        
        renderSongTags();
        
        // Save all changes
        saveConfig().then(() => {
            buildMasterTagsFromConfig();
            renderFilterTags();
            console.log(`Batch ${adding ? 'added' : 'removed'} tag "${tagName}" ${adding ? 'to' : 'from'} ${selectedSongs.size} songs`);
        });
    } else {
        // Single song mode: toggle tag for current song only
        if (selectedSongTags.has(tagName)) {
            selectedSongTags.delete(tagName);
        } else {
            selectedSongTags.add(tagName);
        }
        renderSongTags();
        
        // Automatically save tags
        saveTags();
    }
}

function renderSongTags() {
    if (isLoadingMetadata) return;
    
    const container = document.getElementById('songTags');
    container.innerHTML = '';
    
    // Show selection info if in multi-select mode
    if (multiSelectMode && selectedSongs.size > 0) {
        const infoDiv = document.createElement('div');
        infoDiv.style.cssText = 'color: #ff6b35; font-size: 12px; margin-bottom: 10px; font-weight: 600;';
        infoDiv.textContent = `Editing ${selectedSongs.size} song${selectedSongs.size !== 1 ? 's' : ''}`;
        container.appendChild(infoDiv);
    }

    // Only show Add button if a specific category is selected (not "All")
    if (currentTagCategory !== 'All') {
        const addBtn = document.createElement('button');
        addBtn.className = 'add-tag-btn';
        addBtn.style.borderColor = accentColor1;
        addBtn.style.color = accentColor1;
        
        // Show which category will be added
        addBtn.textContent = `+ Add ${currentTagCategory}`;
        addBtn.onclick = showTagInput;
        container.appendChild(addBtn);
    }

    // ... rest of the function stays the same

    // Get filtered and sorted tags
    const filteredTags = getFilteredTags();
    
    filteredTags.forEach(tag => {
        const pill = document.createElement('button');
        pill.className = 'tag-pill';
        
        // Check if this tag is selected for the current song
        if (selectedSongTags.has(tag)) {
            pill.classList.add('active');
            pill.style.background = currentAccentGradient;
            pill.style.color = '#1a1a1a';
            pill.style.borderColor = accentColor1;
        } else {
            pill.style.borderColor = accentColor1;
            pill.style.color = accentColor1;
            pill.style.background = 'transparent';
        }
        pill.textContent = tag;
        pill.onclick = () => toggleSongTag(tag);
        container.appendChild(pill);
    });
}


// Toggle filter tag selection
function selectFilterTag(tagName) {
    if (tagName === 'all') {
        selectedFilterTags.clear();
        excludedFilterTags.clear();
        selectedFilterTags.add('all');
    } else {
        selectedFilterTags.delete('all');
        
        if (tagFilterMode === 'include') {
            // Include mode
            if (tagSelectMode === 'single') {
                // Single select mode - allow deselection if clicking the same tag
                if (selectedFilterTags.has(tagName)) {
                    selectedFilterTags.delete(tagName);
                    if (selectedFilterTags.size === 0 && excludedFilterTags.size === 0) {
                        selectedFilterTags.add('all');
                    }
                } else {
                    selectedFilterTags.clear();
                    selectedFilterTags.add(tagName);
                }
            } else {
                // Multi select mode
                if (selectedFilterTags.has(tagName)) {
                    selectedFilterTags.delete(tagName);
                    if (selectedFilterTags.size === 0 && excludedFilterTags.size === 0) {
                        selectedFilterTags.add('all');
                    }
                } else {
                    selectedFilterTags.add(tagName);
                }
            }
        } else {
            // Exclude mode - always multi-select for excludes
            if (excludedFilterTags.has(tagName)) {
                excludedFilterTags.delete(tagName);
                if (selectedFilterTags.size === 0 && excludedFilterTags.size === 0) {
                    selectedFilterTags.add('all');
                }
            } else {
                excludedFilterTags.add(tagName);
            }
        }
    }
    
    // Clear search bar when clicking a tag
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.value = '';
        searchQuery = '';
    }
    
    renderFilterTags();
    updateAudioFilesList();
    
    // Save filter state
    saveConfig();
}

// Toggle multi-select mode
function toggleMultiSelect() {
    multiSelectMode = !multiSelectMode;
    const btn = document.getElementById('multiSelectBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    
    if (multiSelectMode) {
        btn.classList.add('active');
        btn.style.background = currentAccentGradient;
        btn.style.color = '#1a1a1a';
        btn.style.borderColor = accentColor1;
        selectAllBtn.style.display = 'block';
    } else {
        btn.classList.remove('active');
        btn.style.background = '';
        btn.style.color = '';
        btn.style.borderColor = '#3a3a3a';
        selectAllBtn.style.display = 'none';
        // Clear all selections
        selectedSongs.clear();
    }
    
    // Re-render playlist with/without checkboxes
    displayPlaylist();
    
    // Update the tagging section to show appropriate message
    updateTaggingDisplay();
}

// Toggle select all/deselect all
function toggleSelectAll() {
    const selectAllBtn = document.getElementById('selectAllBtn');
    
    // Check if all visible songs are already selected
    const allSelected = audioFiles.every(file => selectedSongs.has(file.name));
    
    if (allSelected) {
        // Deselect all visible songs
        audioFiles.forEach(file => selectedSongs.delete(file.name));
        selectAllBtn.textContent = 'Select All';
    } else {
        // Select all visible songs
        audioFiles.forEach(file => selectedSongs.add(file.name));
        selectAllBtn.textContent = 'Deselect All';
    }
    
    // Re-render playlist to update checkboxes
    displayPlaylist();
    updateTaggingDisplay();
}

// Update tagging display based on selection
function updateTaggingDisplay() {
    if (!multiSelectMode || selectedSongs.size === 0) {
        // Show tags for currently playing song
        if (currentlyPlayingFile) {
            loadSongTags(currentlyPlayingFile.name);
        }
    } else {
        // Show combined tags from all selected songs
        loadMultiSongTags();
    }
}

// Load tags that are common or present across selected songs
function loadMultiSongTags() {
    selectedSongTags.clear();
    
    if (selectedSongs.size === 0) return;
    
    // Get all tags from all selected songs
    const allTags = new Map(); // tag -> count of songs that have it
    
    selectedSongs.forEach(filename => {
        const config = getSongConfig(filename);
        if (config.tags) {
            config.tags.forEach(tag => {
                allTags.set(tag, (allTags.get(tag) || 0) + 1);
            });
        }
    });
    
    // Include tags that are in ALL selected songs (for display purposes)
    allTags.forEach((count, tag) => {
        if (count === selectedSongs.size) {
            selectedSongTags.add(tag);
        }
    });
    
    renderSongTags();
}

// Handle song checkbox click
function toggleSongSelection(event, file) {
    event.stopPropagation(); // Prevent playing the song
    
    if (selectedSongs.has(file.name)) {
        selectedSongs.delete(file.name);
    } else {
        selectedSongs.add(file.name);
    }
    
    // Update select all button text
    const selectAllBtn = document.getElementById('selectAllBtn');
    const allSelected = audioFiles.every(f => selectedSongs.has(f.name));
    selectAllBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
    
    // Update tagging display
    updateTaggingDisplay();
    
    // Just update the checkbox, don't re-render entire playlist
    const checkbox = event.target;
    checkbox.checked = selectedSongs.has(file.name);
}

// Update the audioFiles list based on current filter and shuffle state
function updateAudioFilesList() {
    // Get filtered files based on selected tags
    let filteredFiles;
    
    // Step 1: Apply INCLUDE filters
    if (selectedFilterTags.has('all')) {
        // Start with all songs
        filteredFiles = [...originalOrder];
    } else if (selectedFilterTags.size > 0) {
        // Filter based on included tags
        filteredFiles = originalOrder.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return false;
            
            // Include mode: Show songs that match the selected tags
            if (tagMatchMode === 'and') {
                // ALL selected tags must be present
                return Array.from(selectedFilterTags).every(tag => config.tags.includes(tag));
            } else {
                // AT LEAST ONE selected tag must be present
                return config.tags.some(tag => selectedFilterTags.has(tag));
            }
        });
    } else {
        // No include tags selected, start with all songs
        filteredFiles = [...originalOrder];
    }
    
    // Step 2: Apply EXCLUDE filters (remove songs with excluded tags)
    if (excludedFilterTags.size > 0) {
        filteredFiles = filteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) {
                // Songs with no tags pass through (can't have excluded tags)
                return true;
            }
            
            // Remove songs that have ANY of the excluded tags
            return !config.tags.some(tag => excludedFilterTags.has(tag));
        });
    }
    
    // Step 3: ALWAYS exclude "DELETE" tag unless explicitly included
    if (!selectedFilterTags.has('DELETE')) {
        filteredFiles = filteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return true;
            
            // Remove songs that have the DELETE tag
            return !config.tags.includes('DELETE');
        });
    }

    // Step 4: ALWAYS exclude "Original from duped" tag unless explicitly included
    if (!selectedFilterTags.has('Original from duped')) {
        filteredFiles = filteredFiles.filter(file => {
            const config = getSongConfig(file.name);
            if (!config.tags || !config.tags.length) return true;
            
            // Remove songs that have the "Original from duped" tag
            return !config.tags.includes('Original from duped');
        });
    }
    
    // Apply search filter
    if (searchQuery.trim()) {
        const query = searchQuery.toLowerCase();
        filteredFiles = filteredFiles.filter(file => 
            file.name.toLowerCase().includes(query)
        );
    }
    
    // Apply sorting (before shuffle)
    filteredFiles = sortFiles(filteredFiles);
    
    // Apply shuffle if enabled
    if (isShuffled) {
        audioFiles = [...filteredFiles].sort(() => Math.random() - 0.5);
    } else {
        audioFiles = filteredFiles;
    }
    
    // Update current index based on currently playing file
    if (currentlyPlayingFile) {
        // Find the currently playing file in the new filtered list
        const playingIndex = audioFiles.findIndex(f => f.name === currentlyPlayingFile.name);
        
        if (playingIndex !== -1) {
            // Currently playing song is in the filtered list
            currentIndex = playingIndex;
        } else {
            // Currently playing song is NOT in the filtered list
            currentIndex = -1; // Set to -1 to indicate no valid selection
        }
    } else {
        // No song is currently playing
        currentIndex = audioFiles.length > 0 ? 0 : -1;
    }
    
    // Clear selections for songs that are no longer visible
    if (multiSelectMode) {
        const visibleSongs = new Set(audioFiles.map(f => f.name));
        const selectionsToRemove = [];
        
        selectedSongs.forEach(filename => {
            if (!visibleSongs.has(filename)) {
                selectionsToRemove.push(filename);
            }
        });
        
        selectionsToRemove.forEach(filename => selectedSongs.delete(filename));
        
        // Update select all button if needed
        if (selectionsToRemove.length > 0) {
            const selectAllBtn = document.getElementById('selectAllBtn');
            if (selectAllBtn) {
                const allSelected = audioFiles.every(f => selectedSongs.has(f.name));
                selectAllBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
            }
        }
    }
    
    displayPlaylist();
}
// Render filter tags
function renderFilterTags() {
    if (isLoadingMetadata) return;
    
    const container = document.getElementById('filterTags');
    container.innerHTML = '';

    // "All" button
    const allBtn = document.createElement('button');
    allBtn.className = 'tag-pill';
    if (selectedFilterTags.has('all')) {
        allBtn.classList.add('active');
        allBtn.style.background = currentAccentGradient;
        allBtn.style.color = '#1a1a1a';
        allBtn.style.borderColor = accentColor1;
    } else {
        allBtn.style.borderColor = accentColor1;
        allBtn.style.color = accentColor1;
        allBtn.style.background = 'transparent';
    }
    allBtn.textContent = 'All';
    allBtn.onclick = () => selectFilterTag('all');
    container.appendChild(allBtn);

    // Get filtered and sorted tags
    const filteredTags = getFilteredTags();
    
    filteredTags.forEach(tag => {
        const pill = document.createElement('button');
        pill.className = 'tag-pill';
        
        // Show song count
        const tagText = `${tag} (${masterTags[tag].songCount})`;
        
        // Check if included or excluded
        const isIncluded = selectedFilterTags.has(tag);
        const isExcluded = excludedFilterTags.has(tag);
        
        // Special handling for DELETE tag - always red unless explicitly included
        const isDeleteTag = tag === 'DELETE';
        const shouldShowAsExcluded = isExcluded || (isDeleteTag && !isIncluded);
        
        if (isIncluded) {
            // Included tag - use accent color
            pill.classList.add('active');
            pill.style.background = currentAccentGradient;
            pill.style.color = '#1a1a1a';
            pill.style.borderColor = accentColor1;
        } else if (shouldShowAsExcluded) {
            // Excluded tag OR DELETE tag (unless included) - use red
            pill.classList.add('active');
            pill.style.background = 'linear-gradient(135deg, #ff3333, #cc0000)';
            pill.style.color = '#fff';
            pill.style.borderColor = '#ff3333';
        } else {
            // Not selected
            pill.style.borderColor = accentColor1;
            pill.style.color = accentColor1;
            pill.style.background = 'transparent';
        }
        
        pill.textContent = tagText;
        pill.onclick = () => selectFilterTag(tag);
        container.appendChild(pill);
    });
}

// Load tags from current song
function loadSongTags(filename) {
    // Don't override if in multi-select mode with selections
    if (multiSelectMode && selectedSongs.size > 0) {
        return;
    }
    
    selectedSongTags.clear();
    
    const config = getSongConfig(filename);
    if (config.tags) {
        config.tags.forEach(tag => selectedSongTags.add(tag));
    }
    
    renderSongTags();
}

// Save tags for current song
async function saveTags() {
    if (!currentlyPlayingFile) return;
    
    const currentFile = currentlyPlayingFile;
    const tags = Array.from(selectedSongTags);
    
    // Update configuration
    updateSongConfig(currentFile.name, { tags: tags });
    
    // Save configuration file
    await saveConfig();
    
    // Rebuild master tags to update song counts
    buildMasterTagsFromConfig();
    renderFilterTags();
    
    // Update now playing display to show new tag count
    updateNowPlayingDisplay();
    if (collapsedSections.player) {
        updateCompactPlayer();
    }
    
    console.log('Tags saved for:', currentFile.name, tags);
}



        // Accent color pickers
        const accentColorPicker1 = document.getElementById('accentColorPicker1');
        const accentColorPicker2 = document.getElementById('accentColorPicker2');
        // Search input handler
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', (e) => {
            searchQuery = e.target.value;
            updateAudioFilesList();
        });

        function updateAccentColors(color1, color2) {
            accentColor1 = color1;
            accentColor2 = color2;
            currentAccentGradient = `linear-gradient(135deg, ${color1}, ${color2})`;

            updateFavicon(color1, color2);

 
            const headerLogo = document.getElementById('headerLogo');
            if (!headerLogo) return;
            
            // Update the gradient stops
            const gradient = headerLogo.querySelector('#lg1');
            if (gradient) {
                const stops = gradient.querySelectorAll('stop');
                stops[0].setAttribute('stop-color', color1);
                stops[1].setAttribute('stop-color', color2);
            }
            const help = document.querySelector('.help');
            help.style.borderColor = color1;
            help.style.color = color1;
            
            // Update all elements with gradient
            document.documentElement.style.setProperty('--accent-color', color1);
            document.documentElement.style.setProperty('--accent-gradient', currentAccentGradient);
            
            // Update specific elements with gradient
            const h1 = document.querySelector('h1');
            const h3 = document.querySelector('h3');
            h1.style.background = currentAccentGradient;
            h1.style.webkitBackgroundClip = 'text';
            h1.style.webkitTextFillColor = 'transparent';
            h1.style.backgroundClip = 'text';

            h3.style.background = currentAccentGradient;
            h3.style.webkitBackgroundClip = 'text';
            h3.style.webkitTextFillColor = 'transparent';
            h3.style.backgroundClip = 'text';
            
            const container = document.querySelector('.container');
            container.style.borderColor = color1;

            const folderBtn = document.querySelector('.folder-btn');
            folderBtn.style.borderColor = color1;
            folderBtn.style.color = color1;

            const searchSection = document.querySelector('.search-section');
            searchSection.style.borderColor = color1;

            // Add these lines to the updateAccentColors function:
                const sortOrderBtn = document.getElementById('sortOrderBtn');
                const scrollToSongBtn = document.querySelector('.scroll-to-song-btn');
                const sortSelect = document.getElementById('sortSelect');

                if (sortOrderBtn) {
                    sortOrderBtn.style.borderColor = color1;
                }
                if (scrollToSongBtn) {
                    scrollToSongBtn.style.borderColor = color1;
                }
                if (sortSelect) {
                    sortSelect.style.borderColor = color1;
                }

            // Update visualizer controls section
            const visualizerControlsSection = document.querySelector('.visualizer-controls-section');
            if (visualizerControlsSection) {
                visualizerControlsSection.style.borderColor = color1;
            }

            const taggingSection = document.querySelector('.tagging-section');
            taggingSection.style.borderColor = color1;

            const filterSection = document.querySelector('.filter-section');
            filterSection.style.borderColor = color1;

            const writeSongEditsBtn = document.getElementById('writeSongEditsBtn');
            if (writeSongEditsBtn) {
                writeSongEditsBtn.style.borderColor = color1;
                if (!writeSongEditsBtn.disabled) {
                    writeSongEditsBtn.style.background = currentAccentGradient;
                }
            }

            const jsonSelectBtns = document.querySelectorAll('.json-select-btn');
            jsonSelectBtns.forEach(btn => {
                btn.style.borderColor = color1;
                btn.style.color = color1;
            });

            const jsonSelectBtnsSelected = document.querySelectorAll('.json-select-btn.selected');
            jsonSelectBtnsSelected.forEach(btn => {
                btn.style.background = currentAccentGradient;
                btn.style.color = '#1a1a1a';
                btn.style.borderColor = color1;
            });

            const mergeArrow = document.querySelector('.merge-arrow');
            if (mergeArrow) {
                mergeArrow.style.color = color1;
            }

            const mergeActionBtn = document.getElementById('mergeBtn');
            if (mergeActionBtn) {
                mergeActionBtn.style.borderColor = color1;
                if (!mergeActionBtn.disabled) {
                    mergeActionBtn.style.background = currentAccentGradient;
                }
            }
                        
            // Update all section labels
            const sectionLabels = document.querySelectorAll('.section-label');
            sectionLabels.forEach(label => {
                label.style.background = currentAccentGradient;
                label.style.webkitBackgroundClip = 'text';
                label.style.webkitTextFillColor = 'transparent';
                label.style.backgroundClip = 'text';
            });
            
            // Update all tag pills
            const tagPills = document.querySelectorAll('.tag-pill');
            tagPills.forEach(pill => {
                pill.style.borderColor = color1;
                pill.style.borderImage = 'none';
                if (!pill.classList.contains('active')) {
                    pill.style.background = 'transparent';
                    pill.style.color = color1;
                }
            });
            
            // Update active tag pills
            const activeTagPills = document.querySelectorAll('.tag-pill.active');
            activeTagPills.forEach(pill => {
                pill.style.background = currentAccentGradient;
                pill.style.color = '#1a1a1a';
                pill.style.borderColor = color1;
                pill.style.borderImage = 'none';
            });
            
            const visualizerCanvas = document.querySelector('.visualizer-canvas');
            visualizerCanvas.style.borderColor = color1;

            const playlist = document.querySelector('.playlist');
            playlist.style.borderColor = color1;

            const playerSection = document.querySelector('.player-section');
            playerSection.style.borderColor = color1;

            const songCounter = document.getElementById('songCounter');
            if (songCounter) {
                songCounter.style.borderColor = color1;
            }

            
            const nowPlayingEl = document.querySelector('.now-playing');
            nowPlayingEl.style.background = currentAccentGradient;
            nowPlayingEl.style.webkitBackgroundClip = 'text';
            nowPlayingEl.style.webkitTextFillColor = 'transparent';
            nowPlayingEl.style.backgroundClip = 'text';
            
            const progressBar = document.querySelector('.progress-bar');
            progressBar.style.background = currentAccentGradient;
            
            // Update control buttons - use solid color for circular buttons to preserve border-radius
            const controlBtns = document.querySelectorAll('.control-btn');
            controlBtns.forEach(btn => {
                btn.style.borderColor = color1;
                //btn.style.borderImage = 'none';
                btn.style.color = color1;
            });
            
            // Update active buttons
            const activeBtns = document.querySelectorAll('.control-btn.active');
            activeBtns.forEach(btn => {
                btn.style.background = currentAccentGradient;
                btn.style.color = '#1a1a1a';
                btn.style.borderColor = color1;
                //btn.style.borderImage = 'none';
            });
            
            // Update active playlist item if exists
            const activeItem = document.querySelector('.playlist-item.active');
            if (activeItem) {
                activeItem.style.background = currentAccentGradient;
            }

            const toggleOptions = document.querySelectorAll('.toggle-option.active');
            toggleOptions.forEach(option => {
                option.style.background = currentAccentGradient;
            });

            const saveFadesBtn = document.querySelector('.save-fades-btn');
            if (saveFadesBtn) {
                saveFadesBtn.style.borderColor = color1;
                saveFadesBtn.style.color = color1;
            }

            const settingsSection = document.querySelector('.settings-section');
            if (settingsSection) {
                settingsSection.style.borderColor = color1;
            }

            const settingItems = document.querySelectorAll('.setting-item');
            settingItems.forEach(item => {
                item.style.borderColor = color1;
            });

            const settingCheckboxes = document.querySelectorAll('.setting-checkbox');
            settingCheckboxes.forEach(checkbox => {
                checkbox.style.accentColor = color1;
            });

            // Update visualizer toggle button
            const visualizerToggleBtn = document.getElementById('visualizerToggleBtn');
            if (visualizerToggleBtn) {
                visualizerToggleBtn.style.borderColor = color1;
                visualizerToggleBtn.style.color = color1;
                }

                const speedArrowBtns = document.querySelectorAll('.speed-arrow-btn');
                speedArrowBtns.forEach(btn => {
                    btn.style.borderColor = color1;
                    btn.style.color = color1;
                });

                const saveSpeedBtn = document.querySelector('.save-speed-btn');
                if (saveSpeedBtn) {
                    saveSpeedBtn.style.borderColor = color1;
                    saveSpeedBtn.style.color = color1;
                }

                const calculateDurationsBtn = document.getElementById('calculateDurationsBtn');
                if (calculateDurationsBtn) {
                    calculateDurationsBtn.style.borderColor = color1;
                    if (!calculateDurationsBtn.disabled) {
                        calculateDurationsBtn.style.background = currentAccentGradient;
                    }
                }
                            
            // Update slider thumb color and dynamic hover styles
            const existingStyle = document.getElementById('dynamic-accent-styles');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            
            const style = document.createElement('style');
            style.id = 'dynamic-accent-styles';
            style.innerHTML = `
                .duration-slider::-webkit-slider-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .duration-slider::-moz-range-thumb {
                    background: ${currentAccentGradient} !important;
                }

                .playback-slider::-webkit-slider-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .playback-slider::-moz-range-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .visualizer-control-slider::-webkit-slider-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .visualizer-control-slider::-moz-range-thumb {
                    background: ${currentAccentGradient} !important;
                }
                .control-group label {
                    background: ${currentAccentGradient} !important;
                    -webkit-background-clip: text !important;
                    -webkit-text-fill-color: transparent !important;
                    background-clip: text !important;
                }
                .folder-btn:hover {
                    background: ${color1} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .help:hover {
                    background: ${color1} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .control-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-color: ${color1} !important;
                }
                .collapse-handle {
                    color: ${color1} !important;
                }
                .player-compact-title {
                    background: ${currentAccentGradient} !important;
                    -webkit-background-clip: text !important;
                    -webkit-text-fill-color: transparent !important;
                    background-clip: text !important;
                }
                .checkbox-wrapper input[type="checkbox"] {
                    accent-color: ${color1} !important;
                }
                .speed-arrow-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .save-speed-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                .visualizer-toggle-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                    .sort-order-btn:hover,
                    .scroll-to-song-btn:hover,
                    .sort-select:focus {
                        border-color: ${color1} !important;
                    }
                .trim-btn {
                    border-color: ${color1} !important;
                    color: ${color1} !important;
                }
                .trim-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                    .save-fades-btn:hover {
                    background: ${currentAccentGradient} !important;
                    color: #1a1a1a !important;
                    border-image: none !important;
                }
                    .setting-checkbox {
                    accent-color: ${color1} !important;
                }
                #calculateDurationsBtn {
                    border-color: ${color1} !important;
                    background: ${currentAccentGradient} !important;
                }
                #calculateDurationsBtn:hover:not(:disabled) {
                    background: ${color1} !important;
                }
                    .json-select-btn {
    border-color: ${color1} !important;
    color: ${color1} !important;
}
.json-select-btn:hover {
    background: ${color1}40 !important;
}
.json-select-btn.selected {
    background: ${currentAccentGradient} !important;
    color: #1a1a1a !important;
    border-color: ${color1} !important;
}
.merge-arrow {
    color: ${color1} !important;
}
.merge-action-btn {
    border-color: ${color1} !important;
    background: ${currentAccentGradient} !important;
}
.merge-action-btn:hover:not(:disabled) {
    background: ${color1} !important;
}
.merge-action-btn:disabled {
    color: ${color1} !important;
}
            `;
            document.head.appendChild(style);
        }
        // Update favicon with current accent colors
// Update favicon with current accent colors
function updateFavicon(color1, color2) {
    const favicon = document.getElementById('dynamicFavicon');
    if (!favicon) return;
    
    // URL-encode the colors (replace # with %23)
    const encodedColor1 = color1.replace('#', '%23');
    const encodedColor2 = color2.replace('#', '%23');
    
    // Create SVG with dynamic gradients
    const svgContent = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 197.09 197.09'>
        <defs>
            <linearGradient id='lg1' x1='18.3' y1='51.83' x2='178.93' y2='144.58' gradientUnits='userSpaceOnUse'>
                <stop offset='0' stop-color='${encodedColor1}'/>
                <stop offset='1' stop-color='${encodedColor2}'/>
            </linearGradient>
            <linearGradient id='lg2' x1='96.76' y1='67.87' x2='124.81' y2='84.06' href='%23lg1'/>
            <linearGradient id='lg3' x1='96.76' y1='126.45' x2='124.81' y2='142.64' gradientTransform='translate(221.95 .32) rotate(79.1)' href='%23lg1'/>
            <linearGradient id='lg4' x1='47.35' y1='68.57' x2='161.33' y2='134.37' href='%23lg1'/>
        </defs>
        <circle fill='%23231f20' cx='98.55' cy='98.55' r='98.55'/>
        <circle fill='url(%23lg1)' cx='98.61' cy='98.2' r='92.73'/>
        <circle fill='%23231f20' cx='99.87' cy='98.47' r='87.1'/>
        <circle fill='url(%23lg2)' cx='110.78' cy='75.97' r='16.19'/>
        <circle fill='url(%23lg3)' cx='110.78' cy='134.55' r='16.19' transform='translate(-42.28 217.89) rotate(-79.1)'/>
        <path fill='url(%23lg4)' d='M51.64,144.55c.05,1.91.18,5.43,2.5,7.95,1.12,1.22,3.58,3.14,6.82,4.09,1.33.39,10.31,3.02,15.91-2.73,3.01-3.09,3.47-7.24,3.64-9.32,2.12-25.98,2.03-72.69,2.05-76.36,0-.26,0-.67.05-1.22.76-9.69,10.47-15.74,11.05-16.09,3.91-2.36,7.38-2.91,11.22-3.52,4.04-.64,9.8-.55,15,.65,2.09.48,8.28,4.04,9.78,6.65.38.67,4.02,5.14,4.43,11.61.08,1.23.02,2.17,0,2.48-.86,14.19,1.91,73.11,1.04,79.43-.03.19-.13.9,0,1.83.37,2.54,2.22,4.23,2.61,4.57,3.37,2.93,9.58,2.44,12.13-.52,1-1.17,1.24-2.49,1.3-2.87,2.05-12.34-1.11-68.62-.78-83.35,0-.41.03-1,0-1.83-.29-9.3-5.01-18.76-11.74-24.65-6.05-5.3-12.08-7.35-22.57-8.22-14.15-1.18-26.53-.25-34.83,1.57-9.16,2-12.33,4.76-14.45,6.29-5.77,4.19-8.82,8.82-10.99,13.01-1.5,2.89-4.57,8.97-4.83,17.09-.03,1.09,0,1.9,0,2.22.21,7.42.12,50.09.64,71.24Z'/>
    </svg>`;
    
    favicon.href = `data:image/svg+xml,${svgContent}`;
}

        // Debounce timer for color picker
let colorPickerSaveTimeout = null;

accentColorPicker1.addEventListener('input', (e) => {
    updateAccentColors(e.target.value, accentColor2);
    
    // Clear existing timeout
    if (colorPickerSaveTimeout) {
        clearTimeout(colorPickerSaveTimeout);
    }
    
    // Set new timeout to save after 500ms of inactivity
    colorPickerSaveTimeout = setTimeout(() => {
        saveConfig();
    }, 1500);
});

accentColorPicker2.addEventListener('input', (e) => {
    updateAccentColors(accentColor1, e.target.value);
    
    // Clear existing timeout
    if (colorPickerSaveTimeout) {
        clearTimeout(colorPickerSaveTimeout);
    }
    
    // Set new timeout to save after 500ms of inactivity
    colorPickerSaveTimeout = setTimeout(() => {
        saveConfig();
    }, 1500);
});

        // Initialize audio context on first user interaction
function initAudioContext() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (!audioContext && !isIOS) {
        // Only create audio context on non-iOS
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        compressorNode = audioContext.createDynamicsCompressor();
        compressorNode.threshold.setValueAtTime(-24, audioContext.currentTime);
        compressorNode.knee.setValueAtTime(30, audioContext.currentTime);
        compressorNode.ratio.setValueAtTime(12, audioContext.currentTime);
        compressorNode.attack.setValueAtTime(0.003, audioContext.currentTime);
        compressorNode.release.setValueAtTime(0.25, audioContext.currentTime);
        
        analyserNode = audioContext.createAnalyser();
        gainNode = audioContext.createGain();
        
        gainNode.connect(compressorNode);
        compressorNode.connect(analyserNode);
        analyserNode.connect(audioContext.destination);
        
        analyserNode.fftSize = 256;
        analyserNode.smoothingTimeConstant = 0.8;
    } else if (isIOS) {
        console.log('iOS mode - skipping Web Audio API initialization');
        // Create dummy nodes so code doesn't break
        analyserNode = null;
        gainNode = null;
    }
}

        // Draw visualizer
        // Bubble visualizer variables
let bubbleVertices = [];
let bubbleBaseRadius = 0;
let bubbleNoiseOffset = 0;

function initBubbleVertices(count) {
    bubbleVertices = [];
    bubbleBaseRadius = Math.min(canvas.width, canvas.height) * 0.15;
    for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        bubbleVertices.push({
            angle: angle,
            baseX: Math.cos(angle),
            baseY: Math.sin(angle),
            offset: 0
        });
    }
}

// Simple noise function for organic movement
function noise(x, y) {
    return Math.sin(x * 1.5 + y * 2.3) * Math.cos(x * 2.1 - y * 1.7) * 0.5 + 0.5;
}

function drawBubble(audioData) {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    // Get frequency data
    const bufferLength = analyserNode.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyserNode.getByteFrequencyData(dataArray);
    
    // Get bubble frequency settings
    const bubbleMinFreq = parseInt(document.getElementById('bubbleMinFreqSlider')?.value || 20);
    const bubbleMaxFreq = parseInt(document.getElementById('bubbleMaxFreqSlider')?.value || 20000);
    
    // Calculate frequency bin range
    const nyquist = audioContext.sampleRate / 2;
    const minFreqBin = Math.floor((bubbleMinFreq / nyquist) * bufferLength);
    const maxFreqBin = Math.floor((bubbleMaxFreq / nyquist) * bufferLength);
    const freqRange = maxFreqBin - minFreqBin;
    
    // Apply low-frequency taper (below 1000 Hz)
    const taperThreshold = 1000;
    const taperBin = Math.floor((taperThreshold / nyquist) * bufferLength);
    
    // Calculate average frequency for overall size with tapering
    let sum = 0;
    let count = 0;
    for (let i = minFreqBin; i < maxFreqBin && i < bufferLength; i++) {
        let value = dataArray[i];
        
        // Apply taper to frequencies below 1000 Hz
        if (i < taperBin) {
            const taperFactor = i / taperBin; // 0 to 1
            value *= taperFactor * taperFactor; // Quadratic taper for smooth reduction
        }
        
        sum += value;
        count++;
    }
    const avgFreq = count > 0 ? sum / count : 0;
    const pulseScale = 1 + (avgFreq / 255) * 0.3;
    
    // Get bubble settings
    const complexity = parseInt(document.getElementById('bubbleComplexitySlider')?.value || 2);
    const fluidity = parseFloat(document.getElementById('bubbleFluiditySlider')?.value || 0.5);
    
    // Initialize vertices if needed or if complexity changed
    if (bubbleVertices.length !== complexity * 20) {
        initBubbleVertices(complexity * 20);
    }
    
    // Update noise offset for animation
    bubbleNoiseOffset += 0.02 * fluidity;
    
    // Calculate vertex positions with audio influence
    const points = [];
    bubbleVertices.forEach((vertex, i) => {
        // Get frequency data for this vertex with tapering
        const freqIndex = minFreqBin + Math.floor((i / bubbleVertices.length) * freqRange);
        let freqValue = dataArray[freqIndex] / 255;
        
        // Apply taper to low frequencies
        if (freqIndex < taperBin) {
            const taperFactor = freqIndex / taperBin;
            freqValue *= taperFactor * taperFactor;
        }
        
        // Add noise for organic movement
        const noiseValue = noise(
            vertex.baseX * 1.5 + bubbleNoiseOffset,
            vertex.baseY * 1.5 + bubbleNoiseOffset
        );
        
        // Combine frequency and noise
        const displacement = (freqValue * 0.7 + noiseValue * 0.3) * bubbleBaseRadius * 2.5;
        
        const radius = bubbleBaseRadius * pulseScale + displacement;
        const x = cx + vertex.baseX * radius;
        const y = cy + vertex.baseY * radius;
        
        points.push({ x, y });
    });
    
    // Draw the bubble with gradient
    canvasCtx.beginPath();
    
    // Start at first point
    canvasCtx.moveTo(points[0].x, points[0].y);
    
    // Draw smooth curve through all points
    for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const p3 = points[(i + 2) % points.length];
        
        // Calculate control points for smooth curve
        const cp1x = p1.x + (p2.x - p1.x) * 0.5;
        const cp1y = p1.y + (p2.y - p1.y) * 0.5;
        
        canvasCtx.quadraticCurveTo(p1.x, p1.y, cp1x, cp1y);
    }
    
    canvasCtx.closePath();
    
    // Create radial gradient
    const gradient = canvasCtx.createRadialGradient(cx, cy, 0, cx, cy, bubbleBaseRadius * pulseScale);
    
    // Extract RGB from accent colors
    const r1 = parseInt(accentColor1.slice(1, 3), 16);
    const g1 = parseInt(accentColor1.slice(3, 5), 16);
    const b1 = parseInt(accentColor1.slice(5, 7), 16);
    const r2 = parseInt(accentColor2.slice(1, 3), 16);
    const g2 = parseInt(accentColor2.slice(3, 5), 16);
    const b2 = parseInt(accentColor2.slice(5, 7), 16);
    
    gradient.addColorStop(0, `rgba(${r2}, ${g2}, ${b2}, 0.9)`);
    gradient.addColorStop(0.5, `rgba(${r1}, ${g1}, ${b1}, 0.7)`);
    gradient.addColorStop(1, `rgba(${r2}, ${g2}, ${b2}, 0.3)`);
    
    canvasCtx.fillStyle = gradient;
    canvasCtx.fill();
    
    // Add glossy highlight
    const highlightGradient = canvasCtx.createRadialGradient(
        cx - bubbleBaseRadius * 0.3,
        cy - bubbleBaseRadius * 0.3,
        0,
        cx,
        cy,
        bubbleBaseRadius * pulseScale
    );
    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
    highlightGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.1)');
    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    canvasCtx.fillStyle = highlightGradient;
    canvasCtx.fill();
    
    // Add subtle edge glow
    canvasCtx.strokeStyle = `rgba(${r1}, ${g1}, ${b1}, 0.6)`;
    canvasCtx.lineWidth = 3;
    canvasCtx.stroke();
}
// Draw visualizer
function drawVisualizer() {
    if (!analyserNode) {
        // No analyser on iOS - draw a simple static visualization
        const bgColor = '#0f0f0f';
        canvasCtx.fillStyle = bgColor;
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw a simple message
        canvasCtx.fillStyle = accentColor1;
        canvasCtx.font = '16px Arial';
        canvasCtx.textAlign = 'center';
        canvasCtx.fillText('Visualizer disabled on iOS', canvas.width / 2, canvas.height / 2);
        canvasCtx.fillText('(for background playback)', canvas.width / 2, canvas.height / 2 + 20);
        return;
    }

    // CRITICAL: Stop any existing animation loop before starting a new one
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }

    const bufferLength = analyserNode.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const waveformData = new Uint8Array(bufferLength);
    
    const draw = () => {
        animationId = requestAnimationFrame(draw);
        
        // Check if visualizer is enabled and tab is visible
        if (!visualizerEnabled || !isTabVisible) {
            const bgColor = '#0f0f0f';
            canvasCtx.fillStyle = bgColor;
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        
        const bgColor = '#0f0f0f';
        canvasCtx.fillStyle = bgColor;
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (visualizerMode === 'bubble') {
            // Bubble mode
            drawBubble(dataArray);
        } else if (visualizerMode === 'frequency') {
            // Frequency bar mode (existing code)
            analyserNode.getByteFrequencyData(dataArray);
            
            const barCount = 64;
            const barWidth = (canvas.width / barCount) * 0.8;
            const barGap = (canvas.width / barCount) * 0.2;
            
            if (barHeights.length !== barCount) {
                barHeights = new Array(barCount).fill(0);
                barFallSpeeds = new Array(barCount).fill(0);
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const minFreqBin = Math.floor((minFrequency / nyquist) * bufferLength);
            const maxFreqBin = Math.floor((maxFrequency / nyquist) * bufferLength);
            const freqRange = maxFreqBin - minFreqBin;
            
            // Apply low-frequency taper (below 1000 Hz)
const taperThreshold = 1000;
const taperBin = Math.floor((taperThreshold / nyquist) * bufferLength);

for (let i = 0; i < barCount; i++) {
    const dataIndex = minFreqBin + Math.floor((i / barCount) * freqRange);
    let value = dataArray[dataIndex];
    
    // Apply taper to frequencies below 1000 Hz
    if (dataIndex < taperBin) {
        const taperFactor = dataIndex / taperBin; // 0 to 1
        value *= taperFactor * taperFactor; // Quadratic taper for smooth reduction
    }
    
    const minHeightPixels = (minBarHeight / 100) * canvas.height;
    const maxHeightPixels = (maxBarHeight / 100) * canvas.height;
    const heightRange = maxHeightPixels - minHeightPixels;
    
    const targetHeight = minHeightPixels + (value / 255) * heightRange;
    
    const responseSpeed = 1 / (responseDuration / 16.67);
    
    if (targetHeight > barHeights[i]) {
        barHeights[i] += (targetHeight - barHeights[i]) * responseSpeed * 2;
        barFallSpeeds[i] = 0;
    } else {
        const fallSpeed = responseSpeed * 5.5;
        barHeights[i] = Math.max(targetHeight, barHeights[i] - fallSpeed * 10);
    }
    
    const x = i * (barWidth + barGap);
    const height = barHeights[i];
    const y = canvas.height - height;
    
    const gradient = canvasCtx.createLinearGradient(0, y, 0, canvas.height);
    
    const r1 = parseInt(accentColor1.slice(1, 3), 16);
    const g1 = parseInt(accentColor1.slice(3, 5), 16);
    const b1 = parseInt(accentColor1.slice(5, 7), 16);
    const r2 = parseInt(accentColor2.slice(1, 3), 16);
    const g2 = parseInt(accentColor2.slice(3, 5), 16);
    const b2 = parseInt(accentColor2.slice(5, 7), 16);
    
    gradient.addColorStop(0, `rgba(${r1}, ${g1}, ${b1}, 0.7)`);
    gradient.addColorStop(1, `rgba(${r2}, ${g2}, ${b2}, 1)`);
    
    canvasCtx.fillStyle = gradient;
    canvasCtx.fillRect(x, y, barWidth, height);
}
        } else {
    // Waveform mode - Audacity-style scrolling
    analyserNode.getByteTimeDomainData(waveformData);
    
    // Add new data to buffer
    for (let i = 0; i < bufferLength; i++) {
        waveformBuffer.push(waveformData[i]);
    }
    
    // Adjust buffer size based on slider (zoom level)
    waveformBufferSize = Math.floor(4096 * (waveformSensitivity / 1.0));
    
    // Keep buffer at target size
    while (waveformBuffer.length > waveformBufferSize) {
        waveformBuffer.shift();
    }
    
    // Clear canvas
    canvasCtx.fillStyle = '#0f0f0f';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw center line
    canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    canvasCtx.lineWidth = 1;
    canvasCtx.beginPath();
    canvasCtx.moveTo(0, canvas.height / 2);
    canvasCtx.lineTo(canvas.width, canvas.height / 2);
    canvasCtx.stroke();
    
    // Draw waveform
    if (waveformBuffer.length > 1) {
        const samplesPerPixel = Math.max(1, Math.floor(waveformBuffer.length / canvas.width));
        const centerY = canvas.height / 2;
        
        canvasCtx.beginPath();
        
        for (let x = 0; x < canvas.width; x++) {
            const bufferIndex = Math.floor((x / canvas.width) * waveformBuffer.length);
            
            // Get min and max for this pixel column (like Audacity does)
            let min = 255;
            let max = 0;
            
            for (let s = 0; s < samplesPerPixel && bufferIndex + s < waveformBuffer.length; s++) {
                const value = waveformBuffer[bufferIndex + s];
                min = Math.min(min, value);
                max = Math.max(max, value);
            }
            
            // Convert to screen coordinates
            const yMin = centerY - ((min - 128) / 128) * (canvas.height / 2);
            const yMax = centerY - ((max - 128) / 128) * (canvas.height / 2);
            
            // Draw vertical line for this pixel
            canvasCtx.moveTo(x, yMin);
            canvasCtx.lineTo(x, yMax);
        }
        
        const gradient = canvasCtx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, accentColor1);
        gradient.addColorStop(1, accentColor2);
        canvasCtx.strokeStyle = gradient;
        canvasCtx.lineWidth = 1;
        canvasCtx.stroke();
    }
}
    };
    
    draw();
}

        function stopVisualizer() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            // Clear canvas
            const bgColor = '#0f0f0f';
            canvasCtx.fillStyle = bgColor;
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            barHeights = [];
            barFallSpeeds = [];
        }

function setupAudioSource() {
    // Detect if we're on iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (!isAudioContextSetup && audioContext && !isIOS) {
        // Only use Web Audio API on non-iOS devices
        sourceNode = audioContext.createMediaElementSource(audioPlayer);
        sourceNode.connect(gainNode);
        isAudioContextSetup = true;
        console.log('Web Audio API connected (desktop mode)');
    } else if (isIOS) {
        console.log('iOS detected - using direct audio playback for background compatibility');
        // On iOS, don't use Web Audio API - just play directly
        // This sacrifices normalization but enables background playback
        isAudioContextSetup = true; // Set to true to prevent trying again
    }
}

        // Calculate RMS (Root Mean Square) for loudness
        function calculateRMS() {
            if (!analyserNode) return 0;
            
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            analyserNode.getFloatTimeDomainData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i] * dataArray[i];
            }
            
            return Math.sqrt(sum / bufferLength);
        }

        // Variables for hybrid normalization
        let trackStartTime = 0;
        let initialGainSet = false;
        let rmsHistory = [];
        const INITIAL_ANALYSIS_DURATION = 200; // ms - analyze first 200ms quickly
        const FAST_RESPONSE_DURATION = 2000; // ms - fast response for first 2 seconds

        // Normalize audio levels with hybrid approach
        function normalizeAudio() {
            if (!isNormalized || !gainNode) return;
            
            const rms = calculateRMS();
            if (rms < 0.001) return; // Avoid division by very small numbers
            
            const targetRMS = 0.1; // Target loudness level
            const maxGain = 3.0; // Maximum gain multiplier
            const minGain = 0.3; // Minimum gain multiplier
            const currentTime = Date.now();
            const timeSinceStart = currentTime - trackStartTime;
            
            // Calculate desired gain
            let desiredGain = targetRMS / rms;
            desiredGain = Math.max(minGain, Math.min(maxGain, desiredGain));
            
            // Adaptive smoothing based on how long track has been playing
            let smoothing;
            if (timeSinceStart < INITIAL_ANALYSIS_DURATION) {
                // Very fast initial response - almost instant
                smoothing = 0.8;
                rmsHistory.push(rms);
            } else if (timeSinceStart < FAST_RESPONSE_DURATION) {
                // Fast response in first 2 seconds
                smoothing = 0.3;
            } else {
                // Smooth and stable after 2 seconds
                smoothing = 0.05;
            }
            
            const currentGain = gainNode.gain.value;
            const newGain = currentGain + (desiredGain - currentGain) * smoothing;
            
            gainNode.gain.setValueAtTime(newGain, audioContext.currentTime);
        }

        // Start normalization monitoring with faster initial interval
        let normalizationInterval;
        function startNormalization() {
            if (normalizationInterval) clearInterval(normalizationInterval);
            
            trackStartTime = Date.now();
            initialGainSet = false;
            rmsHistory = [];
            
            if (isNormalized && audioContext) {
                // Start with very fast polling for initial analysis
                let checkCount = 0;
                const fastInterval = 20; // Check every 20ms initially
                const normalInterval = 100; // Then every 100ms
                
                normalizationInterval = setInterval(() => {
                    normalizeAudio();
                    checkCount++;
                    
                    // After initial fast response period, switch to normal interval
                    if (checkCount * fastInterval >= FAST_RESPONSE_DURATION) {
                        clearInterval(normalizationInterval);
                        normalizationInterval = setInterval(normalizeAudio, normalInterval);
                    }
                }, fastInterval);
            }
        }

        function stopNormalization() {
            if (normalizationInterval) {
                clearInterval(normalizationInterval);
                normalizationInterval = null;
            }
        }

        function toggleNormalization() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    
    if (isIOS) {
        alert('Audio normalization is not available on iOS to enable background playback.');
        normalizeBtn.classList.remove('active');
        normalizeBtn.style.background = '';
        normalizeBtn.style.color = '';
        return;
    }
    
    initAudioContext();
    isNormalized = !isNormalized;
            
            if (isNormalized) {
                normalizeBtn.classList.add('active');
                normalizeBtn.style.background = currentAccentGradient;
                normalizeBtn.style.color = '#1a1a1a';
                normalizeBtn.style.borderColor = accentColor1;
                if (isPlaying) {
                    startNormalization();
                }
            } else {
                normalizeBtn.classList.remove('active');
                normalizeBtn.style.background = '';
                normalizeBtn.style.color = '';
                normalizeBtn.style.borderColor = accentColor1;
                stopNormalization();
                // Reset gain to 1.0 when disabled
                if (gainNode) {
                    gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
                }
            }
        }

        // Toggle sort order
function toggleSortOrder() {
    sortAscending = !sortAscending;
    const btn = document.getElementById('sortOrderBtn');
    btn.textContent = sortAscending ? '‚Üì' : '‚Üë';
    updateAudioFilesList();
}

// Sort files based on current sort settings
function sortFiles(files) {
    const sorted = [...files];
    
    if (sortBy === 'name') {
        sorted.sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();
            return sortAscending ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
        });
    } else if (sortBy === 'modified') {
        sorted.sort((a, b) => {
            const dateA = a.lastModified || 0;
            const dateB = b.lastModified || 0;
            return sortAscending ? dateA - dateB : dateB - dateA;
        });
    } else if (sortBy === 'size') {
        sorted.sort((a, b) => {
            const sizeA = a.size || 0;
            const sizeB = b.size || 0;
            return sortAscending ? sizeA - sizeB : sizeB - sizeA;
        });
    }
    
    return sorted;
}

// Scroll to currently playing song
function scrollToCurrentSong() {
    if (audioFiles.length === 0 || currentIndex < 0) return;
    
    const playlistItems = playlist.querySelectorAll('.playlist-item');
    if (playlistItems[currentIndex]) {
        playlistItems[currentIndex].scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });
    }
}

// Reset speed to 100%
function resetSpeed() {
    speedSlider.value = 100;
    speedValue.textContent = 100;
    audioPlayer.playbackRate = 1.0;
    audioPlayer.preservesPitch = false;
}

async function selectFolder() {
    // Check if File System Access API is supported (Chrome/Edge desktop)
    if ('showDirectoryPicker' in window) {
        try {
            const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
            audioFiles = [];
            fileHandles.clear();
            
            // Load or create configuration file
            await loadOrCreateConfig(dirHandle);
            
            async function loadFilesRecursively(dirHandle, path = '') {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        if (file.type.startsWith('audio/') || file.name.endsWith('.mp3')) {
                            audioFiles.push(file);
                            fileHandles.set(file.name, entry);
                        }
                    } else if (entry.kind === 'directory') {
                        await loadFilesRecursively(entry, path + entry.name + '/');
                    }
                }
            }

            await loadFilesRecursively(dirHandle);

            if (audioFiles.length === 0) {
                playlist.innerHTML = '<div class="empty-state">No audio files found in the selected folder.</div>';
                return;
            }

            originalOrder = sortFiles(audioFiles);
            audioFiles = [...originalOrder];
            
            buildMasterTagsFromConfig();
            displayPlaylist();
            renderFilterTags();
            restoreFilterModeUI();
            updateWriteEditsStatus();

            console.log('Loaded', audioFiles.length, 'songs');
            console.log('Master tags:', masterTags);

            setTimeout(() => {
                updateAudioFilesList();
                console.log('Applied saved filter tags:', Array.from(selectedFilterTags));
            }, 500);
            
        } catch (err) {
            console.error('Error accessing folder:', err);
        }
    } else {
        // Fallback for mobile/iOS - use file input
        useMobileFileInput();
    }
}

// Mobile fallback function
function useMobileFileInput() {
    // Create a container for file inputs
    const inputContainer = document.createElement('div');
    inputContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1a1a1a;
        padding: 30px;
        border-radius: 15px;
        border: 2px solid ${accentColor1};
        z-index: 3000;
        max-width: 90%;
    `;
    
    inputContainer.innerHTML = `
        <h3 style="color: ${accentColor1}; margin-bottom: 20px; text-align: center;">Select Files (Mobile Mode)</h3>
        <p style="color: #e0e0e0; margin-bottom: 15px; font-size: 14px;">First, select your config JSON file (optional):</p>
        <button id="selectConfigBtn" style="
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            color: ${accentColor1};
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 15px;
        ">Select Config JSON</button>
        <p id="configStatus" style="color: #999; margin-bottom: 15px; font-size: 12px; text-align: center;">No config selected</p>
        <p style="color: #e0e0e0; margin-bottom: 15px; font-size: 14px;">Then, select your music files:</p>
        <button id="selectMusicBtn" style="
            width: 100%;
            padding: 12px;
            background: ${accentColor1};
            color: #1a1a1a;
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 15px;
        ">Select Music Files</button>
        <button id="cancelBtn" style="
            width: 100%;
            padding: 12px;
            background: transparent;
            color: ${accentColor1};
            border: 2px solid ${accentColor1};
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        ">Cancel</button>
    `;
    
    document.body.appendChild(inputContainer);
    
    let configLoaded = false;
    
    // Config file selector
    document.getElementById('selectConfigBtn').onclick = () => {
        const configInput = document.createElement('input');
        configInput.type = 'file';
        configInput.accept = '.json';
        
        configInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    const loadedConfig = JSON.parse(text);
                    
                    // Load the config
                    if (loadedConfig.songs) {
                        songConfig = loadedConfig.songs;
                    } else {
                        songConfig = loadedConfig;
                    }
                    
                    if (loadedConfig.songDurations) {
                        songDurations = loadedConfig.songDurations;
                    }
                    
                    if (loadedConfig.masterTags) {
                        Object.keys(PREDEFINED_TAGS).forEach(tagName => {
                            if (!loadedConfig.masterTags[tagName]) {
                                loadedConfig.masterTags[tagName] = {
                                    category: PREDEFINED_TAGS[tagName],
                                    songCount: 0
                                };
                            }
                        });
                        masterTags = loadedConfig.masterTags;
                    } else {
                        buildMasterTagsFromConfig();
                    }
                    
                    if (loadedConfig.appSettings) {
                        const settings = loadedConfig.appSettings;
                        
                        if (settings.accentColor1 && settings.accentColor2) {
                            updateAccentColors(settings.accentColor1, settings.accentColor2);
                            document.getElementById('accentColorPicker1').value = settings.accentColor1;
                            document.getElementById('accentColorPicker2').value = settings.accentColor2;
                        }
                        
                        if (settings.volume !== null && settings.volume !== undefined) {
                            volumeSlider.value = settings.volume;
                            volumeValue.textContent = settings.volume;
                            audioPlayer.volume = settings.volume / 100;
                        }
                        
                        if (settings.useSavedSpeed !== null && settings.useSavedSpeed !== undefined) {
                            useSavedSpeed = settings.useSavedSpeed;
                            const checkbox = document.getElementById('useSavedSpeedCheckbox');
                            if (checkbox) checkbox.checked = useSavedSpeed;
                        }
                        
                        if (settings.useSavedFades !== null && settings.useSavedFades !== undefined) {
                            useSavedFades = settings.useSavedFades;
                            const checkbox = document.getElementById('useSavedFadesCheckbox');
                            if (checkbox) checkbox.checked = useSavedFades;
                        }
                        
                        if (settings.prioritizeNewSongs !== null && settings.prioritizeNewSongs !== undefined) {
                            prioritizeNewSongs = settings.prioritizeNewSongs;
                            const checkbox = document.getElementById('prioritizeNewSongsCheckbox');
                            if (checkbox) checkbox.checked = prioritizeNewSongs;
                        }
                        
                        if (settings.selectedFilterTags && Array.isArray(settings.selectedFilterTags)) {
                            selectedFilterTags = new Set(settings.selectedFilterTags);
                        }
                        
                        if (settings.excludedFilterTags && Array.isArray(settings.excludedFilterTags)) {
                            excludedFilterTags = new Set(settings.excludedFilterTags);
                        }
                        
                        if (settings.tagFilterMode) {
                            tagFilterMode = settings.tagFilterMode;
                        }
                        
                        if (settings.tagSelectMode) {
                            tagSelectMode = settings.tagSelectMode;
                        }
                        
                        if (settings.tagMatchMode) {
                            tagMatchMode = settings.tagMatchMode;
                        }
                    }
                    
                    configLoaded = true;
                    document.getElementById('configStatus').textContent = `‚úì Config loaded: ${file.name}`;
                    document.getElementById('configStatus').style.color = '#4CAF50';
                    
                    console.log('Loaded configuration from JSON:', Object.keys(songConfig).length, 'songs');
                } catch (error) {
                    console.error('Error loading config:', error);
                    document.getElementById('configStatus').textContent = '‚úó Error loading config';
                    document.getElementById('configStatus').style.color = '#ff3333';
                }
            }
        };
        
        configInput.click();
    };
    
    // Music file selector
    document.getElementById('selectMusicBtn').onclick = () => {
        const musicInput = document.createElement('input');
        musicInput.type = 'file';
        musicInput.multiple = true;
        musicInput.accept = 'audio/*,.mp3,.m4a,.wav,.flac';
        
        musicInput.onchange = async (e) => {
            const files = Array.from(e.target.files);
            
            if (files.length === 0) {
                playlist.innerHTML = '<div class="empty-state">No audio files selected.</div>';
                return;
            }
            
            audioFiles = files.filter(file => 
                file.type.startsWith('audio/') || 
                file.name.match(/\.(mp3|m4a|wav|flac)$/i)
            );
            
            if (audioFiles.length === 0) {
                playlist.innerHTML = '<div class="empty-state">No valid audio files found.</div>';
                return;
            }
            
            // If no config was loaded, try localStorage as fallback
            if (!configLoaded) {
                loadConfigFromLocalStorage();
            }
            
            // Hide editing features in mobile mode
            hideMobileEditingFeatures();
            
            originalOrder = sortFiles(audioFiles);
            audioFiles = [...originalOrder];
            
            buildMasterTagsFromConfig();
            displayPlaylist();
            renderFilterTags();
            restoreFilterModeUI();
            
            console.log('Loaded', audioFiles.length, 'songs (mobile mode)');
            
            setTimeout(() => {
                updateAudioFilesList();
            }, 500);
            
            // Remove the input container
            document.body.removeChild(inputContainer);
        };
        
        musicInput.click();
    };
    
    // Cancel button
    document.getElementById('cancelBtn').onclick = () => {
        document.body.removeChild(inputContainer);
    };
}

// Hide editing features when in mobile mode
function hideMobileEditingFeatures() {
    // Hide the entire tagging section
    const taggingSection = document.querySelector('.tagging-section');
    if (taggingSection) {
        taggingSection.style.display = 'none';
    }
    
    // Hide the entire left column (visualizer section and settings)
    const mainContent = document.querySelector('.main-content');
    if (mainContent) {
        const leftColumn = mainContent.querySelector('div[style*="max-width: 35%"]');
        if (leftColumn) {
            leftColumn.style.display = 'none';
        }
        
        // Make the playlist take full width
        const playlistWrapper = mainContent.querySelector('.playlist-wrapper');
        if (playlistWrapper) {
            playlistWrapper.style.width = '100%';
            playlistWrapper.style.maxWidth = '100%';
        }
    }
    
    // Hide ONLY the save speed button (keep the checkbox!)
    const saveSpeedBtn = document.querySelector('.save-speed-btn');
    if (saveSpeedBtn) {
        saveSpeedBtn.style.display = 'none';
    }
    
    // Keep the "Use Saved" checkbox visible
    // (don't hide .speed-save-controls)
    
    // Hide ONLY the save fades button (keep the checkbox!)
    const saveFadesBtn = document.querySelector('.save-fades-btn');
    if (saveFadesBtn) {
        saveFadesBtn.style.display = 'none';
    }
    
    // Keep the "Use Saved" checkbox visible
    // (don't hide .fade-save-controls)
    
    // Hide trim button (but trim settings will still apply automatically)
    const trimBtn = document.querySelector('.trim-btn');
    if (trimBtn) {
        trimBtn.style.display = 'none';
    }
    
    // Hide the last two advanced control items (Merge JSON and Calculate Setlist)
    const settingItems = document.querySelectorAll('.setting-item');
    if (settingItems.length >= 2) {
        // Hide Merge JSON Configs (second to last)
        settingItems[settingItems.length - 2].style.display = 'none';
        // Hide Calculate Setlist Lengths (last)
        settingItems[settingItems.length - 1].style.display = 'none';
    }
    
    // Auto-enable "Use Saved" checkboxes on mobile
    const useSavedSpeedCheckbox = document.getElementById('useSavedSpeedCheckbox');
    if (useSavedSpeedCheckbox) {
        useSavedSpeedCheckbox.checked = true;
        useSavedSpeed = true;
    }
    
    const useSavedFadesCheckbox = document.getElementById('useSavedFadesCheckbox');
    if (useSavedFadesCheckbox) {
        useSavedFadesCheckbox.checked = true;
        useSavedFades = true;
    }
    
    console.log('Mobile editing features hidden - Use Saved options enabled');
}

// Load config from localStorage (mobile fallback)
function loadConfigFromLocalStorage() {
    try {
        const savedConfig = localStorage.getItem('u-groove-config');
        if (savedConfig) {
            const loadedConfig = JSON.parse(savedConfig);
            
            if (loadedConfig.songs) {
                songConfig = loadedConfig.songs;
            } else {
                songConfig = loadedConfig;
            }
            
            if (loadedConfig.masterTags) {
                Object.keys(PREDEFINED_TAGS).forEach(tagName => {
                    if (!loadedConfig.masterTags[tagName]) {
                        loadedConfig.masterTags[tagName] = {
                            category: PREDEFINED_TAGS[tagName],
                            songCount: 0
                        };
                    }
                });
                masterTags = loadedConfig.masterTags;
            } else {
                buildMasterTagsFromConfig();
            }
            
            console.log('Loaded configuration from localStorage');
        }
        
        // Also load mobile-specific settings
        const mobileSettings = localStorage.getItem('u-groove-mobile-settings');
        if (mobileSettings) {
            const settings = JSON.parse(mobileSettings);
            if (settings.appSettings) {
                const s = settings.appSettings;
                
                if (s.selectedFilterTags) selectedFilterTags = new Set(s.selectedFilterTags);
                if (s.excludedFilterTags) excludedFilterTags = new Set(s.excludedFilterTags);
                if (s.tagFilterMode) tagFilterMode = s.tagFilterMode;
                if (s.tagSelectMode) tagSelectMode = s.tagSelectMode;
                if (s.tagMatchMode) tagMatchMode = s.tagMatchMode;
            }
        }
    } catch (error) {
        console.error('Error loading config from localStorage:', error);
        songConfig = {};
    }
}


function displayPlaylist() {
    playlist.innerHTML = '';
    audioFiles.forEach((file, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        
        if (multiSelectMode) {
            item.classList.add('has-checkbox');
            
            // Add checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'playlist-item-checkbox';
            checkbox.checked = selectedSongs.has(file.name);
            checkbox.onclick = (e) => toggleSongSelection(e, file);
            item.appendChild(checkbox);
            
            // Add text span that's clickable for playing
            const textSpan = document.createElement('span');
            textSpan.className = 'playlist-item-text';
            textSpan.textContent = file.name;
            textSpan.onclick = () => playTrack(index);
            item.appendChild(textSpan);
        } else {
            item.textContent = file.name;
            item.onclick = () => playTrack(index);
        }
        
        playlist.appendChild(item);
    });
    updatePlaylistHighlight();
    updateSongCounter();
}

function updateSongCounter() {
    const counter = document.getElementById('songCounter');
    const count = audioFiles.length;
    
    // Calculate total duration from stored durations
    let totalDuration = 0;
    let songsWithDuration = 0;
    
    audioFiles.forEach(file => {
        if (songDurations[file.name]) {
            const config = getSongConfig(file.name);
            // Use trim duration if available, otherwise full duration
            if (config.trimEnd && config.trimStart !== null) {
                totalDuration += (config.trimEnd - (config.trimStart || 0));
            } else if (config.trimEnd) {
                totalDuration += config.trimEnd;
            } else {
                totalDuration += songDurations[file.name];
            }
            songsWithDuration++;
        }
    });
    
    // Format total duration
    let durationText = '';
    if (songsWithDuration > 0) {
        const hours = Math.floor(totalDuration / 3600);
        const minutes = Math.floor((totalDuration % 3600) / 60);
        
        if (hours > 0) {
            durationText = ` (${hours}h ${minutes}m)`;
        } else if (minutes > 0) {
            durationText = ` (${minutes}m)`;
        } else {
            const seconds = Math.floor(totalDuration);
            durationText = ` (${seconds}s)`;
        }
    }
    
    counter.textContent = `${count} song${count !== 1 ? 's' : ''}${durationText}`;
    
    // Apply accent color to border
    counter.style.borderColor = accentColor1;
}

// Get duration of a song without playing it
async function getSongDuration(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const tempContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
        await tempContext.close();
        return audioBuffer.duration;
    } catch (error) {
        console.error('Error getting duration for', file.name, error);
        return 0;
    }
}

// Load durations for all songs in the library (called once when folder is selected)
function updateDurationStatus() {
    const statusEl = document.getElementById('durationStatus');
    const calculateBtn = document.getElementById('calculateDurationsBtn');
    
    if (!statusEl || !calculateBtn) {
        console.warn('Duration status elements not found');
        return;
    }
    
    if (!originalOrder || originalOrder.length === 0) {
        statusEl.textContent = 'No folder selected';
        calculateBtn.disabled = true;
        return;
    }
    
    const totalSongs = originalOrder.length;
    const calculatedSongs = originalOrder.filter(file => songDurations[file.name]).length;
    
    if (calculatedSongs === 0) {
        statusEl.textContent = 'Not yet calculated';
        statusEl.style.color = '#999';
        calculateBtn.disabled = false;
    } else if (calculatedSongs < totalSongs) {
        statusEl.textContent = `Partially calculated (${calculatedSongs}/${totalSongs} songs)`;
        statusEl.style.color = '#ff8c42';
        calculateBtn.disabled = false;
    } else {
        statusEl.textContent = `‚úì All ${totalSongs} songs calculated`;
        statusEl.style.color = '#4CAF50';
        calculateBtn.disabled = false;
    }
    
    updateSongCounter();
}

// Manual duration calculation function
async function calculateAllDurations() {
    if (!originalOrder || originalOrder.length === 0) {
        alert('Please select a music folder first');
        return;
    }
    
    const calculateBtn = document.getElementById('calculateDurationsBtn');
    const statusEl = document.getElementById('durationStatus');
    
    // Disable button and show progress
    calculateBtn.disabled = true;
    calculateBtn.textContent = 'Calculating...';
    
    console.log('Starting duration calculation for', originalOrder.length, 'songs...');
    
    let loaded = 0;
    let skipped = 0;
    
    for (const file of originalOrder) {
        // Skip if already calculated
        if (songDurations[file.name]) {
            skipped++;
            continue;
        }
        
        const duration = await getSongDuration(file);
        songDurations[file.name] = duration;
        loaded++;
        
        // Update status every 5 songs
        if (loaded % 5 === 0) {
            statusEl.textContent = `Calculating... ${loaded + skipped}/${originalOrder.length}`;
            updateSongCounter();
        }
    }
    
    console.log(`Finished! Calculated ${loaded} new durations, skipped ${skipped} already calculated`);
    
    // Save to config
    await saveConfig();
    
    // Re-enable button and update status
    calculateBtn.disabled = false;
    calculateBtn.textContent = 'Run';
    updateDurationStatus();
    
}

// Count songs that need to be duplicated
function countSongsNeedingDuplication() {
    let count = 0;
    
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        
        // Skip if already duped
        if (config.duped === true) return;
        
        // Check if song has edits
        const hasSpeedEdit = config.speed !== null && config.speed !== 100;
        const hasTrimStart = config.trimStart !== null && config.trimStart !== 0;
        const hasTrimEnd = config.trimEnd !== null && config.trimEnd !== 0;
        const hasFadeIn = config.FI && config.FI > 0;
        const hasFadeOut = config.FO && config.FO > 0;
        
        if (hasSpeedEdit || hasTrimStart || hasTrimEnd || hasFadeIn || hasFadeOut) {
            count++;
        }
    });
    
    return count;
}

// Update write edits status
function updateWriteEditsStatus() {
    const statusEl = document.getElementById('writeEditsStatus');
    if (!statusEl) {
        console.warn('writeEditsStatus element not found');
        return;
    }
    
    const count = countSongsNeedingDuplication();
    
    if (count === 0) {
        statusEl.textContent = 'No songs with edits found';
        statusEl.style.color = '#999';
    } else {
        statusEl.textContent = `${count} song${count !== 1 ? 's' : ''} will be processed`;
        statusEl.style.color = '#ff6b35';
    }
}

// Process audio with effects
async function processAudioFile(file, config) {
    try {
        // Load the audio file
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        const originalDuration = audioBuffer.duration;
        const sampleRate = audioBuffer.sampleRate;
        const numberOfChannels = audioBuffer.numberOfChannels;
        
        // Calculate new duration based on trim and speed
        const trimStart = config.trimStart || 0;
        const trimEnd = config.trimEnd || originalDuration;
        const trimmedDuration = trimEnd - trimStart;
        const speed = (config.speed || 100) / 100;
        const newDuration = trimmedDuration / speed;
        
        // Create offline context for processing
        const offlineContext = new OfflineAudioContext(
            numberOfChannels,
            Math.ceil(newDuration * sampleRate),
            sampleRate
        );
        
        // Create source
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        source.playbackRate.value = speed;
        
        // Create gain node for fading
        const gainNode = offlineContext.createGain();
        source.connect(gainNode);
        gainNode.connect(offlineContext.destination);
        
        // Apply fade in
        const fadeIn = config.FI || 0;
        if (fadeIn > 0) {
            gainNode.gain.setValueAtTime(0, 0);
            gainNode.gain.linearRampToValueAtTime(1, fadeIn);
        } else {
            gainNode.gain.setValueAtTime(1, 0);
        }
        
        // Apply fade out
        const fadeOut = config.FO || 0;
        if (fadeOut > 0) {
            gainNode.gain.setValueAtTime(1, newDuration - fadeOut);
            gainNode.gain.linearRampToValueAtTime(0, newDuration);
        }
        
        // Start playback from trim start
        source.start(0, trimStart, trimmedDuration);
        
        // Render the audio
        const renderedBuffer = await offlineContext.startRendering();
        
        // Convert to MP3 instead of WAV
        const mp3Blob = await audioBufferToMp3(renderedBuffer);
        
        await audioContext.close();
        
        return mp3Blob;
        
    } catch (error) {
        console.error('Error processing audio:', error);
        throw error;
    }
}

// Convert Float32 to Int16 for MP3 encoding
function convertFloat32ToInt16(buffer) {
    const l = buffer.length;
    const buf = new Int16Array(l);
    for (let i = 0; i < l; i++) {
        const s = Math.max(-1, Math.min(1, buffer[i]));
        buf[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return buf;
}

// Convert AudioBuffer to MP3 blob
async function audioBufferToMp3(buffer, bitrate = 192) {
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const samples = buffer.length;
    
    // Prepare channel data
    const leftChannel = buffer.getChannelData(0);
    const rightChannel = channels > 1 ? buffer.getChannelData(1) : leftChannel;
    
    // Convert to 16-bit PCM
    const leftData = convertFloat32ToInt16(leftChannel);
    const rightData = convertFloat32ToInt16(rightChannel);
    
    // Encode to MP3
    const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
    const mp3Data = [];
    
    const sampleBlockSize = 1152;
    for (let i = 0; i < samples; i += sampleBlockSize) {
        const leftChunk = leftData.subarray(i, i + sampleBlockSize);
        const rightChunk = rightData.subarray(i, i + sampleBlockSize);
        const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
        if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
        }
    }
    
    const mp3buf = mp3encoder.flush();
    if (mp3buf.length > 0) {
        mp3Data.push(mp3buf);
    }
    
    return new Blob(mp3Data, { type: 'audio/mp3' });
}

// Write song edits to copies
async function writeSongEdits() {
    if (!configDirHandle) {
        alert('Please select a music folder first');
        return;
    }
    
    const writeBtn = document.getElementById('writeSongEditsBtn');
    const statusEl = document.getElementById('writeEditsStatus');
    
    // Get songs that need processing
    const songsToProcess = [];
    Object.keys(songConfig).forEach(filename => {
        const config = songConfig[filename];
        
        // Skip if already duped
        if (config.duped === true) return;
        
        // Check if song has edits
        const hasSpeedEdit = config.speed !== null && config.speed !== 100;
        const hasTrimStart = config.trimStart !== null && config.trimStart !== 0;
        const hasTrimEnd = config.trimEnd !== null && config.trimEnd !== 0;
        const hasFadeIn = config.FI && config.FI > 0;
        const hasFadeOut = config.FO && config.FO > 0;
        
        if (hasSpeedEdit || hasTrimStart || hasTrimEnd || hasFadeIn || hasFadeOut) {
            songsToProcess.push({ filename, config });
        }
    });
    
    if (songsToProcess.length === 0) {
        alert('No songs with edits found');
        return;
    }
    
    const confirmed = confirm(`This will process ${songsToProcess.length} song(s). Original files will be moved to an "Original from duped" folder. This may take a while. Continue?`);
    if (!confirmed) return;
    
    // Disable button
    writeBtn.disabled = true;
    writeBtn.textContent = 'Processing...';
    
    try {
        // Create or get "Original from duped" folder
        let originalsFolder;
        try {
            originalsFolder = await configDirHandle.getDirectoryHandle('Original from duped', { create: true });
        } catch (error) {
            console.error('Error creating originals folder:', error);
            alert('Could not create "Original from duped" folder');
            return;
        }
        
        let processed = 0;
        
        for (const { filename, config } of songsToProcess) {
            try {
                statusEl.textContent = `Processing ${processed + 1}/${songsToProcess.length}: ${filename}`;
                
                // Get the original file handle
                const fileHandle = fileHandles.get(filename);
                if (!fileHandle) {
                    console.warn(`File handle not found for ${filename}`);
                    continue;
                }
                
                const file = await fileHandle.getFile();
                
                // Process the audio
                // Process the audio
                const processedBlob = await processAudioFile(file, config);
                
                // Get file extension and create names
                const lastDotIndex = filename.lastIndexOf('.');
                const nameWithoutExt = filename.substring(0, lastDotIndex);
                const ext = filename.substring(lastDotIndex);
                const originalName = `${nameWithoutExt} (original)${ext}`;
                
                // For the processed file, change extension to .wav
                const processedName = `${nameWithoutExt}.mp3`;
                
                // Step 1: Copy original file to "Original from duped" folder with (original) name
                const originalFileHandle = await originalsFolder.getFileHandle(originalName, { create: true });
                const originalWritable = await originalFileHandle.createWritable();
                await originalWritable.write(await file.arrayBuffer());
                await originalWritable.close();
                
                // Step 2: Delete the original file from its location
                // Note: We can't directly delete using File System Access API, so we'll just overwrite
                
                // Step 3: Write the processed file as a new .wav file
                const processedFileHandle = await configDirHandle.getFileHandle(processedName, { create: true });
                const processedWritable = await processedFileHandle.createWritable();
                await processedWritable.write(processedBlob);
                await processedWritable.close();
                
                // Update config for original file in "Original from duped" folder
                // Copy all the original settings so it sounds the same
                updateSongConfig(originalName, {
                    tags: ['Original from duped'],
                    speed: config.speed,
                    trimStart: config.trimStart,
                    trimEnd: config.trimEnd,
                    FI: config.FI,
                    FO: config.FO,
                    heardb4: config.heardb4,
                    duped: false
                });
                
                // Update config for processed file (keep tags, reset edits, mark as duped)
                updateSongConfig(processedName, {
                    tags: config.tags,
                    speed: null,
                    trimStart: null,
                    trimEnd: null,
                    FI: 0,
                    FO: 0,
                    duped: true
                });
                
                // Update the file handle reference
                fileHandles.set(processedName, processedFileHandle);
                
                processed++;
                console.log(`Processed: ${filename} ‚Üí ${processedName} (original saved as ${originalName})`);
                
            } catch (error) {
                console.error(`Error processing ${filename}:`, error);
            }
        }
        
        // Add "Original from duped" to master tags if not already there
        if (!masterTags['Original from duped']) {
            masterTags['Original from duped'] = {
                category: 'Utility',
                songCount: processed
            };
        } else {
            masterTags['Original from duped'].songCount += processed;
        }
        
        // Save config
        await saveConfig();
        
        // Rebuild master tags
        buildMasterTagsFromConfig();
        
        alert(`Successfully processed ${processed} song(s)! Originals have been moved to "Original from duped" folder. The edited versions have replaced the original files in their original locations.`);
        
        // Update status
        updateWriteEditsStatus();
        
    } catch (error) {
        console.error('Error writing song edits:', error);
        alert('An error occurred while processing songs. Check console for details.');
    } finally {
        writeBtn.disabled = false;
        writeBtn.textContent = 'Write Edits';
    }
}

// Get duration of a song without playing it
async function getSongDuration(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const tempContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
        await tempContext.close();
        return audioBuffer.duration;
    } catch (error) {
        console.error('Error getting duration for', file.name, error);
        return 0;
    }
}

// Load durations for all songs in the current list
async function loadAllSongDurations() {
    console.log('Loading durations for', audioFiles.length, 'songs...');
    
    for (const file of audioFiles) {
        if (!songDurations[file.name]) {
            const duration = await getSongDuration(file);
            songDurations[file.name] = duration;
        }
    }
    
    console.log('Finished loading durations');
    updateSongCounter();
}

function updatePlaylistHighlight() {
    const items = playlist.querySelectorAll('.playlist-item');
    items.forEach((item, index) => {
        item.classList.remove('active', 'playing');
        item.style.background = '';
        item.style.color = '';
        
        // Only highlight if currentIndex is valid and matches
        if (currentIndex !== -1 && index === currentIndex) {
            item.classList.add('active');
            item.style.background = currentAccentGradient;
            item.style.color = '#1a1a1a';
            if (isPlaying) {
                item.classList.add('playing');
            }
        }
    });
}

        // Get fresh file from handle, with retry logic
async function getFreshFileFromHandle(filename, retries = 3) {
    const handle = fileHandles.get(filename);
    if (!handle) return null;
    
    for (let i = 0; i < retries; i++) {
        try {
            const file = await handle.getFile();
            return file;
        } catch (error) {
            console.warn(`Attempt ${i + 1} to get fresh file failed:`, error);
            if (i < retries - 1) {
                await new Promise(resolve => setTimeout(resolve, 200 * (i + 1)));
            }
        }
    }
    
    console.error(`Failed to get fresh file after ${retries} attempts`);
    return null;
}

// Enable background playback and media controls
function setupMediaSession(file) {
    if ('mediaSession' in navigator) {
        const config = getSongConfig(file.name);
        const tagCount = config.tags ? config.tags.length : 0;
        
        navigator.mediaSession.metadata = new MediaMetadata({
            title: file.name,
            artist: tagCount > 0 ? `${tagCount} tag${tagCount !== 1 ? 's' : ''}` : 'U-Groove',
            album: 'U-Groove Player',
            artwork: [
                { src: getFaviconDataUrl(), sizes: '512x512', type: 'image/png' }
            ]
        });
        
        // Set up action handlers for car controls
        navigator.mediaSession.setActionHandler('play', () => {
            audioPlayer.play();
            isPlaying = true;
            playBtn.textContent = '‚∏®';
            if (document.getElementById('playBtnCompact')) {
                document.getElementById('playBtnCompact').textContent = '‚∏®';
            }
        });
        
        navigator.mediaSession.setActionHandler('pause', () => {
            audioPlayer.pause();
            isPlaying = false;
            playBtn.textContent = '‚ñ∂';
            if (document.getElementById('playBtnCompact')) {
                document.getElementById('playBtnCompact').textContent = '‚ñ∂';
            }
        });
        
        navigator.mediaSession.setActionHandler('previoustrack', () => {
            previousTrack();
        });
        
        navigator.mediaSession.setActionHandler('nexttrack', () => {
            nextTrack();
        });
        
        // Optional: seek handlers for car controls
        navigator.mediaSession.setActionHandler('seekbackward', (details) => {
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - (details.seekOffset || 10));
        });
        
        navigator.mediaSession.setActionHandler('seekforward', (details) => {
            audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + (details.seekOffset || 10));
        });
        
        console.log('Media Session API configured for background playback');
    }
}

// Helper function to get favicon as data URL for media session artwork
function getFaviconDataUrl() {
    // Create a canvas with the U-Groove logo
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // Draw background
    ctx.fillStyle = '#231f20';
    ctx.fillRect(0, 0, 512, 512);
    
    // Draw circle with gradient
    const gradient = ctx.createLinearGradient(0, 0, 512, 512);
    gradient.addColorStop(0, accentColor1);
    gradient.addColorStop(1, accentColor2);
    
    ctx.beginPath();
    ctx.arc(256, 256, 200, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
    
    return canvas.toDataURL('image/png');
}

async function playTrack(index) {
    initAudioContext();
    
    // ENSURE AUDIO CONTEXT IS RUNNING (important for iOS)
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    
    // Stop any active fades
    stopFades();
    
    hasMarkedAsHeard = false;
    
    currentIndex = index;
    const file = audioFiles[currentIndex];
    currentlyPlayingFile = file;
    const url = URL.createObjectURL(file);
    audioPlayer.src = url;
    
    // SETUP MEDIA SESSION FOR BACKGROUND PLAYBACK
    setupMediaSession(file);
    
    // Setup audio source for Web Audio API on first play
    if (!isAudioContextSetup) {
        audioPlayer.addEventListener('loadedmetadata', () => {
            setupAudioSource();
        }, { once: true });
    }
    
    // Brief fade-in to mask initial normalization adjustment
    if (isNormalized && gainNode && audioContext) {
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.05);
    }
    
    audioPlayer.play();
    isPlaying = true;
    playBtn.textContent = '‚è∏';
    nowPlaying.textContent = `Now playing: ${file.name}`;

        // Update both now playing displays with tag count
    updateNowPlayingDisplay();
    updatePlaylistHighlight();

     // Get tag count for this song
    const config = getSongConfig(file.name);
    const tagCount = config.tags ? config.tags.length : 0;
    const tagCountText = tagCount > 0 ? ` (${tagCount} tag${tagCount !== 1 ? 's' : ''})` : '';

    updatePlaylistHighlight();
    
    if (isNormalized) {
        startNormalization();
    }

    stopVisualizer();
    // Start visualizer
    drawVisualizer();
    
    // Load tags for this song
    loadSongTags(file.name);

    // Load saved speed if checkbox is enabled
    if (useSavedSpeed) {
        loadSavedSpeed(file.name);
    }
    
    // Load saved fades if checkbox is enabled
    if (useSavedFades) {
        loadSavedFades(file.name);
    }
    
// Apply trim settings when metadata loads
    audioPlayer.addEventListener('loadedmetadata', () => {
        const config = getSongConfig(file.name);
        if (config.trimStart !== null && config.trimStart !== undefined) {
            audioPlayer.currentTime = config.trimStart;
        }
        
        // Apply fade in when song starts
        if (currentFadeInDuration > 0) {
            applyFadeIn();
        }
    }, { once: true });

    // Update compact player display
    if (collapsedSections.player) {
        updateCompactPlayer();
    }
}

async function togglePlay() {
    if (audioFiles.length === 0) return;
    
    // Ensure audio context is ready (iOS requirement)
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }

    if (isPlaying) {
        audioPlayer.pause();
        playBtn.textContent = '‚ñ∂';
        isPlaying = false;
        stopNormalization();
        stopVisualizer();
    } else {
        if (!audioPlayer.src) {
            await playTrack(0);
        } else {
            audioPlayer.play();
            playBtn.textContent = '‚è∏';
            isPlaying = true;
            if (isNormalized) {
                startNormalization();
            }
             // Only start if not already running
            if (!animationId) {
                drawVisualizer();
            }
        }
    }
    updatePlaylistHighlight();
}

async function nextTrack() {
    if (audioFiles.length === 0) return;
    
    console.log('nextTrack called');
    
    // Auto-save current speed if "Use Saved" is checked
    if (useSavedSpeed && currentlyPlayingFile) {
        const currentSpeed = parseInt(speedSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.speed !== currentSpeed) {
            updateSongConfig(currentlyPlayingFile.name, { speed: currentSpeed });
            await saveConfig();
        }
    }
    
    // Auto-save current fades if "Use Saved" is checked
    if (useSavedFades && currentlyPlayingFile) {
        const fadeIn = parseInt(fadeInSlider.value);
        const fadeOut = parseInt(fadeOutSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.FI !== fadeIn || config.FO !== fadeOut) {
            updateSongConfig(currentlyPlayingFile.name, { FI: fadeIn, FO: fadeOut });
            await saveConfig();
        }
    }
    
    // If current song is not in list (currentIndex is -1), start from beginning
    if (currentIndex === -1) {
        currentIndex = 0;
    } else {
        // Use the new function to get next index
        const nextIndex = getNextUnheardSongIndex('next');
        console.log('nextTrack will play index:', nextIndex);
        currentIndex = nextIndex;
    }
    
    await playTrack(currentIndex);
}

async function previousTrack() {
    if (audioFiles.length === 0) return;
    
    console.log('previousTrack called');
    
    // Auto-save current speed if "Use Saved" is checked
    if (useSavedSpeed && currentlyPlayingFile) {
        const currentSpeed = parseInt(speedSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.speed !== currentSpeed) {
            updateSongConfig(currentlyPlayingFile.name, { speed: currentSpeed });
            await saveConfig();
        }
    }
    
    // Auto-save current fades if "Use Saved" is checked
    if (useSavedFades && currentlyPlayingFile) {
        const fadeIn = parseInt(fadeInSlider.value);
        const fadeOut = parseInt(fadeOutSlider.value);
        const config = getSongConfig(currentlyPlayingFile.name);
        
        if (config.FI !== fadeIn || config.FO !== fadeOut) {
            updateSongConfig(currentlyPlayingFile.name, { FI: fadeIn, FO: fadeOut });
            await saveConfig();
        }
    }
    
    // If current song is not in list (currentIndex is -1), start from beginning
    if (currentIndex === -1) {
        currentIndex = 0;
    } else {
        // Use the new function to get next index
        const prevIndex = getNextUnheardSongIndex('previous');
        console.log('previousTrack will play index:', prevIndex);
        currentIndex = prevIndex;
    }
    
    await playTrack(currentIndex);
}


function toggleShuffle() {
    if (audioFiles.length === 0) return;
    
    isShuffled = !isShuffled;
    
    if (isShuffled) {
        shuffleBtn.classList.add('active');
        shuffleBtn.style.background = currentAccentGradient;
        shuffleBtn.style.color = '#1a1a1a';
        shuffleBtn.style.borderColor = accentColor1;
    } else {
        shuffleBtn.classList.remove('active');
        shuffleBtn.style.background = '';
        shuffleBtn.style.color = '';
        shuffleBtn.style.borderColor = accentColor1;
    }
    
    updateAudioFilesList();
    saveConfig(); // Save shuffle state
}

        function toggleLoop() {
            isLooping = !isLooping;
            audioPlayer.loop = isLooping;
            if (isLooping) {
                loopBtn.classList.add('active');
                loopBtn.style.background = currentAccentGradient;
                loopBtn.style.color = '#1a1a1a';
                loopBtn.style.borderColor = accentColor1;
            } else {
                loopBtn.classList.remove('active');
                loopBtn.style.background = '';
                loopBtn.style.color = '';
                loopBtn.style.borderColor = accentColor1;
            }
            saveConfig(); // Save loop state
        }

        function seekAudio(event) {
            if (!audioPlayer.src) return;
            const rect = event.currentTarget.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            audioPlayer.currentTime = pos * audioPlayer.duration;
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

audioPlayer.addEventListener('timeupdate', () => {
    const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressBar.style.width = progress + '%';
    currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
    
    // Check if song should be marked as heard
    if (prioritizeNewSongs) {
        checkAndMarkAsHeard();
    }
    
    // Check for fade out
    if (currentFadeOutDuration > 0 && !isFadingOut && !isFadingIn) {
        const timeRemaining = audioPlayer.duration - audioPlayer.currentTime;
        if (timeRemaining <= currentFadeOutDuration && timeRemaining > 0) {
            applyFadeOut();
        }
    }
    
    // Check if we've reached the trim end point
    if (audioFiles.length > 0 && currentIndex >= 0) {
        const file = audioFiles[currentIndex];
        const config = getSongConfig(file.name);
        
        if (config.trimEnd !== null && config.trimEnd !== undefined) {
            if (audioPlayer.currentTime >= config.trimEnd) {
                // Trigger next track
                if (!isLooping) {
                    nextTrack();
                } else {
                    audioPlayer.currentTime = config.trimStart || 0;
                }
            }
        }
    }
    
    // Update compact view if collapsed
    if (collapsedSections.player) {
        updateCompactPlayer();
    }
});

        audioPlayer.addEventListener('loadedmetadata', () => {
            durationEl.textContent = formatTime(audioPlayer.duration);
        });

audioPlayer.addEventListener('ended', async () => {
    // Auto-save current speed if "Use Saved" is checked
    if (useSavedSpeed && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        const currentSpeed = parseInt(speedSlider.value);
        const config = getSongConfig(currentFile.name);
        
        if (config.speed !== currentSpeed) {
            updateSongConfig(currentFile.name, { speed: currentSpeed });
            await saveConfig();
            console.log('Auto-saved speed on track end:', currentFile.name, currentSpeed);
        }
    }
    
    // Auto-save current fades if "Use Saved" is checked
    if (useSavedFades && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        const fadeIn = parseInt(fadeInSlider.value);
        const fadeOut = parseInt(fadeOutSlider.value);
        const config = getSongConfig(currentFile.name);
        
        if (config.FI !== fadeIn || config.FO !== fadeOut) {
            updateSongConfig(currentFile.name, { FI: fadeIn, FO: fadeOut });
            await saveConfig();
            console.log('Auto-saved fades on track end:', currentFile.name, fadeIn, fadeOut);
        }
    }
    
    if (!isLooping) {
        await nextTrack();
    }
});

        // Collapse/expand functionality
const collapsedSections = {
    filter: false,
    tagging: false,
    visualizer: false,
    player: false
};

function toggleCollapse(section) {
    collapsedSections[section] = !collapsedSections[section];
    
    if (section === 'filter') {
        const content = document.getElementById('filterContent');
        const btn = document.getElementById('filterCollapseBtn');
        content.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
    } else if (section === 'tagging') {
        const content = document.getElementById('taggingContent');
        const btn = document.getElementById('taggingCollapseBtn');
        content.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
    } else if (section === 'visualizer') {
        const content = document.getElementById('visualizerContent');
        const btn = document.getElementById('visualizerCollapseBtn');
        content.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
    } else if (section === 'player') {
        const playerSection = document.getElementById('playerSection');
        const btn = document.getElementById('playerCollapseBtn');
        playerSection.classList.toggle('collapsed');
        btn.classList.toggle('collapsed');
        
        // Update compact view when collapsing
        if (collapsedSections[section]) {
            updateCompactPlayer();
        }
    }
}

// Adjust speed by increment
function adjustSpeed(increment) {
    const currentSpeed = parseInt(speedSlider.value);
    const newSpeed = Math.max(25, Math.min(200, currentSpeed + increment));
    speedSlider.value = newSpeed;
    speedValue.textContent = newSpeed;
    audioPlayer.playbackRate = newSpeed / 100;
    audioPlayer.preservesPitch = false;
}

// Visualizer toggle
function toggleVisualizer() {
    visualizerEnabled = !visualizerEnabled;
    const btn = document.getElementById('visualizerToggleBtn');
    btn.textContent = `Visualizer: ${visualizerEnabled ? 'ON' : 'OFF'}`;
    
    if (!visualizerEnabled) {
        // Clear canvas when disabled
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    }
}

// Set visualizer mode
function setVisualizerMode(mode) {
    visualizerMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#visualizerModeSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    let activeBtn;
    if (mode === 'frequency') {
        activeBtn = buttons[0];
    } else if (mode === 'waveform') {
        activeBtn = buttons[1];
    } else {
        activeBtn = buttons[2];
    }
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // Show/hide appropriate controls
    const frequencyControls = document.getElementById('frequencyControls');
    const waveformControls = document.getElementById('waveformControls');
    const bubbleControls = document.getElementById('bubbleControls');
    
    if (mode === 'frequency') {
        frequencyControls.style.display = 'block';
        waveformControls.style.display = 'none';
        bubbleControls.style.display = 'none';
    } else if (mode === 'waveform') {
        frequencyControls.style.display = 'none';
        waveformControls.style.display = 'block';
        bubbleControls.style.display = 'none';
    } else {
        frequencyControls.style.display = 'none';
        waveformControls.style.display = 'none';
        bubbleControls.style.display = 'block';
    }
}

// Tag match mode (AND/OR)
function setTagMatchMode(mode) {
    tagMatchMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#tagMatchSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    const activeBtn = mode === 'and' ? buttons[0] : buttons[1];
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // Save config
    saveConfig();
    
    // Re-filter the playlist
    updateAudioFilesList();
}

// Tag select mode (single/multi)
function setTagSelectMode(mode) {
    tagSelectMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#tagSelectSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    const activeBtn = mode === 'single' ? buttons[0] : buttons[1];
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // If switching to single select and multiple tags are selected, keep only the first
    if (mode === 'single' && selectedFilterTags.size > 1) {
        const firstTag = Array.from(selectedFilterTags)[0];
        selectedFilterTags.clear();
        selectedFilterTags.add(firstTag);
        renderFilterTags();
        updateAudioFilesList();
    }
    
    // Save config
    saveConfig();
}

// Tag filter mode (include/exclude)
function setTagFilterMode(mode) {
    tagFilterMode = mode;
    
    // Update button states
    const buttons = document.querySelectorAll('#tagFilterModeSwitch .toggle-option');
    buttons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    
    // Activate selected button
    const activeBtn = mode === 'include' ? buttons[0] : buttons[1];
    activeBtn.classList.add('active');
    activeBtn.style.background = currentAccentGradient;
    activeBtn.style.color = '#1a1a1a';
    
    // Save config
    saveConfig();
    
    // Re-render tags to show proper colors
    renderFilterTags();
}

// Restore filter mode UI from loaded settings
function restoreFilterModeUI() {
    // Restore tag filter mode (Include/Exclude)
    const filterModeButtons = document.querySelectorAll('#tagFilterModeSwitch .toggle-option');
    filterModeButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    const activeFilterBtn = tagFilterMode === 'include' ? filterModeButtons[0] : filterModeButtons[1];
    if (activeFilterBtn) {
        activeFilterBtn.classList.add('active');
        activeFilterBtn.style.background = currentAccentGradient;
        activeFilterBtn.style.color = '#1a1a1a';
    }
    
    // Restore tag select mode (Single/Multi)
    const selectModeButtons = document.querySelectorAll('#tagSelectSwitch .toggle-option');
    selectModeButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    const activeSelectBtn = tagSelectMode === 'single' ? selectModeButtons[0] : selectModeButtons[1];
    if (activeSelectBtn) {
        activeSelectBtn.classList.add('active');
        activeSelectBtn.style.background = currentAccentGradient;
        activeSelectBtn.style.color = '#1a1a1a';
    }
    
    // Restore tag match mode (AND/OR)
    const matchModeButtons = document.querySelectorAll('#tagMatchSwitch .toggle-option');
    matchModeButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
        btn.style.color = accentColor1;
    });
    const activeMatchBtn = tagMatchMode === 'and' ? matchModeButtons[0] : matchModeButtons[1];
    if (activeMatchBtn) {
        activeMatchBtn.classList.add('active');
        activeMatchBtn.style.background = currentAccentGradient;
        activeMatchBtn.style.color = '#1a1a1a';
    }
    
    console.log('Restored filter UI:', { tagFilterMode, tagSelectMode, tagMatchMode });
}

const bubbleComplexitySlider = document.getElementById('bubbleComplexitySlider');
const bubbleComplexityValue = document.getElementById('bubbleComplexityValue');
const bubbleFluiditySlider = document.getElementById('bubbleFluiditySlider');
const bubbleFluidityValue = document.getElementById('bubbleFluidityValue');

if (bubbleComplexitySlider) {
    bubbleComplexitySlider.addEventListener('input', (e) => {
        bubbleComplexityValue.textContent = e.target.value;
    });
}

if (bubbleFluiditySlider) {
    bubbleFluiditySlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        bubbleFluidityValue.textContent = value.toFixed(1);
    });
}
const bubbleMinFreqSlider = document.getElementById('bubbleMinFreqSlider');
const bubbleMinFreqValue = document.getElementById('bubbleMinFreqValue');
const bubbleMaxFreqSlider = document.getElementById('bubbleMaxFreqSlider');
const bubbleMaxFreqValue = document.getElementById('bubbleMaxFreqValue');

if (bubbleMinFreqSlider) {
    bubbleMinFreqSlider.addEventListener('input', (e) => {
        bubbleMinFreqValue.textContent = e.target.value;
    });
}

if (bubbleMaxFreqSlider) {
    bubbleMaxFreqSlider.addEventListener('input', (e) => {
        bubbleMaxFreqValue.textContent = e.target.value;
    });
}

// Toggle use saved speed
function toggleUseSavedSpeed() {
    useSavedSpeed = document.getElementById('useSavedSpeedCheckbox').checked;
    
    // If enabling and there's a current song, load its saved speed
    if (useSavedSpeed && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        loadSavedSpeed(currentFile.name);
    }
    
    // Save setting
    saveConfig();
}

// Save speed for current song
async function saveSpeed() {
    if (!currentlyPlayingFile) {
        console.warn('No song currently playing');
        return;
    }
    if (currentlyPlayingFile) {
        markAsNotDuped(currentlyPlayingFile.name);
    }
    const currentFile = currentlyPlayingFile;
    const currentSpeed = parseInt(speedSlider.value);
    
    // Update configuration
    updateSongConfig(currentFile.name, { speed: currentSpeed });
    
    // Save configuration file
    await saveConfig();
    
    console.log(`Speed saved: ${currentFile.name}: ${currentSpeed}%`);
    
    // Visual feedback
    const saveBtn = document.querySelector('.save-speed-btn');
    if (saveBtn) {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = '‚úì Saved';
        saveBtn.style.background = currentAccentGradient;
        saveBtn.style.color = '#1a1a1a';
        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
            saveBtn.style.color = '';
        }, 1500);
    }
}

// Load saved speed for a song
function loadSavedSpeed(filename) {
    const config = getSongConfig(filename);
    let savedSpeed = 100; // Default to 100%
    
    if (config.speed !== null && config.speed !== undefined) {
        savedSpeed = config.speed;
        console.log(`Loaded saved speed for ${filename}: ${savedSpeed}%`);
    } else {
        console.log(`No saved speed for ${filename}, using default: 100%`);
    }
    
    // Always update the slider and playback rate, even if it's the default
    speedSlider.value = savedSpeed;
    speedValue.textContent = savedSpeed;
    audioPlayer.playbackRate = savedSpeed / 100;
    audioPlayer.preservesPitch = false;
}

// Toggle use saved speed
function toggleUseSavedSpeed() {
    useSavedSpeed = document.getElementById('useSavedSpeedCheckbox').checked;
    
    // If enabling and there's a current song, load its saved speed
    if (useSavedSpeed && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        loadSavedSpeed(currentFile.name);
    }
}

// Save fades for current song
async function saveFades() {
    if (!currentlyPlayingFile) {
        console.warn('No song currently playing');
        return;
    }
    if (currentlyPlayingFile) {
        markAsNotDuped(currentlyPlayingFile.name);
    }
    const currentFile = currentlyPlayingFile;
    const fadeIn = parseInt(fadeInSlider.value);
    const fadeOut = parseInt(fadeOutSlider.value);
    
    // Update configuration
    updateSongConfig(currentFile.name, { FI: fadeIn, FO: fadeOut });
    
    // Save configuration file
    await saveConfig();
    
    console.log(`Fades saved: ${currentFile.name}: FI=${fadeIn}s, FO=${fadeOut}s`);
    
    // Visual feedback
    const saveBtn = document.querySelector('.save-fades-btn');
    if (saveBtn) {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = '‚úì Saved';
        saveBtn.style.background = currentAccentGradient;
        saveBtn.style.color = '#1a1a1a';
        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
            saveBtn.style.color = '';
        }, 1500);
    }
}

// Load saved fades for a song
function loadSavedFades(filename) {
    const config = getSongConfig(filename);
    let savedFadeIn = 0;
    let savedFadeOut = 0;
    
    if (config.FI !== null && config.FI !== undefined) {
        savedFadeIn = config.FI;
    }
    
    if (config.FO !== null && config.FO !== undefined) {
        savedFadeOut = config.FO;
    }
    
    console.log(`Loaded saved fades for ${filename}: FI=${savedFadeIn}s, FO=${savedFadeOut}s`);
    
    // Update sliders
    fadeInSlider.value = savedFadeIn;
    fadeInValue.textContent = savedFadeIn;
    fadeOutSlider.value = savedFadeOut;
    fadeOutValue.textContent = savedFadeOut;
    
    currentFadeInDuration = savedFadeIn;
    currentFadeOutDuration = savedFadeOut;
}

// Toggle use saved fades
function toggleUseSavedFades() {
    useSavedFades = document.getElementById('useSavedFadesCheckbox').checked;
    
    // If enabling and there's a current song, load its saved fades
    if (useSavedFades && audioFiles.length > 0 && currentIndex >= 0) {
        const currentFile = audioFiles[currentIndex];
        loadSavedFades(currentFile.name);
    }
    
    // Save setting
    saveConfig();
}

// Apply fade in effect
function applyFadeIn() {
    if (currentFadeInDuration === 0 || !audioPlayer.src) return;
    
    isFadingIn = true;
    originalVolume = volumeSlider.value / 100;
    
    // Start at 0 volume
    audioPlayer.volume = 0;
    
    const startTime = Date.now();
    const fadeInMs = currentFadeInDuration * 1000;
    
    if (fadeInInterval) clearInterval(fadeInInterval);
    
    fadeInInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fadeInMs, 1);
        
        // Linear fade in
        audioPlayer.volume = originalVolume * progress;
        
        if (progress >= 1) {
            clearInterval(fadeInInterval);
            fadeInInterval = null;
            isFadingIn = false;
            audioPlayer.volume = originalVolume;
        }
    }, 20);
}

// Apply fade out effect
function applyFadeOut() {
    if (currentFadeOutDuration === 0 || !audioPlayer.src) return;
    
    isFadingOut = true;
    originalVolume = volumeSlider.value / 100;
    
    const fadeOutMs = currentFadeOutDuration * 1000;
    const startTime = Date.now();
    const startVolume = audioPlayer.volume;
    
    if (fadeOutInterval) clearInterval(fadeOutInterval);
    
    fadeOutInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / fadeOutMs, 1);
        
        // Linear fade out
        audioPlayer.volume = startVolume * (1 - progress);
        
        if (progress >= 1) {
            clearInterval(fadeOutInterval);
            fadeOutInterval = null;
            isFadingOut = false;
        }
    }, 20);
}

// Stop any active fades
function stopFades() {
    if (fadeInInterval) {
        clearInterval(fadeInInterval);
        fadeInInterval = null;
    }
    if (fadeOutInterval) {
        clearInterval(fadeOutInterval);
        fadeOutInterval = null;
    }
    isFadingIn = false;
    isFadingOut = false;
    
    // Restore original volume
    if (audioPlayer.src) {
        audioPlayer.volume = volumeSlider.value / 100;
    }
}

// Toggle prioritize new songs
function togglePrioritizeNewSongs() {
    prioritizeNewSongs = document.getElementById('prioritizeNewSongsCheckbox').checked;
    
    // Save setting
    saveConfig();
    
    console.log('Prioritize new songs:', prioritizeNewSongs ? 'enabled' : 'disabled');
}

// Mark current song as heard if conditions are met
function checkAndMarkAsHeard() {
    if (!currentlyPlayingFile || hasMarkedAsHeard) return;
    
    const duration = audioPlayer.duration;
    const currentTime = audioPlayer.currentTime;
    
    // Mark as heard if played for 15+ seconds, or entire song if less than 15 seconds
    const threshold = duration < 15 ? duration : 15;
    
    if (currentTime >= threshold) {
        updateSongConfig(currentlyPlayingFile.name, { heardb4: true });
        hasMarkedAsHeard = true;
        
        // Save immediately
        saveConfig();
        
        console.log(`Marked as heard: ${currentlyPlayingFile.name}`);
    }
}

// Check if all songs have been heard and reset if so
function checkAndResetHeardStatus() {
    if (!prioritizeNewSongs) return false;
    
    // Get all songs in the folder (audioFiles represents the actual files)
    const allFilesInFolder = originalOrder.map(file => file.name);
    
    if (allFilesInFolder.length === 0) return false;
    
    // Check if ALL songs in the folder have been heard
    const allHeard = allFilesInFolder.every(filename => {
        const config = getSongConfig(filename);
        return config.heardb4 === true;
    });
    
    if (allHeard) {
        console.log('All songs in folder have been heard. Resetting heard status for all songs.');
        
        // Reset all songs in the folder to unheard
        allFilesInFolder.forEach(filename => {
            updateSongConfig(filename, { heardb4: false });
        });
        
        // Save config
        saveConfig();
        
        return true;
    }
    
    return false;
}

// Select JSON file for merging
async function selectJsonFile(jsonNumber) {
    try {
        // Open file picker for JSON files
        const [fileHandle] = await window.showOpenFilePicker({
            types: [{
                description: 'JSON Files',
                accept: { 'application/json': ['.json'] }
            }],
            multiple: false
        });
        
        const file = await fileHandle.getFile();
        const text = await file.text();
        
        // Parse and validate JSON
        let jsonData;
        try {
            jsonData = JSON.parse(text);
        } catch (e) {
            alert('Invalid JSON file. Please select a valid u-groove-config.json file.');
            return;
        }
        
        // Store the data
        if (jsonNumber === 1) {
            json1Data = jsonData;
            json1FileName = file.name;
            document.getElementById('json1Btn').classList.add('selected');
            document.getElementById('json1Info').textContent = file.name;
            console.log('JSON 1 loaded:', file.name);
        } else {
            json2Data = jsonData;
            json2FileName = file.name;
            document.getElementById('json2Btn').classList.add('selected');
            document.getElementById('json2Info').textContent = file.name;
            console.log('JSON 2 loaded:', file.name);
        }
        
        // Enable merge button if both files are selected
        if (json1Data && json2Data) {
            document.getElementById('mergeBtn').disabled = false;
        }
        
    } catch (err) {
        console.error('Error selecting file:', err);
    }
}

// Merge JSON files
async function mergeJsonFiles() {
    if (!json1Data || !json2Data) {
        alert('Please select both JSON files before merging.');
        return;
    }
    
    console.log('Starting merge...');
    
    // Create merged data structure starting with JSON 1
    const mergedData = {
        songs: JSON.parse(JSON.stringify(json1Data.songs || {})),
        masterTags: JSON.parse(JSON.stringify(json1Data.masterTags || {})),
        appSettings: JSON.parse(JSON.stringify(json2Data.appSettings || json1Data.appSettings || {}))
    };
    
    // Merge songs from JSON 2 into JSON 1
    const json2Songs = json2Data.songs || {};
    
    Object.keys(json2Songs).forEach(filename => {
        const json2Song = json2Songs[filename];
        
        if (!mergedData.songs[filename]) {
            // Song doesn't exist in JSON 1, add it completely
            mergedData.songs[filename] = JSON.parse(JSON.stringify(json2Song));
            console.log(`Added new song: ${filename}`);
        } else {
            // Song exists in both, merge properties
            const json1Song = mergedData.songs[filename];
            
            // Merge tags (add unique tags from JSON 2)
            if (json2Song.tags && Array.isArray(json2Song.tags)) {
                const json1Tags = new Set(json1Song.tags || []);
                json2Song.tags.forEach(tag => json1Tags.add(tag));
                mergedData.songs[filename].tags = Array.from(json1Tags);
            }
            
            // Overwrite speed if JSON 2 has a non-null value
            if (json2Song.speed !== null && json2Song.speed !== undefined) {
                mergedData.songs[filename].speed = json2Song.speed;
            }
            
            // Overwrite trimStart if JSON 2 has a non-null value
            if (json2Song.trimStart !== null && json2Song.trimStart !== undefined) {
                mergedData.songs[filename].trimStart = json2Song.trimStart;
            }
            
            // Overwrite trimEnd if JSON 2 has a non-null value
            if (json2Song.trimEnd !== null && json2Song.trimEnd !== undefined) {
                mergedData.songs[filename].trimEnd = json2Song.trimEnd;
            }
            
            // Overwrite FI if JSON 2 has a value greater than 0
            if (json2Song.FI && json2Song.FI > 0) {
                mergedData.songs[filename].FI = json2Song.FI;
            }
            
            // Overwrite FO if JSON 2 has a value greater than 0
            if (json2Song.FO && json2Song.FO > 0) {
                mergedData.songs[filename].FO = json2Song.FO;
            }
            
            // Overwrite heardb4 if JSON 2 has it as true
            if (json2Song.heardb4 === true) {
                mergedData.songs[filename].heardb4 = true;
            }
            
            console.log(`Merged song: ${filename}`);
        }
    });
    
    // Merge master tags from JSON 2
    const json2Tags = json2Data.masterTags || {};
    
    Object.keys(json2Tags).forEach(tagName => {
        if (!mergedData.masterTags[tagName]) {
            // Tag doesn't exist in JSON 1, add it
            mergedData.masterTags[tagName] = JSON.parse(JSON.stringify(json2Tags[tagName]));
            console.log(`Added new tag: ${tagName}`);
        }
        // If tag exists, we'll recalculate song counts below
    });
    
    // Recalculate song counts for all tags based on merged songs
    Object.keys(mergedData.masterTags).forEach(tagName => {
        let count = 0;
        Object.keys(mergedData.songs).forEach(filename => {
            const song = mergedData.songs[filename];
            if (song.tags && song.tags.includes(tagName)) {
                count++;
            }
        });
        mergedData.masterTags[tagName].songCount = count;
        console.log(`Updated tag count for ${tagName}: ${count}`);
    });
    
    // Remove tags with 0 songs
    Object.keys(mergedData.masterTags).forEach(tagName => {
        if (mergedData.masterTags[tagName].songCount === 0) {
            delete mergedData.masterTags[tagName];
            console.log(`Removed tag with 0 songs: ${tagName}`);
        }
    });
    
    console.log('Merge complete!');
    console.log('Total songs:', Object.keys(mergedData.songs).length);
    console.log('Total tags:', Object.keys(mergedData.masterTags).length);
    
    // Download the merged JSON
    downloadMergedJson(mergedData);
    
    // Reset the merge UI
    resetMergeUI();
}

// Download merged JSON file
function downloadMergedJson(mergedData) {
    const jsonString = JSON.stringify(mergedData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'u-groove-config-merged.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    alert('Merged JSON file has been downloaded as "u-groove-config-merged.json". Replace your current config file with this merged version.');
}

// Reset merge UI
function resetMergeUI() {
    json1Data = null;
    json2Data = null;
    json1FileName = '';
    json2FileName = '';
    
    document.getElementById('json1Btn').classList.remove('selected');
    document.getElementById('json2Btn').classList.remove('selected');
    document.getElementById('json1Info').textContent = 'No file selected';
    document.getElementById('json2Info').textContent = 'No file selected';
    document.getElementById('mergeBtn').disabled = true;
}

// Get next unheard song index
function getNextUnheardSongIndex(direction = 'next') {
    console.log('=== getNextUnheardSongIndex called ===');
    console.log('prioritizeNewSongs:', prioritizeNewSongs);
    console.log('direction:', direction);
    console.log('currentIndex:', currentIndex);
    console.log('audioFiles.length:', audioFiles.length);
    
    if (!prioritizeNewSongs || audioFiles.length === 0) {
        const nextIndex = direction === 'next' 
            ? (currentIndex + 1) % audioFiles.length 
            : (currentIndex - 1 + audioFiles.length) % audioFiles.length;
        console.log('Prioritize disabled or no files, returning:', nextIndex);
        return nextIndex;
    }
    
    // Check if all songs have been heard and reset if needed
    const didReset = checkAndResetHeardStatus();
    console.log('Did reset heard status?', didReset);
    
    // Find next unheard song in the current filtered/sorted list
    let searchIndex = currentIndex;
    let attempts = 0;
    const maxAttempts = audioFiles.length;
    
    console.log('Starting search from index:', searchIndex);
    
    while (attempts < maxAttempts) {
        // Move to next/previous song
        if (direction === 'next') {
            searchIndex = (searchIndex + 1) % audioFiles.length;
        } else {
            searchIndex = (searchIndex - 1 + audioFiles.length) % audioFiles.length;
        }
        
        const file = audioFiles[searchIndex];
        const config = getSongConfig(file.name);
        
        console.log(`Checking index ${searchIndex}: ${file.name}`);
        console.log('  heardb4 value:', config.heardb4);
        
        // If this song hasn't been heard, return its index
        if (!config.heardb4 || config.heardb4 === false) {
            console.log(`‚úì Found unheard song at index ${searchIndex}: ${file.name}`);
            return searchIndex;
        }
        
        attempts++;
    }
    
    // If all songs in current list have been heard, return next in sequence
    console.log('All songs in current list have been heard, playing next in sequence');
    const nextIndex = direction === 'next' 
        ? (currentIndex + 1) % audioFiles.length 
        : (currentIndex - 1 + audioFiles.length) % audioFiles.length;
    console.log('Returning sequential index:', nextIndex);
    return nextIndex;
}

// Parse saved speed from comments
function parseSpeedFromComments(comments) {
    const match = comments.match(/PS:\s*(\d+)/);
    if (match) {
        return parseInt(match[1]);
    }
    return null;
}

// Update compact player display
function updateCompactPlayer() {
    const compactTitle = document.getElementById('compactTitle');
    const compactTime = document.getElementById('compactTime');
    const playBtnCompact = document.getElementById('playBtnCompact');
    
    if (currentlyPlayingFile) {
        // Get tag count for this song
        const config = getSongConfig(currentlyPlayingFile.name);
        const tagCount = config.tags ? config.tags.length : 0;
        const tagCountText = tagCount > 0 ? ` (${tagCount} tag${tagCount !== 1 ? 's' : ''})` : '';
        
        compactTitle.textContent = `${currentlyPlayingFile.name}${tagCountText}`;
    } else {
        compactTitle.textContent = 'No track playing';
    }
    
    compactTime.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
    playBtnCompact.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
}

// Update now playing display with tag count
function updateNowPlayingDisplay() {
    if (!currentlyPlayingFile) {
        nowPlaying.textContent = 'No track playing';
        return;
    }
    
    // Get tag count for this song
    const config = getSongConfig(currentlyPlayingFile.name);
    const tagCount = config.tags ? config.tags.length : 0;
    const tagCountText = tagCount > 0 ? ` (${tagCount} tag${tagCount !== 1 ? 's' : ''})` : '';
    
    nowPlaying.textContent = `Now playing: ${currentlyPlayingFile.name}${tagCountText}`;
}

        // Set normalize button to active on load since it's on by default

// Visualizer control sliders
const minFreqSlider = document.getElementById('minFreqSlider');
const minFreqValue = document.getElementById('minFreqValue');
const maxFreqSlider = document.getElementById('maxFreqSlider');
const maxFreqValue = document.getElementById('maxFreqValue');
const minHeightSlider = document.getElementById('minHeightSlider');
const minHeightValue = document.getElementById('minHeightValue');
const maxHeightSlider = document.getElementById('maxHeightSlider');
const maxHeightValue = document.getElementById('maxHeightValue');
const waveformSensitivitySlider = document.getElementById('waveformSensitivitySlider');
const waveformSensitivityValue = document.getElementById('waveformSensitivityValue');

minFreqSlider.addEventListener('input', (e) => {
    minFrequency = parseInt(e.target.value);
    minFreqValue.textContent = minFrequency;
});

maxFreqSlider.addEventListener('input', (e) => {
    maxFrequency = parseInt(e.target.value);
    maxFreqValue.textContent = maxFrequency;
});

minHeightSlider.addEventListener('input', (e) => {
    minBarHeight = parseInt(e.target.value);
    minHeightValue.textContent = minBarHeight;
});

maxHeightSlider.addEventListener('input', (e) => {
    maxBarHeight = parseInt(e.target.value);
    maxHeightValue.textContent = maxBarHeight;
});

waveformSensitivitySlider.addEventListener('input', (e) => {
    waveformSensitivity = parseFloat(e.target.value);
    waveformSensitivityValue.textContent = waveformSensitivity.toFixed(1) + 'x';
});

// Tab visibility detection
document.addEventListener('visibilitychange', () => {
    isTabVisible = !document.hidden;
});

// Sort select change handler
const sortSelect = document.getElementById('sortSelect');
if (sortSelect) {
    sortSelect.addEventListener('change', (e) => {
        sortBy = e.target.value;
        updateAudioFilesList();
    });
}

// Apply accent colors to sort controls
const sortOrderBtn = document.getElementById('sortOrderBtn');
const scrollToSongBtn = document.querySelector('.scroll-to-song-btn');

sortSelect.addEventListener('focus', () => {
    sortSelect.style.borderColor = accentColor1;
});

sortSelect.addEventListener('blur', () => {
    sortSelect.style.borderColor = '#3a3a3a';
});

// Trim functionality
let trimStartTime = 0;
let trimEndTime = 0;
let trimZoomLevel = 1;
let trimScrollOffset = 0;
let trimWaveformData = null;
let trimCurrentFile = null;
let isDraggingTrimHandle = null;
let isPanningWaveform = false;
let panStartX = 0;
let panStartOffset = 0;

// Open trim window
async function openTrimWindow() {
    if (audioFiles.length === 0 || currentIndex < 0) {
        alert('Please select a song first');
        return;
    }
    
    trimCurrentFile = audioFiles[currentIndex];
    const config = getSongConfig(trimCurrentFile.name);
    
    // Load existing trim points or use defaults
    trimStartTime = config.trimStart || 0;
    trimEndTime = config.trimEnd || audioPlayer.duration || 0;
    
    // If no trim end is set, use the audio duration
    if (trimEndTime === 0 && audioPlayer.duration) {
        trimEndTime = audioPlayer.duration;
    }
    
    // Reset zoom and scroll
    trimZoomLevel = 1;
    trimScrollOffset = 0;
    
    // Show overlay
    document.getElementById('trimOverlay').classList.add('active');
    document.getElementById('trimHeader').textContent = `Trim: ${trimCurrentFile.name}`;
    
    // Load waveform data
    await loadTrimWaveform();
    
    // Setup drag handlers
    setupTrimHandlers();
    
    // Initial draw
    drawTrimWaveform();
    updateTrimDisplay();
}

// Close trim window
function closeTrimWindow() {
    document.getElementById('trimOverlay').classList.remove('active');
    trimWaveformData = null;
    trimCurrentFile = null;
}

// Load waveform data for trimming
async function loadTrimWaveform() {
    if (!trimCurrentFile) return;
    
    try {
        // Create an offline audio context to decode the entire file
        const arrayBuffer = await trimCurrentFile.arrayBuffer();
        const offlineContext = new OfflineAudioContext(1, 44100 * 30, 44100);
        const audioBuffer = await offlineContext.decodeAudioData(arrayBuffer);
        
        // Get channel data
        const channelData = audioBuffer.getChannelData(0);
        const duration = audioBuffer.duration;
        
        // If we don't have a trim end time yet, set it to duration
        if (trimEndTime === 0) {
            trimEndTime = duration;
        }
        
        trimWaveformData = {
            data: channelData,
            duration: duration,
            sampleRate: audioBuffer.sampleRate
        };
        
    } catch (error) {
        console.error('Error loading waveform:', error);
        alert('Error loading waveform data');
    }
}

// Draw trim waveform
function drawTrimWaveform() {
    if (!trimWaveformData) return;
    
    const canvas = document.getElementById('trimWaveformCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('trimWaveformContainer');
    
    // Set canvas size
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    
    // Clear canvas
    ctx.fillStyle = '#0f0f0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const { data, duration } = trimWaveformData;
    const width = canvas.width;
    const height = canvas.height;
    const centerY = height / 2;
    
    // Calculate visible time range based on zoom and scroll
    const visibleDuration = duration / trimZoomLevel;
    const startTime = trimScrollOffset;
    const endTime = Math.min(startTime + visibleDuration, duration);
    
    // Calculate samples per pixel
    const samplesPerPixel = Math.floor((data.length * (endTime - startTime) / duration) / width);
    
    // Draw waveform
    ctx.beginPath();
    ctx.strokeStyle = accentColor1;
    ctx.lineWidth = 1;
    
    for (let x = 0; x < width; x++) {
        const time = startTime + (x / width) * (endTime - startTime);
        const sampleIndex = Math.floor((time / duration) * data.length);
        
        // Get min/max for this pixel
        let min = 1;
        let max = -1;
        
        for (let s = 0; s < samplesPerPixel && sampleIndex + s < data.length; s++) {
            const value = data[sampleIndex + s];
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        
        const yMin = centerY - (min * centerY);
        const yMax = centerY - (max * centerY);
        
        ctx.moveTo(x, yMin);
        ctx.lineTo(x, yMax);
    }
    
    ctx.stroke();
    
    // Update handle positions
    updateTrimHandlePositions();
}

// Update trim handle positions
function updateTrimHandlePositions() {
    if (!trimWaveformData) return;
    
    const container = document.getElementById('trimWaveformContainer');
    const width = container.offsetWidth;
    if (!trimWaveformData) return;
    const duration = trimWaveformData.duration;
    
    // Calculate visible time range
    const visibleDuration = duration / trimZoomLevel;
    const startTime = trimScrollOffset;
    const endTime = Math.min(startTime + visibleDuration, duration);
    
    // Calculate handle positions relative to visible range
    const startPos = ((trimStartTime - startTime) / (endTime - startTime)) * width;
    const endPos = ((trimEndTime - startTime) / (endTime - startTime)) * width;
    
    // Update handle elements
    const startHandle = document.getElementById('trimHandleStart');
    const endHandle = document.getElementById('trimHandleEnd');
    const region = document.getElementById('trimRegion');
    
    startHandle.style.left = `${Math.max(0, Math.min(width, startPos))}px`;
    endHandle.style.left = `${Math.max(0, Math.min(width, endPos))}px`;
    
    region.style.left = `${Math.max(0, startPos)}px`;
    region.style.width = `${Math.max(0, endPos - startPos)}px`;
}

// Setup trim drag handlers
function setupTrimHandlers() {
    const container = document.getElementById('trimWaveformContainer');
    const startHandle = document.getElementById('trimHandleStart');
    const endHandle = document.getElementById('trimHandleEnd');
    
    // Handle dragging
    startHandle.onmousedown = (e) => {
        e.stopPropagation();
        isDraggingTrimHandle = 'start';
    };
    
    endHandle.onmousedown = (e) => {
        e.stopPropagation();
        isDraggingTrimHandle = 'end';
    };
    
    // Panning
    container.onmousedown = (e) => {
        if (isDraggingTrimHandle) return;
        isPanningWaveform = true;
        panStartX = e.clientX;
        panStartOffset = trimScrollOffset;
    };
    
    document.onmousemove = (e) => {
        if (isDraggingTrimHandle) {
            const container = document.getElementById('trimWaveformContainer');
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            if (!trimWaveformData) return;
            const duration = trimWaveformData.duration;
            
            // Calculate time from position
            const visibleDuration = duration / trimZoomLevel;
            const startTime = trimScrollOffset;
            const endTime = Math.min(startTime + visibleDuration, duration);
            const time = startTime + (x / width) * (endTime - startTime);
            
            if (isDraggingTrimHandle === 'start') {
                trimStartTime = Math.max(0, Math.min(time, trimEndTime - 0.01));
            } else if (isDraggingTrimHandle === 'end') {
                trimEndTime = Math.max(trimStartTime + 0.01, Math.min(time, duration));
            }
            
            updateTrimDisplay();
            updateTrimHandlePositions();
        } else if (isPanningWaveform) {
            const container = document.getElementById('trimWaveformContainer');
            const rect = container.getBoundingClientRect();
            const deltaX = e.clientX - panStartX;
            if (!trimWaveformData) return;
            const duration = trimWaveformData.duration;
            const visibleDuration = duration / trimZoomLevel;
            
            // Convert pixel delta to time delta
            const timeDelta = (deltaX / rect.width) * visibleDuration;
            trimScrollOffset = Math.max(0, Math.min(panStartOffset - timeDelta, duration - visibleDuration));
            
            drawTrimWaveform();
        }
    };
    
    document.onmouseup = () => {
        isDraggingTrimHandle = null;
        isPanningWaveform = false;
    };
}

// Adjust trim zoom
function adjustTrimZoom(delta) {
    if (!trimWaveformData) return;
    trimZoomLevel = Math.max(1, Math.min(20, trimZoomLevel + delta));
    
    // Adjust scroll offset to keep centered
    const duration = trimWaveformData.duration;
    const visibleDuration = duration / trimZoomLevel;
    trimScrollOffset = Math.max(0, Math.min(trimScrollOffset, duration - visibleDuration));
    
    drawTrimWaveform();
}

// Reset trim zoom
function resetTrimZoom() {
    trimZoomLevel = 1;
    trimScrollOffset = 0;
    drawTrimWaveform();
}

// Update trim display
function updateTrimDisplay() {
    document.getElementById('trimStartTime').textContent = formatTimeWithMs(trimStartTime);
    document.getElementById('trimEndTime').textContent = formatTimeWithMs(trimEndTime);
    document.getElementById('trimDuration').textContent = formatTimeWithMs(trimEndTime - trimStartTime);
}

// Format time with milliseconds
function formatTimeWithMs(seconds) {
    if (isNaN(seconds)) return '0:00.00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 100);
    return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
}

// Save trim settings
async function saveTrimSettings() {
    if (!currentlyPlayingFile) return;
    
    if (currentlyPlayingFile) {
        markAsNotDuped(currentlyPlayingFile.name);
    }
    // Update configuration
    updateSongConfig(currentlyPlayingFile.name, {
        trimStart: trimStartTime,
        trimEnd: trimEndTime
    });
    
    // Save configuration file
    await saveConfig();
    
    console.log('Trim saved for:', trimCurrentFile.name, {
        start: trimStartTime,
        end: trimEndTime
    });
    
    closeTrimWindow();
    
    // If this is the currently playing song, apply trim immediately
     if (isPlaying) {
        applyTrimToCurrentSong();
    }
}

// Apply trim to currently playing song
function applyTrimToCurrentSong() {
    if (audioFiles.length === 0 || currentIndex < 0) return;
    
    const file = audioFiles[currentIndex];
    const config = getSongConfig(file.name);
    
    if (config.trimStart !== null && config.trimStart !== undefined) {
        audioPlayer.currentTime = config.trimStart;
    }
}

// Open trim window
async function openTrimWindow() {
    if (!currentlyPlayingFile) {
        alert('Please select a song first');
        return;
    }
    
    trimCurrentFile = currentlyPlayingFile;
    const config = getSongConfig(trimCurrentFile.name);
    
    // Load existing trim points or use defaults
    trimStartTime = config.trimStart || 0;
    trimEndTime = config.trimEnd || audioPlayer.duration || 0;
    
    // If no trim end is set, use the audio duration
    if (trimEndTime === 0 && audioPlayer.duration) {
        trimEndTime = audioPlayer.duration;
    }
    
    // Reset zoom and scroll
    trimZoomLevel = 1;
    trimScrollOffset = 0;
    
    // Show overlay
    document.getElementById('trimOverlay').classList.add('active');
    document.getElementById('trimHeader').textContent = `Trim: ${trimCurrentFile.name}`;
    
    // Load waveform data
    await loadTrimWaveform();
    
    // Setup drag handlers
    setupTrimHandlers();
    
    // Initial draw
    drawTrimWaveform();
    updateTrimDisplay();
}

// Parse trim times from comments
function parseTrimFromComments(comments) {
    const startMatch = comments.match(/ST:\s*([\d.]+)/);
    const endMatch = comments.match(/ET:\s*([\d.]+)/);
    
    return {
        trimStart: startMatch ? parseFloat(startMatch[1]) : undefined,
        trimEnd: endMatch ? parseFloat(endMatch[1]) : undefined
    };
}


window.addEventListener('load', async () => {
    normalizeBtn.classList.add('active');
    normalizeBtn.style.background = currentAccentGradient;
    normalizeBtn.style.color = '#1a1a1a';
    normalizeBtn.style.borderImage = 'none';
    
    // Initialize accent colors
    updateAccentColors(accentColor1, accentColor2);
    
    updateFavicon(accentColor1, accentColor2);
});
    </script>
</body>
</html>
